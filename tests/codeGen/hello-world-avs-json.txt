[
  {
    "path": "abis/ECDSAStakeRegistry.json",
    "summary": "JSON ABI with 50 entries.",
    "content": "[\n  {\n    \"type\": \"constructor\",\n    \"inputs\": [\n      {\n        \"name\": \"_delegationManager\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IDelegationManager\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"deregisterOperator\",\n    \"inputs\": [],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getLastCheckpointOperatorWeight\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getLastCheckpointThresholdWeight\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getLastCheckpointThresholdWeightAtBlock\",\n    \"inputs\": [\n      {\n        \"name\": \"blockNumber\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getLastCheckpointTotalWeight\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getLastCheckpointTotalWeightAtBlock\",\n    \"inputs\": [\n      {\n        \"name\": \"blockNumber\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getLatestOperatorSigningKey\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorSigningKeyAtBlock\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"blockNumber\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorWeight\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorWeightAtBlock\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"blockNumber\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"initialize\",\n    \"inputs\": [\n      {\n        \"name\": \"_serviceManager\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"thresholdWeight\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"quorum\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IECDSAStakeRegistryTypes.Quorum\",\n        \"components\": [\n          {\n            \"name\": \"strategies\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct IECDSAStakeRegistryTypes.StrategyParams[]\",\n            \"components\": [\n              {\n                \"name\": \"strategy\",\n                \"type\": \"address\",\n                \"internalType\": \"contract IStrategy\"\n              },\n              {\n                \"name\": \"multiplier\",\n                \"type\": \"uint96\",\n                \"internalType\": \"uint96\"\n              }\n            ]\n          }\n        ]\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"isValidSignature\",\n    \"inputs\": [\n      {\n        \"name\": \"digest\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"_signatureData\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes4\",\n        \"internalType\": \"bytes4\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"minimumWeight\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"operatorRegistered\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"owner\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"quorum\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IECDSAStakeRegistryTypes.Quorum\",\n        \"components\": [\n          {\n            \"name\": \"strategies\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct IECDSAStakeRegistryTypes.StrategyParams[]\",\n            \"components\": [\n              {\n                \"name\": \"strategy\",\n                \"type\": \"address\",\n                \"internalType\": \"contract IStrategy\"\n              },\n              {\n                \"name\": \"multiplier\",\n                \"type\": \"uint96\",\n                \"internalType\": \"uint96\"\n              }\n            ]\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"registerOperatorWithSignature\",\n    \"inputs\": [\n      {\n        \"name\": \"operatorSignature\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct ISignatureUtils.SignatureWithSaltAndExpiry\",\n        \"components\": [\n          {\n            \"name\": \"signature\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          },\n          {\n            \"name\": \"salt\",\n            \"type\": \"bytes32\",\n            \"internalType\": \"bytes32\"\n          },\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      },\n      {\n        \"name\": \"signingKey\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"renounceOwnership\",\n    \"inputs\": [],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"transferOwnership\",\n    \"inputs\": [\n      {\n        \"name\": \"newOwner\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateMinimumWeight\",\n    \"inputs\": [\n      {\n        \"name\": \"newMinimumWeight\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"operators\",\n        \"type\": \"address[]\",\n        \"internalType\": \"address[]\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateOperatorSigningKey\",\n    \"inputs\": [\n      {\n        \"name\": \"newSigningKey\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateOperators\",\n    \"inputs\": [\n      {\n        \"name\": \"operators\",\n        \"type\": \"address[]\",\n        \"internalType\": \"address[]\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateOperatorsForQuorum\",\n    \"inputs\": [\n      {\n        \"name\": \"operatorsPerQuorum\",\n        \"type\": \"address[][]\",\n        \"internalType\": \"address[][]\"\n      },\n      {\n        \"name\": \"\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateQuorumConfig\",\n    \"inputs\": [\n      {\n        \"name\": \"quorum\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IECDSAStakeRegistryTypes.Quorum\",\n        \"components\": [\n          {\n            \"name\": \"strategies\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct IECDSAStakeRegistryTypes.StrategyParams[]\",\n            \"components\": [\n              {\n                \"name\": \"strategy\",\n                \"type\": \"address\",\n                \"internalType\": \"contract IStrategy\"\n              },\n              {\n                \"name\": \"multiplier\",\n                \"type\": \"uint96\",\n                \"internalType\": \"uint96\"\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"name\": \"operators\",\n        \"type\": \"address[]\",\n        \"internalType\": \"address[]\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateStakeThreshold\",\n    \"inputs\": [\n      {\n        \"name\": \"thresholdWeight\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"Initialized\",\n    \"inputs\": [\n      {\n        \"name\": \"version\",\n        \"type\": \"uint8\",\n        \"indexed\": false,\n        \"internalType\": \"uint8\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"MinimumWeightUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"previous\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"current\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorDeregistered\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"avs\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorRegistered\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"avs\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorWeightUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"oldWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"newWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OwnershipTransferred\",\n    \"inputs\": [\n      {\n        \"name\": \"previousOwner\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newOwner\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"QuorumUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"previous\",\n        \"type\": \"tuple\",\n        \"indexed\": false,\n        \"internalType\": \"struct IECDSAStakeRegistryTypes.Quorum\",\n        \"components\": [\n          {\n            \"name\": \"strategies\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct IECDSAStakeRegistryTypes.StrategyParams[]\",\n            \"components\": [\n              {\n                \"name\": \"strategy\",\n                \"type\": \"address\",\n                \"internalType\": \"contract IStrategy\"\n              },\n              {\n                \"name\": \"multiplier\",\n                \"type\": \"uint96\",\n                \"internalType\": \"uint96\"\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"name\": \"current\",\n        \"type\": \"tuple\",\n        \"indexed\": false,\n        \"internalType\": \"struct IECDSAStakeRegistryTypes.Quorum\",\n        \"components\": [\n          {\n            \"name\": \"strategies\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct IECDSAStakeRegistryTypes.StrategyParams[]\",\n            \"components\": [\n              {\n                \"name\": \"strategy\",\n                \"type\": \"address\",\n                \"internalType\": \"contract IStrategy\"\n              },\n              {\n                \"name\": \"multiplier\",\n                \"type\": \"uint96\",\n                \"internalType\": \"uint96\"\n              }\n            ]\n          }\n        ]\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"SigningKeyUpdate\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"updateBlock\",\n        \"type\": \"uint256\",\n        \"indexed\": true,\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"newSigningKey\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"oldSigningKey\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"ThresholdWeightUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"thresholdWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"TotalWeightUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"oldTotalWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"newTotalWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"UpdateMinimumWeight\",\n    \"inputs\": [\n      {\n        \"name\": \"oldMinimumWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"newMinimumWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InsufficientSignedStake\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InsufficientWeight\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidLength\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidQuorum\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidReferenceBlock\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidSignature\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidSignedWeight\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidThreshold\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"LengthMismatch\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"MustUpdateAllOperators\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"NotSorted\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OperatorAlreadyRegistered\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OperatorNotRegistered\",\n    \"inputs\": []\n  }\n]"
  },
  {
    "path": "abis/HelloWorldServiceManager.json",
    "summary": "JSON ABI with 39 entries.",
    "content": "[\n  {\n    \"type\": \"constructor\",\n    \"inputs\": [\n      {\n        \"name\": \"_avsDirectory\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_stakeRegistry\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_rewardsCoordinator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_delegationManager\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_allocationManager\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"addPendingAdmin\",\n    \"inputs\": [\n      {\n        \"name\": \"admin\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"allTaskHashes\",\n    \"inputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"allTaskResponses\",\n    \"inputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"allocationManager\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"avsDirectory\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"createAVSRewardsSubmission\",\n    \"inputs\": [\n      {\n        \"name\": \"rewardsSubmissions\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct IRewardsCoordinatorTypes.RewardsSubmission[]\",\n        \"components\": [\n          {\n            \"name\": \"strategiesAndMultipliers\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct IRewardsCoordinatorTypes.StrategyAndMultiplier[]\",\n            \"components\": [\n              {\n                \"name\": \"strategy\",\n                \"type\": \"address\",\n                \"internalType\": \"contract IStrategy\"\n              },\n              {\n                \"name\": \"multiplier\",\n                \"type\": \"uint96\",\n                \"internalType\": \"uint96\"\n              }\n            ]\n          },\n          {\n            \"name\": \"token\",\n            \"type\": \"address\",\n            \"internalType\": \"contract IERC20\"\n          },\n          {\n            \"name\": \"amount\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"startTimestamp\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"duration\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"createNewTask\",\n    \"inputs\": [\n      {\n        \"name\": \"name\",\n        \"type\": \"string\",\n        \"internalType\": \"string\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IHelloWorldServiceManager.Task\",\n        \"components\": [\n          {\n            \"name\": \"name\",\n            \"type\": \"string\",\n            \"internalType\": \"string\"\n          },\n          {\n            \"name\": \"taskCreatedBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"createOperatorDirectedAVSRewardsSubmission\",\n    \"inputs\": [\n      {\n        \"name\": \"operatorDirectedRewardsSubmissions\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct IRewardsCoordinatorTypes.OperatorDirectedRewardsSubmission[]\",\n        \"components\": [\n          {\n            \"name\": \"strategiesAndMultipliers\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct IRewardsCoordinatorTypes.StrategyAndMultiplier[]\",\n            \"components\": [\n              {\n                \"name\": \"strategy\",\n                \"type\": \"address\",\n                \"internalType\": \"contract IStrategy\"\n              },\n              {\n                \"name\": \"multiplier\",\n                \"type\": \"uint96\",\n                \"internalType\": \"uint96\"\n              }\n            ]\n          },\n          {\n            \"name\": \"token\",\n            \"type\": \"address\",\n            \"internalType\": \"contract IERC20\"\n          },\n          {\n            \"name\": \"operatorRewards\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct IRewardsCoordinatorTypes.OperatorReward[]\",\n            \"components\": [\n              {\n                \"name\": \"operator\",\n                \"type\": \"address\",\n                \"internalType\": \"address\"\n              },\n              {\n                \"name\": \"amount\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              }\n            ]\n          },\n          {\n            \"name\": \"startTimestamp\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"duration\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"description\",\n            \"type\": \"string\",\n            \"internalType\": \"string\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"deregisterOperatorFromAVS\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"deregisterOperatorFromOperatorSets\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"operatorSetIds\",\n        \"type\": \"uint32[]\",\n        \"internalType\": \"uint32[]\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorRestakedStrategies\",\n    \"inputs\": [\n      {\n        \"name\": \"_operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address[]\",\n        \"internalType\": \"address[]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getRestakeableStrategies\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address[]\",\n        \"internalType\": \"address[]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"initialize\",\n    \"inputs\": [\n      {\n        \"name\": \"initialOwner\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_rewardsInitiator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"latestTaskNum\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"owner\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"registerOperatorToAVS\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"operatorSignature\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct ISignatureUtils.SignatureWithSaltAndExpiry\",\n        \"components\": [\n          {\n            \"name\": \"signature\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          },\n          {\n            \"name\": \"salt\",\n            \"type\": \"bytes32\",\n            \"internalType\": \"bytes32\"\n          },\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"removeAdmin\",\n    \"inputs\": [\n      {\n        \"name\": \"admin\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"removeAppointee\",\n    \"inputs\": [\n      {\n        \"name\": \"appointee\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"target\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"selector\",\n        \"type\": \"bytes4\",\n        \"internalType\": \"bytes4\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"removePendingAdmin\",\n    \"inputs\": [\n      {\n        \"name\": \"pendingAdmin\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"renounceOwnership\",\n    \"inputs\": [],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"respondToTask\",\n    \"inputs\": [\n      {\n        \"name\": \"task\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IHelloWorldServiceManager.Task\",\n        \"components\": [\n          {\n            \"name\": \"name\",\n            \"type\": \"string\",\n            \"internalType\": \"string\"\n          },\n          {\n            \"name\": \"taskCreatedBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          }\n        ]\n      },\n      {\n        \"name\": \"referenceTaskIndex\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      },\n      {\n        \"name\": \"signature\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"rewardsInitiator\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setAVSRegistrar\",\n    \"inputs\": [\n      {\n        \"name\": \"registrar\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IAVSRegistrar\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setAppointee\",\n    \"inputs\": [\n      {\n        \"name\": \"appointee\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"target\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"selector\",\n        \"type\": \"bytes4\",\n        \"internalType\": \"bytes4\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setClaimerFor\",\n    \"inputs\": [\n      {\n        \"name\": \"claimer\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setRewardsInitiator\",\n    \"inputs\": [\n      {\n        \"name\": \"newRewardsInitiator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"stakeRegistry\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"transferOwnership\",\n    \"inputs\": [\n      {\n        \"name\": \"newOwner\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateAVSMetadataURI\",\n    \"inputs\": [\n      {\n        \"name\": \"_metadataURI\",\n        \"type\": \"string\",\n        \"internalType\": \"string\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"Initialized\",\n    \"inputs\": [\n      {\n        \"name\": \"version\",\n        \"type\": \"uint8\",\n        \"indexed\": false,\n        \"internalType\": \"uint8\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"NewTaskCreated\",\n    \"inputs\": [\n      {\n        \"name\": \"taskIndex\",\n        \"type\": \"uint32\",\n        \"indexed\": true,\n        \"internalType\": \"uint32\"\n      },\n      {\n        \"name\": \"task\",\n        \"type\": \"tuple\",\n        \"indexed\": false,\n        \"internalType\": \"struct IHelloWorldServiceManager.Task\",\n        \"components\": [\n          {\n            \"name\": \"name\",\n            \"type\": \"string\",\n            \"internalType\": \"string\"\n          },\n          {\n            \"name\": \"taskCreatedBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          }\n        ]\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OwnershipTransferred\",\n    \"inputs\": [\n      {\n        \"name\": \"previousOwner\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newOwner\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"RewardsInitiatorUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"prevRewardsInitiator\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newRewardsInitiator\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"TaskResponded\",\n    \"inputs\": [\n      {\n        \"name\": \"taskIndex\",\n        \"type\": \"uint32\",\n        \"indexed\": true,\n        \"internalType\": \"uint32\"\n      },\n      {\n        \"name\": \"task\",\n        \"type\": \"tuple\",\n        \"indexed\": false,\n        \"internalType\": \"struct IHelloWorldServiceManager.Task\",\n        \"components\": [\n          {\n            \"name\": \"name\",\n            \"type\": \"string\",\n            \"internalType\": \"string\"\n          },\n          {\n            \"name\": \"taskCreatedBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          }\n        ]\n      },\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"DelayPeriodNotPassed\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OnlyRegistryCoordinator\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OnlyRewardsInitiator\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OnlyStakeRegistry\",\n    \"inputs\": []\n  }\n]"
  },
  {
    "path": "abis/IAVSDirectory.json",
    "summary": "JSON ABI with 17 entries.",
    "content": "[\n  {\n    \"type\": \"function\",\n    \"name\": \"OPERATOR_AVS_REGISTRATION_TYPEHASH\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"OPERATOR_SET_REGISTRATION_TYPEHASH\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"calculateOperatorAVSRegistrationDigestHash\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"avs\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"salt\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"expiry\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"cancelSalt\",\n    \"inputs\": [\n      {\n        \"name\": \"salt\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"deregisterOperatorFromAVS\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"initialize\",\n    \"inputs\": [\n      {\n        \"name\": \"initialOwner\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"initialPausedStatus\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"operatorSaltIsSpent\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"salt\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"registerOperatorToAVS\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"operatorSignature\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct ISignatureUtils.SignatureWithSaltAndExpiry\",\n        \"components\": [\n          {\n            \"name\": \"signature\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          },\n          {\n            \"name\": \"salt\",\n            \"type\": \"bytes32\",\n            \"internalType\": \"bytes32\"\n          },\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateAVSMetadataURI\",\n    \"inputs\": [\n      {\n        \"name\": \"metadataURI\",\n        \"type\": \"string\",\n        \"internalType\": \"string\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"AVSMetadataURIUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"avs\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"metadataURI\",\n        \"type\": \"string\",\n        \"indexed\": false,\n        \"internalType\": \"string\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorAVSRegistrationStatusUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"avs\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"status\",\n        \"type\": \"uint8\",\n        \"indexed\": false,\n        \"internalType\": \"enum IAVSDirectoryTypes.OperatorAVSRegistrationStatus\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidSignature\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OperatorAlreadyRegisteredToAVS\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OperatorNotRegisteredToAVS\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OperatorNotRegisteredToEigenLayer\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"SaltSpent\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"SignatureExpired\",\n    \"inputs\": []\n  }\n]"
  },
  {
    "path": "abis/IDelegationManager.json",
    "summary": "JSON ABI with 63 entries.",
    "content": "[\n  {\n    \"type\": \"function\",\n    \"name\": \"DELEGATION_APPROVAL_TYPEHASH\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"beaconChainETHStrategy\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IStrategy\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"burnOperatorShares\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"strategy\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IStrategy\"\n      },\n      {\n        \"name\": \"prevMaxMagnitude\",\n        \"type\": \"uint64\",\n        \"internalType\": \"uint64\"\n      },\n      {\n        \"name\": \"newMaxMagnitude\",\n        \"type\": \"uint64\",\n        \"internalType\": \"uint64\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"calculateDelegationApprovalDigestHash\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_delegationApprover\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"approverSalt\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"expiry\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"calculateWithdrawalRoot\",\n    \"inputs\": [\n      {\n        \"name\": \"withdrawal\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IDelegationManagerTypes.Withdrawal\",\n        \"components\": [\n          {\n            \"name\": \"staker\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"delegatedTo\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"withdrawer\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"nonce\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"startBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"strategies\",\n            \"type\": \"address[]\",\n            \"internalType\": \"contract IStrategy[]\"\n          },\n          {\n            \"name\": \"scaledShares\",\n            \"type\": \"uint256[]\",\n            \"internalType\": \"uint256[]\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"pure\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"completeQueuedWithdrawal\",\n    \"inputs\": [\n      {\n        \"name\": \"withdrawal\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IDelegationManagerTypes.Withdrawal\",\n        \"components\": [\n          {\n            \"name\": \"staker\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"delegatedTo\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"withdrawer\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"nonce\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"startBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"strategies\",\n            \"type\": \"address[]\",\n            \"internalType\": \"contract IStrategy[]\"\n          },\n          {\n            \"name\": \"scaledShares\",\n            \"type\": \"uint256[]\",\n            \"internalType\": \"uint256[]\"\n          }\n        ]\n      },\n      {\n        \"name\": \"tokens\",\n        \"type\": \"address[]\",\n        \"internalType\": \"contract IERC20[]\"\n      },\n      {\n        \"name\": \"receiveAsTokens\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"completeQueuedWithdrawals\",\n    \"inputs\": [\n      {\n        \"name\": \"withdrawals\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct IDelegationManagerTypes.Withdrawal[]\",\n        \"components\": [\n          {\n            \"name\": \"staker\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"delegatedTo\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"withdrawer\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"nonce\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"startBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"strategies\",\n            \"type\": \"address[]\",\n            \"internalType\": \"contract IStrategy[]\"\n          },\n          {\n            \"name\": \"scaledShares\",\n            \"type\": \"uint256[]\",\n            \"internalType\": \"uint256[]\"\n          }\n        ]\n      },\n      {\n        \"name\": \"tokens\",\n        \"type\": \"address[][]\",\n        \"internalType\": \"contract IERC20[][]\"\n      },\n      {\n        \"name\": \"receiveAsTokens\",\n        \"type\": \"bool[]\",\n        \"internalType\": \"bool[]\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"convertToDepositShares\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"strategies\",\n        \"type\": \"address[]\",\n        \"internalType\": \"contract IStrategy[]\"\n      },\n      {\n        \"name\": \"withdrawableShares\",\n        \"type\": \"uint256[]\",\n        \"internalType\": \"uint256[]\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256[]\",\n        \"internalType\": \"uint256[]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"cumulativeWithdrawalsQueued\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"decreaseDelegatedShares\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"curDepositShares\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"beaconChainSlashingFactorDecrease\",\n        \"type\": \"uint64\",\n        \"internalType\": \"uint64\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"delegateTo\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"approverSignatureAndExpiry\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct ISignatureUtils.SignatureWithExpiry\",\n        \"components\": [\n          {\n            \"name\": \"signature\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          },\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      },\n      {\n        \"name\": \"approverSalt\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"delegatedTo\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"delegationApprover\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"delegationApproverSaltIsSpent\",\n    \"inputs\": [\n      {\n        \"name\": \"_delegationApprover\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"salt\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"depositScalingFactor\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"strategy\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IStrategy\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getDepositedShares\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address[]\",\n        \"internalType\": \"contract IStrategy[]\"\n      },\n      {\n        \"name\": \"\",\n        \"type\": \"uint256[]\",\n        \"internalType\": \"uint256[]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorShares\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"strategies\",\n        \"type\": \"address[]\",\n        \"internalType\": \"contract IStrategy[]\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256[]\",\n        \"internalType\": \"uint256[]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorsShares\",\n    \"inputs\": [\n      {\n        \"name\": \"operators\",\n        \"type\": \"address[]\",\n        \"internalType\": \"address[]\"\n      },\n      {\n        \"name\": \"strategies\",\n        \"type\": \"address[]\",\n        \"internalType\": \"contract IStrategy[]\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256[][]\",\n        \"internalType\": \"uint256[][]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getQueuedWithdrawal\",\n    \"inputs\": [\n      {\n        \"name\": \"withdrawalRoot\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IDelegationManagerTypes.Withdrawal\",\n        \"components\": [\n          {\n            \"name\": \"staker\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"delegatedTo\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"withdrawer\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"nonce\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"startBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"strategies\",\n            \"type\": \"address[]\",\n            \"internalType\": \"contract IStrategy[]\"\n          },\n          {\n            \"name\": \"scaledShares\",\n            \"type\": \"uint256[]\",\n            \"internalType\": \"uint256[]\"\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getQueuedWithdrawalRoots\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32[]\",\n        \"internalType\": \"bytes32[]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getQueuedWithdrawals\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"withdrawals\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct IDelegationManagerTypes.Withdrawal[]\",\n        \"components\": [\n          {\n            \"name\": \"staker\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"delegatedTo\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"withdrawer\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"nonce\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"startBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"strategies\",\n            \"type\": \"address[]\",\n            \"internalType\": \"contract IStrategy[]\"\n          },\n          {\n            \"name\": \"scaledShares\",\n            \"type\": \"uint256[]\",\n            \"internalType\": \"uint256[]\"\n          }\n        ]\n      },\n      {\n        \"name\": \"shares\",\n        \"type\": \"uint256[][]\",\n        \"internalType\": \"uint256[][]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getSlashableSharesInQueue\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"strategy\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IStrategy\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getWithdrawableShares\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"strategies\",\n        \"type\": \"address[]\",\n        \"internalType\": \"contract IStrategy[]\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"withdrawableShares\",\n        \"type\": \"uint256[]\",\n        \"internalType\": \"uint256[]\"\n      },\n      {\n        \"name\": \"depositShares\",\n        \"type\": \"uint256[]\",\n        \"internalType\": \"uint256[]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"increaseDelegatedShares\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"strategy\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IStrategy\"\n      },\n      {\n        \"name\": \"prevDepositShares\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"addedShares\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"initialize\",\n    \"inputs\": [\n      {\n        \"name\": \"initialOwner\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"initialPausedStatus\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"isDelegated\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"isOperator\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"minWithdrawalDelayBlocks\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"modifyOperatorDetails\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newDelegationApprover\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"queueWithdrawals\",\n    \"inputs\": [\n      {\n        \"name\": \"params\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct IDelegationManagerTypes.QueuedWithdrawalParams[]\",\n        \"components\": [\n          {\n            \"name\": \"strategies\",\n            \"type\": \"address[]\",\n            \"internalType\": \"contract IStrategy[]\"\n          },\n          {\n            \"name\": \"depositShares\",\n            \"type\": \"uint256[]\",\n            \"internalType\": \"uint256[]\"\n          },\n          {\n            \"name\": \"__deprecated_withdrawer\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32[]\",\n        \"internalType\": \"bytes32[]\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"redelegate\",\n    \"inputs\": [\n      {\n        \"name\": \"newOperator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newOperatorApproverSig\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct ISignatureUtils.SignatureWithExpiry\",\n        \"components\": [\n          {\n            \"name\": \"signature\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          },\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      },\n      {\n        \"name\": \"approverSalt\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"withdrawalRoots\",\n        \"type\": \"bytes32[]\",\n        \"internalType\": \"bytes32[]\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"registerAsOperator\",\n    \"inputs\": [\n      {\n        \"name\": \"initDelegationApprover\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"allocationDelay\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      },\n      {\n        \"name\": \"metadataURI\",\n        \"type\": \"string\",\n        \"internalType\": \"string\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"undelegate\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"withdrawalRoots\",\n        \"type\": \"bytes32[]\",\n        \"internalType\": \"bytes32[]\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateOperatorMetadataURI\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"metadataURI\",\n        \"type\": \"string\",\n        \"internalType\": \"string\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"DelegationApproverUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newDelegationApprover\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"DepositScalingFactorUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"strategy\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"contract IStrategy\"\n      },\n      {\n        \"name\": \"newDepositScalingFactor\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorMetadataURIUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"metadataURI\",\n        \"type\": \"string\",\n        \"indexed\": false,\n        \"internalType\": \"string\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorRegistered\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"delegationApprover\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorSharesBurned\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"strategy\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"contract IStrategy\"\n      },\n      {\n        \"name\": \"shares\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorSharesDecreased\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"strategy\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"contract IStrategy\"\n      },\n      {\n        \"name\": \"shares\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorSharesIncreased\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"strategy\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"contract IStrategy\"\n      },\n      {\n        \"name\": \"shares\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"SlashingWithdrawalCompleted\",\n    \"inputs\": [\n      {\n        \"name\": \"withdrawalRoot\",\n        \"type\": \"bytes32\",\n        \"indexed\": false,\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"SlashingWithdrawalQueued\",\n    \"inputs\": [\n      {\n        \"name\": \"withdrawalRoot\",\n        \"type\": \"bytes32\",\n        \"indexed\": false,\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"withdrawal\",\n        \"type\": \"tuple\",\n        \"indexed\": false,\n        \"internalType\": \"struct IDelegationManagerTypes.Withdrawal\",\n        \"components\": [\n          {\n            \"name\": \"staker\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"delegatedTo\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"withdrawer\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"nonce\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"startBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"strategies\",\n            \"type\": \"address[]\",\n            \"internalType\": \"contract IStrategy[]\"\n          },\n          {\n            \"name\": \"scaledShares\",\n            \"type\": \"uint256[]\",\n            \"internalType\": \"uint256[]\"\n          }\n        ]\n      },\n      {\n        \"name\": \"sharesToWithdraw\",\n        \"type\": \"uint256[]\",\n        \"indexed\": false,\n        \"internalType\": \"uint256[]\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"StakerDelegated\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"StakerForceUndelegated\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"StakerUndelegated\",\n    \"inputs\": [\n      {\n        \"name\": \"staker\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"ActivelyDelegated\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"CallerCannotUndelegate\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"FullySlashed\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InputArrayLengthMismatch\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InputArrayLengthZero\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidSignature\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"NotActivelyDelegated\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OnlyAllocationManager\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OnlyEigenPodManager\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OnlyStrategyManagerOrEigenPodManager\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OperatorNotRegistered\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OperatorsCannotUndelegate\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"SaltSpent\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"SignatureExpired\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"WithdrawalDelayNotElapsed\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"WithdrawalNotQueued\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"WithdrawerNotCaller\",\n    \"inputs\": []\n  }\n]"
  },
  {
    "path": "contracts/anvil/build-state.sh",
    "summary": "File starts: #!/usr/bin/env bash",
    "content": "#!/usr/bin/env bash\nset -e\nSTATE_FILE=\"contracts/anvil/state.json\"\nmkdir -p \"$(dirname \"$STATE_FILE\")\"\necho \"Starting Anvil with state dump in background\"\nanvil --dump-state \"$STATE_FILE\" --port 8545 --base-fee 0 --gas-price 0 > /dev/null 2>&1 &\nANVIL_PID=$!\nsleep 3\ncp .env.example .env\ncp contracts/.env.example contracts/.env\necho \"Building contracts\"\nmake build-contracts > /dev/null 2>&1\necho \"Deploying EigenLayer contracts.\"\nmake deploy-eigenlayer-contracts > /dev/null 2>&1\necho \"Deploying HelloWorld contracts.\"\nmake deploy-helloworld-contracts > /dev/null 2>&1\necho \"Killed Anvil\"\nkill $ANVIL_PID || true"
  },
  {
    "path": "contracts/anvil/deploy-el.sh",
    "summary": "File starts: #!/usr/bin/env bash",
    "content": "#!/usr/bin/env bash\nset -e\nRPC_URL=http://localhost:8545\nPRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\n# cd to the directory of this script so that this can be run from anywhere\nparent_path=$(\n    cd \"$(dirname \"${BASH_SOURCE[0]}\")\"\n    pwd -P\n)\ncd \"$parent_path\"\ncd ../\nforge script script/DeployEigenLayerCore.s.sol --rpc-url http://localhost:8545 --broadcast"
  },
  {
    "path": "contracts/anvil/deploy-helloworld.sh",
    "summary": "File starts: #!/usr/bin/env bash",
    "content": "#!/usr/bin/env bash\nset -e\nRPC_URL=http://localhost:8545\nPRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\n# cd to the directory of this script so that this can be run from anywhere\nparent_path=$(\n    cd \"$(dirname \"${BASH_SOURCE[0]}\")\"\n    pwd -P\n)\ncd \"$parent_path\"\ncd ../\nforge script script/HelloWorldDeployer.s.sol --rpc-url http://localhost:8545 --broadcast"
  },
  {
    "path": "contracts/config/core/31337.json",
    "summary": "JSON file with keys: strategyManager, delegationManager, eigenPodManager, allocationManager, strategyFactory, avsDirectory, rewardsCoordinator.",
    "content": "{\n  \"strategyManager\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"initialStrategyWhitelister\": \"0x959922be3caee4b8cd9a407cc3ac1c251c2007b1\"\n  },\n  \"delegationManager\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"minWithdrawalDelayBlocks\": 50400\n  },\n  \"eigenPodManager\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\n  },\n  \"allocationManager\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"deallocationDelay\": 0,\n    \"allocationConfigurationDelay\": 0\n  },\n  \"strategyFactory\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\n  },\n  \"avsDirectory\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\n  },\n  \"rewardsCoordinator\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"rewardsUpdater\": \"0x14dC79964da2C08b23698B3D3cc7Ca32193d9955\",\n    \"activationDelay\": 0,\n    \"defaultSplitBips\": 1000,\n    \"calculationIntervalSeconds\": 86400,\n    \"maxRewardsDuration\": 864000,\n    \"maxRetroactiveLength\": 432000,\n    \"maxFutureLength\": 86400,\n    \"genesisRewardsTimestamp\": 1672531200\n  }\n}"
  },
  {
    "path": "contracts/config/hello-world/31337.json",
    "summary": "JSON file with keys: addresses, keys.",
    "content": "{\n  \"addresses\": {\n    \"rewardsOwner\": \"0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f\",\n    \"rewardsInitiator\": \"0xa0Ee7A142d267C1f36714E4a8F75612F20a79720\"\n  },\n  \"keys\": {\n    \"rewardsOwner\": \"0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97\",\n    \"rewardsInitiator\": \"0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6\"\n  }\n}"
  },
  {
    "path": "contracts/mocks/MockStrategy.sol",
    "summary": "File starts: // SPDX-License-Identifier: BUSL-1.1",
    "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@eigenlayer/contracts/interfaces/IStrategy.sol\";\n\ncontract MockStrategy is IStrategy {\n    IERC20 public override underlyingToken;\n    uint256 public override totalShares;\n    mapping(address => uint256) public userShares;\n    uint256 public constant EXCHANGE_RATE = 1e18; // 1:1 exchange rate for simplicity\n\n    constructor(IERC20 _underlyingToken) {\n        underlyingToken = _underlyingToken;\n        emit StrategyTokenSet(_underlyingToken, 18); // Assuming 18 decimals for simplicity\n    }\n\n    function deposit(IERC20 token, uint256 amount) external override returns (uint256) {\n        require(token == underlyingToken, \"Invalid token\");\n        uint256 newShares = amount;\n        totalShares += newShares;\n        userShares[msg.sender] += newShares;\n        emit ExchangeRateEmitted(EXCHANGE_RATE);\n        return newShares;\n    }\n\n    function withdraw(address recipient, IERC20 token, uint256 amountShares) external override {\n        require(token == underlyingToken, \"Invalid token\");\n        require(userShares[msg.sender] >= amountShares, \"Insufficient shares\");\n        userShares[msg.sender] -= amountShares;\n        totalShares -= amountShares;\n        underlyingToken.transfer(recipient, amountShares);\n    }\n\n    function sharesToUnderlying(uint256 amountShares) external pure override returns (uint256) {\n        return amountShares;\n    }\n\n    function underlyingToShares(uint256 amountUnderlying) external pure override returns (uint256) {\n        return amountUnderlying;\n    }\n\n    function userUnderlying(address user) external view override returns (uint256) {\n        return userShares[user];\n    }\n\n    function shares(address user) external view override returns (uint256) {\n        return userShares[user];\n    }\n\n    function sharesToUnderlyingView(uint256 amountShares) external pure override returns (uint256) {\n        return amountShares;\n    }\n\n    function underlyingToSharesView(uint256 amountUnderlying) external pure override returns (uint256) {\n        return amountUnderlying;\n    }\n\n    function userUnderlyingView(address user) external view override returns (uint256) {\n        return userShares[user];\n    }\n\n    function explanation() external pure override returns (string memory) {\n        return \"Mock Strategy for testing purposes\";\n    }\n}"
  },
  {
    "path": "contracts/script/utils/CoreDeploymentParsingLib.sol",
    "summary": "File starts: // SPDX-License-Identifier: UNLICENSED",
    "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {TransparentUpgradeableProxy} from\n    \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\nimport {console2} from \"forge-std/Test.sol\";\nimport {Vm} from \"forge-std/Vm.sol\";\nimport {stdJson} from \"forge-std/StdJson.sol\";\nimport {DelegationManager} from \"@eigenlayer/contracts/core/DelegationManager.sol\";\nimport {StrategyManager} from \"@eigenlayer/contracts/core/StrategyManager.sol\";\nimport {AVSDirectory} from \"@eigenlayer/contracts/core/AVSDirectory.sol\";\nimport {EigenPodManager} from \"@eigenlayer/contracts/pods/EigenPodManager.sol\";\nimport {RewardsCoordinator} from \"@eigenlayer/contracts/core/RewardsCoordinator.sol\";\nimport {StrategyBase} from \"@eigenlayer/contracts/strategies/StrategyBase.sol\";\nimport {EigenPod} from \"@eigenlayer/contracts/pods/EigenPod.sol\";\nimport {IETHPOSDeposit} from \"@eigenlayer/contracts/interfaces/IETHPOSDeposit.sol\";\nimport {StrategyBaseTVLLimits} from \"@eigenlayer/contracts/strategies/StrategyBaseTVLLimits.sol\";\nimport {PauserRegistry} from \"@eigenlayer/contracts/permissions/PauserRegistry.sol\";\nimport {IStrategy} from \"@eigenlayer/contracts/interfaces/IStrategy.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ISignatureUtilsMixin} from \"@eigenlayer/contracts/interfaces/ISignatureUtilsMixin.sol\";\nimport {IDelegationManager} from \"@eigenlayer/contracts/interfaces/IDelegationManager.sol\";\nimport {IBeacon} from \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport {IStrategyManager} from \"@eigenlayer/contracts/interfaces/IStrategyManager.sol\";\nimport {ISlasher} from \"@eigenlayer-middleware/src/interfaces/ISlasher.sol\";\nimport {IEigenPodManager} from \"@eigenlayer/contracts/interfaces/IEigenPodManager.sol\";\nimport {IAVSDirectory} from \"@eigenlayer/contracts/interfaces/IAVSDirectory.sol\";\nimport {IPauserRegistry} from \"@eigenlayer/contracts/interfaces/IPauserRegistry.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {StrategyFactory} from \"@eigenlayer/contracts/strategies/StrategyFactory.sol\";\n\nimport {UpgradeableProxyLib} from \"./UpgradeableProxyLib.sol\";\nimport {CoreDeployLib} from \"@eigenlayer-middleware/test/utils/CoreDeployLib.sol\";\n\nlibrary CoreDeploymentParsingLib {\n    using stdJson for *;\n    using Strings for *;\n    using UpgradeableProxyLib for address;\n\n    Vm internal constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function readDeploymentConfigValues(\n        string memory directoryPath,\n        string memory fileName\n    ) internal view returns (CoreDeployLib.DeploymentConfigData memory) {\n        string memory pathToFile = string.concat(directoryPath, fileName);\n\n        require(vm.exists(pathToFile), \"CoreDeployment: Deployment config file does not exist\");\n\n        string memory json = vm.readFile(pathToFile);\n\n        CoreDeployLib.DeploymentConfigData memory data;\n\n        // StrategyManager start\n        data.strategyManager.initPausedStatus = json.readUint(\".strategyManager.initPausedStatus\");\n        data.strategyManager.initialOwner = json.readAddress(\".strategyManager.initialOwner\");\n        data.strategyManager.initialStrategyWhitelister =\n            json.readAddress(\".strategyManager.initialStrategyWhitelister\");\n        // StrategyManager config end\n\n        // DelegationManager config start\n        data.delegationManager.initPausedStatus =\n            json.readUint(\".delegationManager.initPausedStatus\");\n        data.delegationManager.initialOwner = json.readAddress(\".delegationManager.initialOwner\");\n        data.delegationManager.minWithdrawalDelayBlocks =\n            uint32(json.readUint(\".delegationManager.minWithdrawalDelayBlocks\"));\n        // DelegationManager config end\n\n        // EigenPodManager config start\n        data.eigenPodManager.initPausedStatus = json.readUint(\".eigenPodManager.initPausedStatus\");\n        data.eigenPodManager.initialOwner = json.readAddress(\".eigenPodManager.initialOwner\");\n        // EigenPodManager config end\n\n        // AllocationManager config start\n        data.allocationManager.initPausedStatus =\n            json.readUint(\".allocationManager.initPausedStatus\");\n        data.allocationManager.initialOwner = json.readAddress(\".allocationManager.initialOwner\");\n        data.allocationManager.deallocationDelay =\n            uint32(json.readUint(\".allocationManager.deallocationDelay\"));\n        data.allocationManager.allocationConfigurationDelay =\n            uint32(json.readUint(\".allocationManager.allocationConfigurationDelay\"));\n        // AllocationManager config end\n\n        // StrategyFactory config start\n        data.strategyFactory.initPausedStatus = json.readUint(\".strategyFactory.initPausedStatus\");\n        data.strategyFactory.initialOwner = json.readAddress(\".strategyFactory.initialOwner\");\n        // StrategyFactory config end\n\n        // AVSDirectory config start\n        data.avsDirectory.initPausedStatus = json.readUint(\".avsDirectory.initPausedStatus\");\n        data.avsDirectory.initialOwner = json.readAddress(\".avsDirectory.initialOwner\");\n        // AVSDirectory config end\n\n        // RewardsCoordinator config start\n        data.rewardsCoordinator.initPausedStatus =\n            json.readUint(\".rewardsCoordinator.initPausedStatus\");\n        data.rewardsCoordinator.initialOwner = json.readAddress(\".rewardsCoordinator.initialOwner\");\n        data.rewardsCoordinator.rewardsUpdater =\n            json.readAddress(\".rewardsCoordinator.rewardsUpdater\");\n\n        data.rewardsCoordinator.activationDelay =\n            uint32(json.readUint(\".rewardsCoordinator.activationDelay\"));\n        data.rewardsCoordinator.defaultSplitBips =\n            uint16(json.readUint(\".rewardsCoordinator.defaultSplitBips\"));\n        data.rewardsCoordinator.calculationIntervalSeconds =\n            uint32(json.readUint(\".rewardsCoordinator.calculationIntervalSeconds\"));\n        data.rewardsCoordinator.maxRewardsDuration =\n            uint32(json.readUint(\".rewardsCoordinator.maxRewardsDuration\"));\n        data.rewardsCoordinator.maxRetroactiveLength =\n            uint32(json.readUint(\".rewardsCoordinator.maxRetroactiveLength\"));\n        data.rewardsCoordinator.maxFutureLength =\n            uint32(json.readUint(\".rewardsCoordinator.maxFutureLength\"));\n        data.rewardsCoordinator.genesisRewardsTimestamp =\n            uint32(json.readUint(\".rewardsCoordinator.genesisRewardsTimestamp\"));\n        // RewardsCoordinator config end\n\n        data.ethPOSDeposit.ethPOSDepositAddress = address(1);\n\n        return data;\n    }\n\n    function readDeploymentConfigValues(\n        string memory directoryPath,\n        uint256 chainId\n    ) internal view returns (CoreDeployLib.DeploymentConfigData memory) {\n        return\n            readDeploymentConfigValues(directoryPath, string.concat(vm.toString(chainId), \".json\"));\n    }\n\n    function readDeploymentJson(\n        string memory directoryPath,\n        uint256 chainId\n    ) internal view returns (CoreDeployLib.DeploymentData memory) {\n        return readDeploymentJson(directoryPath, string.concat(vm.toString(chainId), \".json\"));\n    }\n\n    function readDeploymentJson(\n        string memory path,\n        string memory fileName\n    ) internal view returns (CoreDeployLib.DeploymentData memory) {\n        string memory pathToFile = string.concat(path, fileName);\n\n        require(vm.exists(pathToFile), \"CoreDeployment: Deployment file does not exist\");\n\n        string memory json = vm.readFile(pathToFile);\n\n        CoreDeployLib.DeploymentData memory data;\n        data.delegationManager = json.readAddress(\".addresses.delegationManager\");\n        data.avsDirectory = json.readAddress(\".addresses.avsDirectory\");\n        data.strategyManager = json.readAddress(\".addresses.strategyManager\");\n        data.eigenPodManager = json.readAddress(\".addresses.eigenPodManager\");\n        data.allocationManager = json.readAddress(\".addresses.allocationManager\");\n        data.eigenPodBeacon = json.readAddress(\".addresses.eigenPodBeacon\");\n        data.pauserRegistry = json.readAddress(\".addresses.pauserRegistry\");\n        data.strategyFactory = json.readAddress(\".addresses.strategyFactory\");\n        data.strategyBeacon = json.readAddress(\".addresses.strategyBeacon\");\n        data.rewardsCoordinator = json.readAddress(\".addresses.rewardsCoordinator\");\n        data.permissionController = json.readAddress(\".addresses.permissionController\");\n\n        return data;\n    }\n\n    /// TODO: Need to be able to read json from eigenlayer-contracts repo for holesky/mainnet and output the json here\n    function writeDeploymentJson(\n        CoreDeployLib.DeploymentData memory data\n    ) internal {\n        writeDeploymentJson(\"deployments/core/\", block.chainid, data);\n    }\n\n    function writeDeploymentJson(\n        string memory path,\n        uint256 chainId,\n        CoreDeployLib.DeploymentData memory data\n    ) internal {\n        address proxyAdmin = address(UpgradeableProxyLib.getProxyAdmin(data.strategyManager));\n\n        string memory deploymentData = _generateDeploymentJson(data, proxyAdmin);\n\n        string memory fileName = string.concat(path, vm.toString(chainId), \".json\");\n        if (!vm.exists(path)) {\n            vm.createDir(path, true);\n        }\n\n        vm.writeFile(fileName, deploymentData);\n        console2.log(\"Deployment artifacts written to:\", fileName);\n    }\n\n    function _generateDeploymentJson(\n        CoreDeployLib.DeploymentData memory data,\n        address proxyAdmin\n    ) private view returns (string memory) {\n        return string.concat(\n            '{\"lastUpdate\":{\"timestamp\":\"',\n            vm.toString(block.timestamp),\n            '\",\"block_number\":\"',\n            vm.toString(block.number),\n            '\"},\"addresses\":',\n            _generateContractsJson(data, proxyAdmin),\n            \"}\"\n        );\n    }\n\n    function _generateContractsJson(\n        CoreDeployLib.DeploymentData memory data,\n        address proxyAdmin\n    ) private view returns (string memory) {\n        /// TODO: namespace contracts -> {avs, core}\n        return string.concat(\n            '{\"proxyAdmin\":\"',\n            proxyAdmin.toHexString(),\n            '\",\"delegationManager\":\"',\n            data.delegationManager.toHexString(),\n            '\",\"delegationManagerImpl\":\"',\n            data.delegationManager.getImplementation().toHexString(),\n            '\",\"avsDirectory\":\"',\n            data.avsDirectory.toHexString(),\n            '\",\"avsDirectoryImpl\":\"',\n            data.avsDirectory.getImplementation().toHexString(),\n            '\",\"strategyManager\":\"',\n            data.strategyManager.toHexString(),\n            '\",\"strategyManagerImpl\":\"',\n            data.strategyManager.getImplementation().toHexString(),\n            '\",\"eigenPodManager\":\"',\n            data.eigenPodManager.toHexString(),\n            '\",\"eigenPodManagerImpl\":\"',\n            data.eigenPodManager.getImplementation().toHexString(),\n            '\",\"allocationManager\":\"',\n            data.allocationManager.toHexString(),\n            '\",\"allocationManagerImpl\":\"',\n            data.allocationManager.getImplementation().toHexString(),\n            '\",\"eigenPodBeacon\":\"',\n            data.eigenPodBeacon.toHexString(),\n            '\",\"pauserRegistry\":\"',\n            data.pauserRegistry.toHexString(),\n            '\",\"pauserRegistryImpl\":\"',\n            data.pauserRegistry.getImplementation().toHexString(),\n            '\",\"strategyFactory\":\"',\n            data.strategyFactory.toHexString(),\n            '\",\"strategyFactoryImpl\":\"',\n            data.strategyFactory.getImplementation().toHexString(),\n            '\",\"strategyBeacon\":\"',\n            data.strategyBeacon.toHexString(),\n            '\",\"rewardsCoordinator\":\"',\n            data.rewardsCoordinator.toHexString(),\n            '\",\"rewardsCoordinatorImpl\":\"',\n            data.rewardsCoordinator.getImplementation().toHexString(),\n            '\",\"permissionController\":\"',\n            data.permissionController.toHexString(),\n            '\",\"permissionControllerImpl\":\"',\n            data.permissionController.getImplementation().toHexString(),\n            '\"}'\n        );\n    }\n}"
  },
  {
    "path": "contracts/script/utils/HelloWorldDeploymentLib.sol",
    "summary": "File starts: // SPDX-License-Identifier: UNLICENSED",
    "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {TransparentUpgradeableProxy} from\n    \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {Script} from \"forge-std/Script.sol\";\nimport {console2} from \"forge-std/Test.sol\";\nimport {Vm} from \"forge-std/Vm.sol\";\nimport {stdJson} from \"forge-std/StdJson.sol\";\nimport {ECDSAStakeRegistry} from \"@eigenlayer-middleware/src/unaudited/ECDSAStakeRegistry.sol\";\nimport {HelloWorldServiceManager} from \"../../src/HelloWorldServiceManager.sol\";\nimport {IDelegationManager} from \"@eigenlayer/contracts/interfaces/IDelegationManager.sol\";\nimport {IECDSAStakeRegistryTypes} from\n    \"@eigenlayer-middleware/src/interfaces/IECDSAStakeRegistry.sol\";\nimport {UpgradeableProxyLib} from \"./UpgradeableProxyLib.sol\";\nimport {CoreDeployLib, CoreDeploymentParsingLib} from \"./CoreDeploymentParsingLib.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nlibrary HelloWorldDeploymentLib {\n    using stdJson for *;\n    using Strings for *;\n    using UpgradeableProxyLib for address;\n\n    Vm internal constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    struct DeploymentData {\n        address helloWorldServiceManager;\n        address stakeRegistry;\n        address strategy;\n        address token;\n    }\n\n    struct DeploymentConfigData {\n        address rewardsOwner;\n        address rewardsInitiator;\n        uint256 rewardsOwnerKey;\n        uint256 rewardsInitiatorKey;\n    }\n\n    function deployContracts(\n        address proxyAdmin,\n        CoreDeployLib.DeploymentData memory core,\n        IECDSAStakeRegistryTypes.Quorum memory quorum,\n        address rewardsInitiator,\n        address owner\n    ) internal returns (DeploymentData memory) {\n        DeploymentData memory result;\n\n        {\n            // First, deploy upgradeable proxy contracts that will point to the implementations.\n            result.helloWorldServiceManager = UpgradeableProxyLib.setUpEmptyProxy(proxyAdmin);\n            result.stakeRegistry = UpgradeableProxyLib.setUpEmptyProxy(proxyAdmin);\n        }\n        deployAndUpgradeStakeRegistryImpl(result, core, quorum);\n        deployAndUpgradeServiceManagerImpl(result, core, owner, rewardsInitiator);\n\n        return result;\n    }\n\n    function deployAndUpgradeStakeRegistryImpl(\n        DeploymentData memory deployment,\n        CoreDeployLib.DeploymentData memory core,\n        IECDSAStakeRegistryTypes.Quorum memory quorum\n    ) private {\n        address stakeRegistryImpl =\n            address(new ECDSAStakeRegistry(IDelegationManager(core.delegationManager)));\n\n        bytes memory upgradeCall = abi.encodeCall(\n            ECDSAStakeRegistry.initialize, (deployment.helloWorldServiceManager, 0, quorum)\n        );\n        UpgradeableProxyLib.upgradeAndCall(deployment.stakeRegistry, stakeRegistryImpl, upgradeCall);\n    }\n\n    function deployAndUpgradeServiceManagerImpl(\n        DeploymentData memory deployment,\n        CoreDeployLib.DeploymentData memory core,\n        address owner,\n        address rewardsInitiator\n    ) private {\n        address helloWorldServiceManager = deployment.helloWorldServiceManager;\n        address helloWorldServiceManagerImpl = address(\n            new HelloWorldServiceManager(\n                core.avsDirectory,\n                deployment.stakeRegistry,\n                core.rewardsCoordinator,\n                core.delegationManager,\n                core.allocationManager,\n                4\n            )\n        );\n\n        bytes memory upgradeCall =\n            abi.encodeCall(HelloWorldServiceManager.initialize, (owner, rewardsInitiator));\n\n        UpgradeableProxyLib.upgradeAndCall(\n            helloWorldServiceManager, helloWorldServiceManagerImpl, upgradeCall\n        );\n    }\n\n    function readDeploymentJson(\n        uint256 chainId\n    ) internal view returns (DeploymentData memory) {\n        return readDeploymentJson(\"deployments/\", chainId);\n    }\n\n    function readDeploymentJson(\n        string memory directoryPath,\n        uint256 chainId\n    ) internal view returns (DeploymentData memory) {\n        string memory fileName = string.concat(directoryPath, vm.toString(chainId), \".json\");\n\n        require(vm.exists(fileName), \"HelloWorldDeployment: Deployment file does not exist\");\n\n        string memory json = vm.readFile(fileName);\n\n        DeploymentData memory data;\n        /// TODO: 2 Step for reading deployment json.  Read to the core and the AVS data\n        data.helloWorldServiceManager = json.readAddress(\".addresses.helloWorldServiceManager\");\n        data.stakeRegistry = json.readAddress(\".addresses.stakeRegistry\");\n        data.strategy = json.readAddress(\".addresses.strategy\");\n        data.token = json.readAddress(\".addresses.token\");\n\n        return data;\n    }\n\n    /// write to default output path\n    function writeDeploymentJson(\n        DeploymentData memory data\n    ) internal {\n        writeDeploymentJson(\"deployments/hello-world/\", block.chainid, data);\n    }\n\n    function writeDeploymentJson(\n        string memory outputPath,\n        uint256 chainId,\n        DeploymentData memory data\n    ) internal {\n        address proxyAdmin =\n            address(UpgradeableProxyLib.getProxyAdmin(data.helloWorldServiceManager));\n\n        string memory deploymentData = _generateDeploymentJson(data, proxyAdmin);\n\n        string memory fileName = string.concat(outputPath, vm.toString(chainId), \".json\");\n        if (!vm.exists(outputPath)) {\n            vm.createDir(outputPath, true);\n        }\n\n        vm.writeFile(fileName, deploymentData);\n        console2.log(\"Deployment artifacts written to:\", fileName);\n    }\n\n    function readDeploymentConfigValues(\n        string memory directoryPath,\n        string memory fileName\n    ) internal view returns (DeploymentConfigData memory) {\n        string memory pathToFile = string.concat(directoryPath, fileName);\n\n        require(\n            vm.exists(pathToFile), \"HelloWorldDeployment: Deployment Config file does not exist\"\n        );\n\n        string memory json = vm.readFile(pathToFile);\n\n        DeploymentConfigData memory data;\n        data.rewardsOwner = json.readAddress(\".addresses.rewardsOwner\");\n        data.rewardsInitiator = json.readAddress(\".addresses.rewardsInitiator\");\n        data.rewardsOwnerKey = json.readUint(\".keys.rewardsOwner\");\n        data.rewardsInitiatorKey = json.readUint(\".keys.rewardsInitiator\");\n        return data;\n    }\n\n    function readDeploymentConfigValues(\n        string memory directoryPath,\n        uint256 chainId\n    ) internal view returns (DeploymentConfigData memory) {\n        return\n            readDeploymentConfigValues(directoryPath, string.concat(vm.toString(chainId), \".json\"));\n    }\n\n    function _generateDeploymentJson(\n        DeploymentData memory data,\n        address proxyAdmin\n    ) private view returns (string memory) {\n        return string.concat(\n            '{\"lastUpdate\":{\"timestamp\":\"',\n            vm.toString(block.timestamp),\n            '\",\"block_number\":\"',\n            vm.toString(block.number),\n            '\"},\"addresses\":',\n            _generateContractsJson(data, proxyAdmin),\n            \"}\"\n        );\n    }\n\n    function _generateContractsJson(\n        DeploymentData memory data,\n        address proxyAdmin\n    ) private view returns (string memory) {\n        return string.concat(\n            '{\"proxyAdmin\":\"',\n            proxyAdmin.toHexString(),\n            '\",\"helloWorldServiceManager\":\"',\n            data.helloWorldServiceManager.toHexString(),\n            '\",\"helloWorldServiceManagerImpl\":\"',\n            data.helloWorldServiceManager.getImplementation().toHexString(),\n            '\",\"stakeRegistry\":\"',\n            data.stakeRegistry.toHexString(),\n            '\",\"stakeRegistryImpl\":\"',\n            data.stakeRegistry.getImplementation().toHexString(),\n            '\",\"strategy\":\"',\n            data.strategy.toHexString(),\n            '\",\"token\":\"',\n            data.token.toHexString(),\n            '\"}'\n        );\n    }\n}"
  },
  {
    "path": "contracts/script/utils/SetupDistributionsLib.sol",
    "summary": "File starts: // SPDX-License-Identifier: UNLICENSED",
    "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {\n    IRewardsCoordinator,\n    IRewardsCoordinatorTypes\n} from \"@eigenlayer/contracts/interfaces/IRewardsCoordinator.sol\";\nimport {IStrategy} from \"eigenlayer-contracts/src/contracts/interfaces/IStrategyManager.sol\";\nimport {ECDSAServiceManagerBase} from\n    \"@eigenlayer-middleware/src/unaudited/ECDSAServiceManagerBase.sol\";\nimport {Vm} from \"forge-std/Vm.sol\";\nimport {console} from \"forge-std/console.sol\";\n\nlibrary SetupDistributionsLib {\n    Vm internal constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    struct PaymentLeaves {\n        bytes32[] leaves;\n        bytes32[] tokenLeaves;\n    }\n\n    function createAVSRewardsSubmissions(\n        address helloWorldServiceManager,\n        address strategy,\n        uint256 numPayments,\n        uint256 amountPerPayment,\n        uint32 duration,\n        uint32 startTimestamp\n    ) internal {\n        IRewardsCoordinatorTypes.RewardsSubmission[] memory rewardsSubmissions =\n            new IRewardsCoordinatorTypes.RewardsSubmission[](numPayments);\n        for (uint256 i = 0; i < numPayments; i++) {\n            IRewardsCoordinatorTypes.StrategyAndMultiplier[] memory strategiesAndMultipliers =\n                new IRewardsCoordinatorTypes.StrategyAndMultiplier[](1);\n            strategiesAndMultipliers[0] = IRewardsCoordinatorTypes.StrategyAndMultiplier({\n                strategy: IStrategy(strategy),\n                multiplier: 10_000\n            });\n\n            IRewardsCoordinatorTypes.RewardsSubmission memory rewardsSubmission =\n            IRewardsCoordinatorTypes.RewardsSubmission({\n                strategiesAndMultipliers: strategiesAndMultipliers,\n                token: IStrategy(strategy).underlyingToken(),\n                amount: amountPerPayment,\n                startTimestamp: startTimestamp,\n                duration: duration\n            });\n\n            rewardsSubmissions[i] = rewardsSubmission;\n        }\n        ECDSAServiceManagerBase(helloWorldServiceManager).createAVSRewardsSubmission(\n            rewardsSubmissions\n        );\n    }\n\n    function createOperatorDirectedAVSRewardsSubmissions(\n        address helloWorldServiceManager,\n        address[] memory operators,\n        address strategy,\n        uint256 numPayments,\n        uint256 amountPerPayment,\n        uint32 duration,\n        uint32 startTimestamp\n    ) internal {\n        uint256 operatorRewardAmount = amountPerPayment / operators.length;\n\n        IRewardsCoordinatorTypes.OperatorReward[] memory operatorRewards =\n            new IRewardsCoordinatorTypes.OperatorReward[](operators.length);\n        for (uint256 i = 0; i < operators.length; i++) {\n            operatorRewards[i] = IRewardsCoordinatorTypes.OperatorReward({\n                operator: operators[i],\n                amount: operatorRewardAmount\n            });\n        }\n\n        IRewardsCoordinatorTypes.OperatorDirectedRewardsSubmission[] memory rewardsSubmissions =\n            new IRewardsCoordinatorTypes.OperatorDirectedRewardsSubmission[](numPayments);\n        for (uint256 i = 0; i < numPayments; i++) {\n            IRewardsCoordinatorTypes.StrategyAndMultiplier[] memory strategiesAndMultipliers =\n                new IRewardsCoordinatorTypes.StrategyAndMultiplier[](1);\n            strategiesAndMultipliers[0] = IRewardsCoordinatorTypes.StrategyAndMultiplier({\n                strategy: IStrategy(strategy),\n                multiplier: 10_000\n            });\n\n            IRewardsCoordinatorTypes.OperatorDirectedRewardsSubmission memory rewardsSubmission =\n            IRewardsCoordinatorTypes.OperatorDirectedRewardsSubmission({\n                strategiesAndMultipliers: strategiesAndMultipliers,\n                token: IStrategy(strategy).underlyingToken(),\n                operatorRewards: operatorRewards,\n                startTimestamp: startTimestamp,\n                duration: duration,\n                description: \"test\"\n            });\n            console.log(\"rrr\");\n            console.log(startTimestamp);\n            console.log(duration);\n            console.log(block.timestamp);\n\n            rewardsSubmissions[i] = rewardsSubmission;\n        }\n        ECDSAServiceManagerBase(helloWorldServiceManager).createOperatorDirectedAVSRewardsSubmission(\n            rewardsSubmissions\n        );\n    }\n\n    function processClaim(\n        IRewardsCoordinator rewardsCoordinator,\n        string memory filePath,\n        uint256 indexToProve,\n        address recipient,\n        IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf memory earnerLeaf,\n        uint256 NUM_TOKEN_EARNINGS,\n        address strategy,\n        uint32 amountPerPayment\n    ) internal {\n        PaymentLeaves memory paymentLeaves = parseLeavesFromJson(filePath);\n\n        bytes memory proof = generateMerkleProof(paymentLeaves.leaves, indexToProve);\n        //we only have one token leaf\n        bytes memory tokenProof = generateMerkleProof(paymentLeaves.tokenLeaves, 0);\n\n        uint32[] memory tokenIndices = new uint32[](NUM_TOKEN_EARNINGS);\n        bytes[] memory tokenProofs = new bytes[](NUM_TOKEN_EARNINGS);\n        tokenProofs[0] = tokenProof;\n\n        IRewardsCoordinatorTypes.TokenTreeMerkleLeaf[] memory tokenLeaves =\n            new IRewardsCoordinatorTypes.TokenTreeMerkleLeaf[](NUM_TOKEN_EARNINGS);\n        tokenLeaves[0] = defaultTokenLeaf(amountPerPayment, strategy);\n\n        // this workflow assumes a new root submitted for every payment claimed.  So we get the latest rood index to process a claim for\n        uint256 rootIndex = rewardsCoordinator.getDistributionRootsLength() - 1;\n\n        IRewardsCoordinatorTypes.RewardsMerkleClaim memory claim = IRewardsCoordinatorTypes\n            .RewardsMerkleClaim({\n            rootIndex: uint32(rootIndex),\n            earnerIndex: uint32(indexToProve),\n            earnerTreeProof: proof,\n            earnerLeaf: earnerLeaf,\n            tokenIndices: tokenIndices,\n            tokenTreeProofs: tokenProofs,\n            tokenLeaves: tokenLeaves\n        });\n\n        rewardsCoordinator.processClaim(claim, recipient);\n    }\n\n    function submitRoot(\n        IRewardsCoordinator rewardsCoordinator,\n        bytes32[] memory tokenLeaves,\n        IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf[] memory earnerLeaves,\n        uint32 rewardsCalculationEndTimestamp,\n        uint256 NUM_PAYMENTS,\n        uint256 NUM_TOKEN_EARNINGS,\n        string memory filePath\n    ) internal {\n        bytes32 paymentRoot = createPaymentRoot(\n            rewardsCoordinator,\n            tokenLeaves,\n            earnerLeaves,\n            NUM_PAYMENTS,\n            NUM_TOKEN_EARNINGS,\n            filePath\n        );\n        rewardsCoordinator.submitRoot(paymentRoot, rewardsCalculationEndTimestamp);\n    }\n\n    function createPaymentRoot(\n        IRewardsCoordinator rewardsCoordinator,\n        bytes32[] memory tokenLeaves,\n        IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf[] memory earnerLeaves,\n        uint256 NUM_PAYMENTS,\n        uint256 NUM_TOKEN_EARNINGS,\n        string memory filePath\n    ) internal returns (bytes32) {\n        require(\n            earnerLeaves.length == NUM_PAYMENTS, \"Number of earners must match number of payments\"\n        );\n        bytes32[] memory leaves = new bytes32[](NUM_PAYMENTS);\n\n        require(\n            tokenLeaves.length == NUM_TOKEN_EARNINGS,\n            \"Number of token leaves must match number of token earnings\"\n        );\n        for (uint256 i = 0; i < NUM_PAYMENTS; i++) {\n            leaves[i] = rewardsCoordinator.calculateEarnerLeafHash(earnerLeaves[i]);\n        }\n\n        writeLeavesToJson(leaves, tokenLeaves, filePath);\n        return (merkleizeKeccak(leaves));\n    }\n\n    function createEarnerLeaves(\n        address[] calldata earners,\n        bytes32[] memory tokenLeaves\n    ) public pure returns (IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf[] memory) {\n        IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf[] memory leaves =\n            new IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf[](earners.length);\n        for (uint256 i = 0; i < earners.length; i++) {\n            leaves[i] = IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf({\n                earner: earners[i],\n                earnerTokenRoot: createTokenRoot(tokenLeaves)\n            });\n        }\n        return leaves;\n    }\n\n    function createTokenRoot(\n        bytes32[] memory tokenLeaves\n    ) public pure returns (bytes32) {\n        return merkleizeKeccak(tokenLeaves);\n    }\n\n    function createTokenLeaves(\n        IRewardsCoordinator rewardsCoordinator,\n        uint256 NUM_TOKEN_EARNINGS,\n        uint256 TOKEN_EARNINGS,\n        address strategy\n    ) internal view returns (bytes32[] memory) {\n        bytes32[] memory leaves = new bytes32[](NUM_TOKEN_EARNINGS);\n        for (uint256 i = 0; i < NUM_TOKEN_EARNINGS; i++) {\n            IRewardsCoordinatorTypes.TokenTreeMerkleLeaf memory leaf =\n                defaultTokenLeaf(TOKEN_EARNINGS, strategy);\n            leaves[i] = rewardsCoordinator.calculateTokenLeafHash(leaf);\n        }\n        return leaves;\n    }\n\n    function defaultTokenLeaf(\n        uint256 TOKEN_EARNINGS,\n        address strategy\n    ) internal view returns (IRewardsCoordinatorTypes.TokenTreeMerkleLeaf memory) {\n        IRewardsCoordinatorTypes.TokenTreeMerkleLeaf memory leaf = IRewardsCoordinatorTypes\n            .TokenTreeMerkleLeaf({\n            token: IStrategy(strategy).underlyingToken(),\n            cumulativeEarnings: TOKEN_EARNINGS\n        });\n        return leaf;\n    }\n\n    function writeLeavesToJson(\n        bytes32[] memory leaves,\n        bytes32[] memory tokenLeaves,\n        string memory filePath\n    ) internal {\n        string memory parent_object = \"parent_object\";\n        vm.serializeBytes32(parent_object, \"leaves\", leaves);\n        string memory finalJson = vm.serializeBytes32(parent_object, \"tokenLeaves\", tokenLeaves);\n        vm.writeJson(finalJson, filePath);\n    }\n\n    function parseLeavesFromJson(\n        string memory filePath\n    ) internal view returns (PaymentLeaves memory) {\n        string memory json = vm.readFile(filePath);\n        bytes memory data = vm.parseJson(json);\n        return abi.decode(data, (PaymentLeaves));\n    }\n\n    function generateMerkleProof(\n        bytes32[] memory leaves,\n        uint256 index\n    ) internal pure returns (bytes memory) {\n        require(leaves.length > 0, \"Leaves array cannot be empty\");\n        require(index < leaves.length, \"Index out of bounds\");\n\n        leaves = padLeaves(leaves);\n\n        uint256 n = leaves.length;\n        uint256 depth = 0;\n        while ((1 << depth) < n) {\n            depth++;\n        }\n\n        bytes32[] memory proof = new bytes32[](depth);\n        uint256 proofIndex = 0;\n\n        for (uint256 i = 0; i < depth; i++) {\n            uint256 levelSize = (n + 1) / 2;\n            uint256 siblingIndex = (index % 2 == 0) ? index + 1 : index - 1;\n\n            if (siblingIndex < n) {\n                proof[proofIndex] = leaves[siblingIndex];\n                proofIndex++;\n            }\n\n            for (uint256 j = 0; j < levelSize; j++) {\n                if (2 * j + 1 < n) {\n                    leaves[j] = keccak256(abi.encodePacked(leaves[2 * j], leaves[2 * j + 1]));\n                } else {\n                    leaves[j] = leaves[2 * j];\n                }\n            }\n\n            n = levelSize;\n            index /= 2;\n        }\n\n        return abi.encodePacked(proof);\n    }\n\n    /**\n     * @notice this function returns the merkle root of a tree created from a set of leaves using keccak256 as its hash function\n     *  @param leaves the leaves of the merkle tree\n     *  @return The computed Merkle root of the tree.\n     *  @dev This pads to the next power of 2. very inefficient! just for POC\n     */\n    function merkleizeKeccak(\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32) {\n        // uint256 paddedLength = 2;\n        // while(paddedLength < leaves.length) {\n        //     paddedLength <<= 1;\n        // }\n\n        // bytes32[] memory paddedLeaves = new bytes32[](paddedLength);\n        // for (uint256 i = 0; i < leaves.length; i++) {\n        //     paddedLeaves[i] = leaves[i];\n        // }\n        leaves = padLeaves(leaves);\n\n        //there are half as many nodes in the layer above the leaves\n        uint256 numNodesInLayer = leaves.length / 2;\n        //create a layer to store the internal nodes\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\n        //fill the layer with the pairwise hashes of the leaves\n        for (uint256 i = 0; i < numNodesInLayer; i++) {\n            layer[i] = keccak256(abi.encodePacked(leaves[2 * i], leaves[2 * i + 1]));\n        }\n        //the next layer above has half as many nodes\n        numNodesInLayer /= 2;\n        //while we haven't computed the root\n        while (numNodesInLayer != 0) {\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\n            for (uint256 i = 0; i < numNodesInLayer; i++) {\n                layer[i] = keccak256(abi.encodePacked(layer[2 * i], layer[2 * i + 1]));\n            }\n            //the next layer above has half as many nodes\n            numNodesInLayer /= 2;\n        }\n        //the first node in the layer is the root\n        return layer[0];\n    }\n\n    function padLeaves(\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32[] memory) {\n        uint256 paddedLength = 2;\n        while (paddedLength < leaves.length) {\n            paddedLength <<= 1;\n        }\n\n        bytes32[] memory paddedLeaves = new bytes32[](paddedLength);\n        for (uint256 i = 0; i < leaves.length; i++) {\n            paddedLeaves[i] = leaves[i];\n        }\n        return paddedLeaves;\n    }\n}"
  },
  {
    "path": "contracts/script/utils/UpgradeableProxyLib.sol",
    "summary": "File starts: // SPDX-License-Identifier: UNLICENSED",
    "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Vm} from \"forge-std/Vm.sol\";\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {\n    ITransparentUpgradeableProxy,\n    TransparentUpgradeableProxy\n} from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {EmptyContract} from \"@eigenlayer/test/mocks/EmptyContract.sol\";\n\nlibrary UpgradeableProxyLib {\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    bytes32 internal constant ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    Vm internal constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function deployProxyAdmin() internal returns (address) {\n        return address(new ProxyAdmin());\n    }\n\n    function setUpEmptyProxy(\n        address admin\n    ) internal returns (address) {\n        address emptyContract = address(new EmptyContract());\n        return address(new TransparentUpgradeableProxy(emptyContract, admin, \"\"));\n    }\n\n    function upgrade(address proxy, address impl) internal {\n        ProxyAdmin admin = getProxyAdmin(proxy);\n        admin.upgrade(ITransparentUpgradeableProxy(payable(proxy)), impl);\n    }\n\n    function upgradeAndCall(address proxy, address impl, bytes memory initData) internal {\n        ProxyAdmin admin = getProxyAdmin(proxy);\n        admin.upgradeAndCall(ITransparentUpgradeableProxy(payable(proxy)), impl, initData);\n    }\n\n    function getImplementation(\n        address proxy\n    ) internal view returns (address) {\n        bytes32 value = vm.load(proxy, IMPLEMENTATION_SLOT);\n        return address(uint160(uint256(value)));\n    }\n\n    function getProxyAdmin(\n        address proxy\n    ) internal view returns (ProxyAdmin) {\n        bytes32 value = vm.load(proxy, ADMIN_SLOT);\n        return ProxyAdmin(address(uint160(uint256(value))));\n    }\n}"
  },
  {
    "path": "contracts/script/DeployEigenLayerCore.s.sol",
    "summary": "File starts: // SPDX-License-Identifier: BUSL-1.1",
    "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.12;\n\nimport {Script} from \"forge-std/Script.sol\";\n\nimport {CoreDeployLib, CoreDeploymentParsingLib} from \"./utils/CoreDeploymentParsingLib.sol\";\nimport {UpgradeableProxyLib} from \"./utils/UpgradeableProxyLib.sol\";\n\nimport {IRewardsCoordinator} from \"@eigenlayer/contracts/interfaces/IRewardsCoordinator.sol\";\nimport {StrategyManager} from \"@eigenlayer/contracts/core/StrategyManager.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract DeployEigenLayerCore is Script, Test {\n    using CoreDeployLib for *;\n    using UpgradeableProxyLib for address;\n\n    address internal deployer;\n    address internal proxyAdmin;\n    CoreDeployLib.DeploymentData internal deploymentData;\n    CoreDeployLib.DeploymentConfigData internal configData;\n\n    function setUp() public virtual {\n        deployer = vm.rememberKey(vm.envUint(\"PRIVATE_KEY\"));\n        vm.label(deployer, \"Deployer\");\n    }\n\n    function run() external {\n        vm.startBroadcast(deployer);\n        //set the rewards updater to the deployer address for payment flow\n        configData =\n            CoreDeploymentParsingLib.readDeploymentConfigValues(\"config/core/\", block.chainid);\n        configData.rewardsCoordinator.rewardsUpdater = deployer;\n        proxyAdmin = UpgradeableProxyLib.deployProxyAdmin();\n        deploymentData = CoreDeployLib.deployContracts(proxyAdmin, configData);\n\n        // TODO: the deployer lib should probably do this\n        StrategyManager(deploymentData.strategyManager).setStrategyWhitelister(\n            deploymentData.strategyFactory\n        );\n        vm.stopBroadcast();\n        string memory deploymentPath = \"deployments/core/\";\n        CoreDeploymentParsingLib.writeDeploymentJson(deploymentPath, block.chainid, deploymentData);\n    }\n}"
  },
  {
    "path": "contracts/script/HelloWorldDeployer.s.sol",
    "summary": "File starts: // SPDX-License-Identifier: UNLICENSED",
    "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Script} from \"forge-std/Script.sol\";\nimport {console2} from \"forge-std/Test.sol\";\nimport {HelloWorldDeploymentLib} from \"./utils/HelloWorldDeploymentLib.sol\";\nimport {CoreDeployLib, CoreDeploymentParsingLib} from \"./utils/CoreDeploymentParsingLib.sol\";\nimport {UpgradeableProxyLib} from \"./utils/UpgradeableProxyLib.sol\";\nimport {StrategyBase} from \"@eigenlayer/contracts/strategies/StrategyBase.sol\";\nimport {ERC20Mock} from \"../test/ERC20Mock.sol\";\nimport {TransparentUpgradeableProxy} from\n    \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {StrategyFactory} from \"@eigenlayer/contracts/strategies/StrategyFactory.sol\";\nimport {StrategyManager} from \"@eigenlayer/contracts/core/StrategyManager.sol\";\nimport {IRewardsCoordinator} from \"@eigenlayer/contracts/interfaces/IRewardsCoordinator.sol\";\n\nimport {\n    IECDSAStakeRegistryTypes,\n    IStrategy\n} from \"@eigenlayer-middleware/src/interfaces/IECDSAStakeRegistry.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract HelloWorldDeployer is Script, Test {\n    using CoreDeployLib for *;\n    using UpgradeableProxyLib for address;\n\n    address private deployer;\n    address proxyAdmin;\n    address rewardsOwner;\n    address rewardsInitiator;\n    IStrategy helloWorldStrategy;\n    CoreDeployLib.DeploymentData coreDeployment;\n    HelloWorldDeploymentLib.DeploymentData helloWorldDeployment;\n    HelloWorldDeploymentLib.DeploymentConfigData helloWorldConfig;\n    IECDSAStakeRegistryTypes.Quorum internal quorum;\n    ERC20Mock token;\n\n    function setUp() public virtual {\n        deployer = vm.rememberKey(vm.envUint(\"PRIVATE_KEY\"));\n        vm.label(deployer, \"Deployer\");\n\n        helloWorldConfig =\n            HelloWorldDeploymentLib.readDeploymentConfigValues(\"config/hello-world/\", block.chainid);\n\n        coreDeployment =\n            CoreDeploymentParsingLib.readDeploymentJson(\"deployments/core/\", block.chainid);\n    }\n\n    function run() external {\n        vm.startBroadcast(deployer);\n        rewardsOwner = helloWorldConfig.rewardsOwner;\n        rewardsInitiator = helloWorldConfig.rewardsInitiator;\n\n        token = new ERC20Mock();\n        // NOTE: if this fails, it's because the initialStrategyWhitelister is not set to be the StrategyFactory\n        helloWorldStrategy =\n            IStrategy(StrategyFactory(coreDeployment.strategyFactory).deployNewStrategy(token));\n\n        quorum.strategies.push(\n            IECDSAStakeRegistryTypes.StrategyParams({\n                strategy: helloWorldStrategy,\n                multiplier: 10_000\n            })\n        );\n\n        token.mint(deployer, 2000);\n        token.increaseAllowance(address(coreDeployment.strategyManager), 1000);\n        StrategyManager(coreDeployment.strategyManager).depositIntoStrategy(\n            helloWorldStrategy, token, 1000\n        );\n\n        proxyAdmin = UpgradeableProxyLib.deployProxyAdmin();\n\n        helloWorldDeployment = HelloWorldDeploymentLib.deployContracts(\n            proxyAdmin, coreDeployment, quorum, rewardsInitiator, rewardsOwner\n        );\n\n        helloWorldDeployment.strategy = address(helloWorldStrategy);\n        helloWorldDeployment.token = address(token);\n\n        vm.stopBroadcast();\n        verifyDeployment();\n        HelloWorldDeploymentLib.writeDeploymentJson(helloWorldDeployment);\n    }\n\n    function verifyDeployment() internal view {\n        require(\n            helloWorldDeployment.stakeRegistry != address(0), \"StakeRegistry address cannot be zero\"\n        );\n        require(\n            helloWorldDeployment.helloWorldServiceManager != address(0),\n            \"HelloWorldServiceManager address cannot be zero\"\n        );\n        require(helloWorldDeployment.strategy != address(0), \"Strategy address cannot be zero\");\n        require(proxyAdmin != address(0), \"ProxyAdmin address cannot be zero\");\n        require(\n            coreDeployment.delegationManager != address(0),\n            \"DelegationManager address cannot be zero\"\n        );\n        require(coreDeployment.avsDirectory != address(0), \"AVSDirectory address cannot be zero\");\n    }\n}"
  },
  {
    "path": "contracts/script/SetupDistributions.s.sol",
    "summary": "File starts: // SPDX-License-Identifier: UNLICENSED",
    "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Script} from \"forge-std/Script.sol\";\nimport {HelloWorldDeploymentLib} from \"./utils/HelloWorldDeploymentLib.sol\";\nimport {CoreDeployLib, CoreDeploymentParsingLib} from \"./utils/CoreDeploymentParsingLib.sol\";\nimport {SetupDistributionsLib} from \"./utils/SetupDistributionsLib.sol\";\nimport {IRewardsCoordinator} from \"@eigenlayer/contracts/interfaces/IRewardsCoordinator.sol\";\nimport {RewardsCoordinator} from \"@eigenlayer/contracts/core/RewardsCoordinator.sol\";\nimport {IStrategy} from \"@eigenlayer/contracts/interfaces/IStrategy.sol\";\nimport {ERC20Mock} from \"../test/ERC20Mock.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract SetupDistributions is Script, Test {\n    struct PaymentInfo {\n        address recipient;\n        uint32 numPayments;\n        uint32 amountPerPayment;\n        uint32 duration;\n        uint32 startTimestamp;\n        uint32 endTimestamp;\n        uint256 indexToProve;\n    }\n\n    address private deployer;\n    CoreDeployLib.DeploymentData coreDeployment;\n    CoreDeployLib.DeploymentConfigData coreConfig;\n\n    HelloWorldDeploymentLib.DeploymentData helloWorldDeployment;\n    HelloWorldDeploymentLib.DeploymentConfigData helloWorldConfig;\n\n    RewardsCoordinator rewardsCoordinator;\n    string internal constant paymentInfofilePath = \"test/mockData/scratch/payment_info.json\";\n    string internal constant filePath = \"test/mockData/scratch/payments.json\";\n\n    uint32 constant CALCULATION_INTERVAL_SECONDS = 1 days;\n    uint256 constant NUM_TOKEN_EARNINGS = 1;\n    //duration MUST be a multiple of CALCULATION_INTERVAL_SECONDS .\n    //https://github.com/Layr-Labs/eigenlayer-contracts/blob/865e723a6b5c634cf45cce1817dec0ea95f0e03b/src/contracts/core/RewardsCoordinator.sol#L439\n    uint32 constant DURATION = 172_800;\n    uint32 constant REWARDS_END_TIMESTAMP_GAP = 1 days;\n    uint256 constant NUM_EARNERS = 8;\n\n    uint32 numPayments = 8;\n    uint32 indexToProve = 0;\n    uint32 amountPerPayment = 100;\n\n    address recipient = address(1);\n    IRewardsCoordinator.EarnerTreeMerkleLeaf[] public earnerLeaves;\n    address[] public earners;\n    uint32 startTimestamp;\n    uint32 endTimestamp;\n    uint256 cumumlativePaymentMultiplier;\n    address nonceSender = 0x998abeb3E57409262aE5b751f60747921B33613E;\n\n    address operator1 = address(1);\n    address operator2 = address(2);\n\n    function setUp() public {\n        deployer = vm.rememberKey(vm.envUint(\"PRIVATE_KEY\"));\n        vm.label(deployer, \"Deployer\");\n\n        coreDeployment =\n            CoreDeploymentParsingLib.readDeploymentJson(\"deployments/core/\", block.chainid);\n        coreConfig =\n            CoreDeploymentParsingLib.readDeploymentConfigValues(\"config/core/\", block.chainid);\n        helloWorldDeployment =\n            HelloWorldDeploymentLib.readDeploymentJson(\"deployments/hello-world/\", block.chainid);\n        helloWorldConfig =\n            HelloWorldDeploymentLib.readDeploymentConfigValues(\"config/hello-world/\", block.chainid);\n\n        rewardsCoordinator = RewardsCoordinator(coreDeployment.rewardsCoordinator);\n\n        // TODO: Get the filePath from config\n    }\n\n    function run() external {\n        vm.startBroadcast(helloWorldConfig.rewardsInitiatorKey);\n\n        // Go back 4 days\n        uint256 targetStartTimestamp = block.timestamp - 4 days;\n        // Start Timestamp must be a multiple of CALCULATION_INTERVAL_SECONDS\n        uint32 diff = (uint32(targetStartTimestamp) % CALCULATION_INTERVAL_SECONDS);\n        startTimestamp = uint32(targetStartTimestamp) - diff;\n\n        endTimestamp = uint32(block.timestamp) - REWARDS_END_TIMESTAMP_GAP;\n        emit log_named_uint(\"startTimestamp\", startTimestamp);\n        emit log_named_uint(\"endTimestamp\", endTimestamp);\n        emit log_named_uint(\"block.timestamp\", block.timestamp);\n        emit log_named_uint(\"MAX_RETROACTIVE_LENGTH\", rewardsCoordinator.MAX_RETROACTIVE_LENGTH());\n        if (endTimestamp > block.timestamp) {\n            revert(\"RewardsEndTimestampNotElapsed.  Please wait to generate new payments.\");\n        }\n\n        // sets a multiplier based on block number such that cumulativeEarnings increase accordingly for multiple runs of this script in the same session\n        uint256 nonce = rewardsCoordinator.getDistributionRootsLength();\n        amountPerPayment = uint32(amountPerPayment * (nonce + 1));\n\n        createAVSRewardsSubmissions(numPayments, amountPerPayment, startTimestamp);\n        vm.stopBroadcast();\n        vm.startBroadcast(deployer);\n        earners = _getEarners(deployer);\n        submitPaymentRoot(earners, endTimestamp, numPayments, amountPerPayment);\n        vm.stopBroadcast();\n    }\n\n    function runOperatorDirected() external {\n        vm.startBroadcast(helloWorldConfig.rewardsInitiatorKey);\n\n        // Go back 4 days\n        uint256 targetStartTimestamp = block.timestamp - 4 days;\n        // Start Timestamp must be a multiple of CALCULATION_INTERVAL_SECONDS\n        uint32 diff = (uint32(targetStartTimestamp) % CALCULATION_INTERVAL_SECONDS);\n        startTimestamp = uint32(targetStartTimestamp) - diff;\n\n        endTimestamp = uint32(block.timestamp) - REWARDS_END_TIMESTAMP_GAP;\n        emit log_named_uint(\"startTimestamp\", startTimestamp);\n        emit log_named_uint(\"endTimestamp\", endTimestamp);\n        emit log_named_uint(\"block.timestamp\", block.timestamp);\n        emit log_named_uint(\"MAX_RETROACTIVE_LENGTH\", rewardsCoordinator.MAX_RETROACTIVE_LENGTH());\n        if (endTimestamp > block.timestamp) {\n            revert(\"RewardsEndTimestampNotElapsed.  Please wait to generate new payments.\");\n        }\n\n        // sets a multiplier based on block number such that cumulativeEarnings increase accordingly for multiple runs of this script in the same session\n        uint256 nonce = rewardsCoordinator.getDistributionRootsLength();\n        amountPerPayment = uint32(amountPerPayment * (nonce + 1));\n\n        createOperatorDirectedAVSRewardsSubmissions(\n            numPayments, amountPerPayment, startTimestamp, DURATION\n        );\n        vm.stopBroadcast();\n        vm.startBroadcast(deployer);\n        earners = _getEarners(deployer);\n        submitPaymentRoot(earners, endTimestamp, numPayments, amountPerPayment);\n        vm.stopBroadcast();\n    }\n\n    function executeProcessClaim() public {\n        uint256 nonce = rewardsCoordinator.getDistributionRootsLength();\n        amountPerPayment = uint32(amountPerPayment * nonce);\n\n        vm.startBroadcast(deployer);\n        earnerLeaves =\n            _getEarnerLeaves(_getEarners(deployer), amountPerPayment, helloWorldDeployment.strategy);\n        processClaim(\n            filePath, indexToProve, recipient, earnerLeaves[indexToProve], amountPerPayment\n        );\n        vm.stopBroadcast();\n    }\n\n    function createAVSRewardsSubmissions(\n        uint256 _numPayments,\n        uint256 _amountPerPayment,\n        uint32 _startTimestamp\n    ) public {\n        ERC20Mock(helloWorldDeployment.token).mint(\n            helloWorldConfig.rewardsInitiator, _amountPerPayment * _numPayments\n        );\n        ERC20Mock(helloWorldDeployment.token).increaseAllowance(\n            helloWorldDeployment.helloWorldServiceManager, _amountPerPayment * _numPayments\n        );\n        uint32 duration = rewardsCoordinator.MAX_REWARDS_DURATION();\n        SetupDistributionsLib.createAVSRewardsSubmissions(\n            helloWorldDeployment.helloWorldServiceManager,\n            helloWorldDeployment.strategy,\n            _numPayments,\n            _amountPerPayment,\n            duration,\n            _startTimestamp\n        );\n    }\n\n    function createOperatorDirectedAVSRewardsSubmissions(\n        uint256 _numPayments,\n        uint256 _amountPerPayment,\n        uint32 _startTimestamp,\n        uint32 duration\n    ) public {\n        ERC20Mock(helloWorldDeployment.token).mint(\n            helloWorldConfig.rewardsInitiator, _amountPerPayment * _numPayments\n        );\n        ERC20Mock(helloWorldDeployment.token).increaseAllowance(\n            helloWorldDeployment.helloWorldServiceManager, _amountPerPayment * _numPayments\n        );\n        address[] memory operators = new address[](2);\n        operators[0] = operator1;\n        operators[1] = operator2;\n\n        SetupDistributionsLib.createOperatorDirectedAVSRewardsSubmissions(\n            helloWorldDeployment.helloWorldServiceManager,\n            operators,\n            helloWorldDeployment.strategy,\n            _numPayments,\n            _amountPerPayment,\n            duration,\n            _startTimestamp\n        );\n    }\n\n    function processClaim(\n        string memory _filePath,\n        uint256 _indexToProve,\n        address _recipient,\n        IRewardsCoordinator.EarnerTreeMerkleLeaf memory _earnerLeaf,\n        uint32 _amountPerPayment\n    ) public {\n        SetupDistributionsLib.processClaim(\n            IRewardsCoordinator(coreDeployment.rewardsCoordinator),\n            _filePath,\n            _indexToProve,\n            _recipient,\n            _earnerLeaf,\n            NUM_TOKEN_EARNINGS,\n            helloWorldDeployment.strategy,\n            _amountPerPayment\n        );\n    }\n\n    function submitPaymentRoot(\n        address[] memory _earners,\n        uint32 _endTimestamp,\n        uint32 _numPayments,\n        uint32 _amountPerPayment\n    ) public {\n        emit log_named_uint(\"cumumlativePaymentMultiplier\", cumumlativePaymentMultiplier);\n        bytes32[] memory tokenLeaves = SetupDistributionsLib.createTokenLeaves(\n            IRewardsCoordinator(coreDeployment.rewardsCoordinator),\n            NUM_TOKEN_EARNINGS,\n            _amountPerPayment,\n            helloWorldDeployment.strategy\n        );\n        IRewardsCoordinator.EarnerTreeMerkleLeaf[] memory _earnerLeaves =\n            SetupDistributionsLib.createEarnerLeaves(_earners, tokenLeaves);\n        emit log_named_uint(\"Earner Leaves Length\", _earnerLeaves.length);\n        emit log_named_uint(\"numPayments\", _numPayments);\n\n        SetupDistributionsLib.submitRoot(\n            IRewardsCoordinator(coreDeployment.rewardsCoordinator),\n            tokenLeaves,\n            _earnerLeaves,\n            _endTimestamp,\n            _numPayments,\n            NUM_TOKEN_EARNINGS,\n            filePath\n        );\n    }\n\n    function _getEarnerLeaves(\n        address[] memory _earners,\n        uint32 _amountPerPayment,\n        address _strategy\n    ) internal view returns (IRewardsCoordinator.EarnerTreeMerkleLeaf[] memory) {\n        bytes32[] memory tokenLeaves = SetupDistributionsLib.createTokenLeaves(\n            IRewardsCoordinator(coreDeployment.rewardsCoordinator),\n            NUM_TOKEN_EARNINGS,\n            _amountPerPayment,\n            _strategy\n        );\n\n        IRewardsCoordinator.EarnerTreeMerkleLeaf[] memory _earnerLeaves =\n            SetupDistributionsLib.createEarnerLeaves(_earners, tokenLeaves);\n\n        return _earnerLeaves;\n    }\n\n    function _getEarners(\n        address _deployer\n    ) internal pure returns (address[] memory) {\n        address[] memory _earners = new address[](NUM_EARNERS);\n        for (uint256 i = 0; i < _earners.length; i++) {\n            _earners[i] = _deployer;\n        }\n        return _earners;\n    }\n}"
  },
  {
    "path": "contracts/src/HelloWorldServiceManager.sol",
    "summary": "File starts: // SPDX-License-Identifier: UNLICENSED",
    "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport {ECDSAServiceManagerBase} from\n    \"@eigenlayer-middleware/src/unaudited/ECDSAServiceManagerBase.sol\";\nimport {ECDSAStakeRegistry} from \"@eigenlayer-middleware/src/unaudited/ECDSAStakeRegistry.sol\";\nimport {IServiceManager} from \"@eigenlayer-middleware/src/interfaces/IServiceManager.sol\";\nimport {ECDSAUpgradeable} from\n    \"@openzeppelin-upgrades/contracts/utils/cryptography/ECDSAUpgradeable.sol\";\nimport {IERC1271Upgradeable} from\n    \"@openzeppelin-upgrades/contracts/interfaces/IERC1271Upgradeable.sol\";\nimport {IHelloWorldServiceManager} from \"./IHelloWorldServiceManager.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@eigenlayer/contracts/interfaces/IRewardsCoordinator.sol\";\nimport {IAllocationManager} from \"@eigenlayer/contracts/interfaces/IAllocationManager.sol\";\nimport {TransparentUpgradeableProxy} from\n    \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n/**\n * @title Primary entrypoint for procuring services from HelloWorld.\n * @author Eigen Labs, Inc.\n */\ncontract HelloWorldServiceManager is ECDSAServiceManagerBase, IHelloWorldServiceManager {\n    using ECDSAUpgradeable for bytes32;\n\n    uint32 public latestTaskNum;\n\n    // mapping of task indices to all tasks hashes\n    // when a task is created, task hash is stored here,\n    // and responses need to pass the actual task,\n    // which is hashed onchain and checked against this mapping\n    mapping(uint32 => bytes32) public allTaskHashes;\n\n    // mapping of task indices to hash of abi.encode(taskResponse, taskResponseMetadata)\n    mapping(address => mapping(uint32 => bytes)) public allTaskResponses;\n\n    // mapping of task indices to task status (true if task has been responded to, false otherwise)\n    // TODO: use bitmap?\n    mapping(uint32 => bool) public taskWasResponded;\n\n    // max interval in blocks for responding to a task\n    // operators can be penalized if they don't respond in time\n    uint32 public immutable MAX_RESPONSE_INTERVAL_BLOCKS;\n\n    modifier onlyOperator() {\n        require(\n            ECDSAStakeRegistry(stakeRegistry).operatorRegistered(msg.sender),\n            \"Operator must be the caller\"\n        );\n        _;\n    }\n\n    constructor(\n        address _avsDirectory,\n        address _stakeRegistry,\n        address _rewardsCoordinator,\n        address _delegationManager,\n        address _allocationManager,\n        uint32 _maxResponseIntervalBlocks\n    )\n        ECDSAServiceManagerBase(\n            _avsDirectory,\n            _stakeRegistry,\n            _rewardsCoordinator,\n            _delegationManager,\n            _allocationManager\n        )\n    {\n        MAX_RESPONSE_INTERVAL_BLOCKS = _maxResponseIntervalBlocks;\n    }\n\n    function initialize(address initialOwner, address _rewardsInitiator) external initializer {\n        __ServiceManagerBase_init(initialOwner, _rewardsInitiator);\n    }\n\n    // These are just to comply with IServiceManager interface\n    function addPendingAdmin(\n        address admin\n    ) external onlyOwner {}\n\n    function removePendingAdmin(\n        address pendingAdmin\n    ) external onlyOwner {}\n\n    function removeAdmin(\n        address admin\n    ) external onlyOwner {}\n\n    function setAppointee(address appointee, address target, bytes4 selector) external onlyOwner {}\n\n    function removeAppointee(\n        address appointee,\n        address target,\n        bytes4 selector\n    ) external onlyOwner {}\n\n    function deregisterOperatorFromOperatorSets(\n        address operator,\n        uint32[] memory operatorSetIds\n    ) external {\n        // unused\n    }\n\n    /* FUNCTIONS */\n    // NOTE: this function creates new task, assigns it a taskId\n    function createNewTask(\n        string memory name\n    ) external returns (Task memory) {\n        // create a new task struct\n        Task memory newTask;\n        newTask.name = name;\n        newTask.taskCreatedBlock = uint32(block.number);\n\n        // store hash of task onchain, emit event, and increase taskNum\n        allTaskHashes[latestTaskNum] = keccak256(abi.encode(newTask));\n        emit NewTaskCreated(latestTaskNum, newTask);\n        latestTaskNum = latestTaskNum + 1;\n\n        return newTask;\n    }\n\n    function respondToTask(\n        Task calldata task,\n        uint32 referenceTaskIndex,\n        bytes memory signature\n    ) external {\n        // check that the task is valid, hasn't been responded yet, and is being responded in time\n        require(\n            keccak256(abi.encode(task)) == allTaskHashes[referenceTaskIndex],\n            \"supplied task does not match the one recorded in the contract\"\n        );\n        require(\n            block.number <= task.taskCreatedBlock + MAX_RESPONSE_INTERVAL_BLOCKS,\n            \"Task response time has already expired\"\n        );\n\n        // The message that was signed\n        bytes32 messageHash = keccak256(abi.encodePacked(\"Hello, \", task.name));\n        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();\n        bytes4 magicValue = IERC1271Upgradeable.isValidSignature.selector;\n\n        // Decode the signature data to get operators and their signatures\n        (address[] memory operators, bytes[] memory signatures, uint32 referenceBlock) =\n            abi.decode(signature, (address[], bytes[], uint32));\n\n        // Check that referenceBlock matches task creation block\n        require(\n            referenceBlock == task.taskCreatedBlock,\n            \"Reference block must match task creation block\"\n        );\n\n        // Store each operator's signature\n        for (uint256 i = 0; i < operators.length; i++) {\n            // Check that this operator hasn't already responded\n            require(\n                allTaskResponses[operators[i]][referenceTaskIndex].length == 0,\n                \"Operator has already responded to the task\"\n            );\n\n            // Store the operator's signature\n            allTaskResponses[operators[i]][referenceTaskIndex] = signatures[i];\n\n            // Emit event for this operator\n            emit TaskResponded(referenceTaskIndex, task, operators[i]);\n        }\n\n        taskWasResponded[referenceTaskIndex] = true;\n\n        // Verify all signatures at once\n        bytes4 isValidSignatureResult =\n            ECDSAStakeRegistry(stakeRegistry).isValidSignature(ethSignedMessageHash, signature);\n\n        require(magicValue == isValidSignatureResult, \"Invalid signature\");\n    }\n\n    function slashOperator(\n        Task calldata task,\n        uint32 referenceTaskIndex,\n        address operator\n    ) external {\n        // check that the task is valid, hasn't been responsed yet\n        require(\n            keccak256(abi.encode(task)) == allTaskHashes[referenceTaskIndex],\n            \"supplied task does not match the one recorded in the contract\"\n        );\n        require(!taskWasResponded[referenceTaskIndex], \"Task has already been responded to\");\n        require(\n            allTaskResponses[operator][referenceTaskIndex].length == 0,\n            \"Operator has already responded to the task\"\n        );\n        require(\n            block.number > task.taskCreatedBlock + MAX_RESPONSE_INTERVAL_BLOCKS,\n            \"Task response time has not expired yet\"\n        );\n        // check operator was registered when task was created\n        uint256 operatorWeight = ECDSAStakeRegistry(stakeRegistry).getOperatorWeightAtBlock(\n            operator, task.taskCreatedBlock\n        );\n        require(operatorWeight > 0, \"Operator was not registered when task was created\");\n\n        // we update the storage with a sentinel value\n        allTaskResponses[operator][referenceTaskIndex] = \"slashed\";\n\n        // TODO: slash operator\n    }\n}"
  },
  {
    "path": "contracts/src/IHelloWorldServiceManager.sol",
    "summary": "File starts: // SPDX-License-Identifier: UNLICENSED",
    "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\ninterface IHelloWorldServiceManager {\n    event NewTaskCreated(uint32 indexed taskIndex, Task task);\n\n    event TaskResponded(uint32 indexed taskIndex, Task task, address operator);\n\n    struct Task {\n        string name;\n        uint32 taskCreatedBlock;\n    }\n\n    function latestTaskNum() external view returns (uint32);\n\n    function allTaskHashes(\n        uint32 taskIndex\n    ) external view returns (bytes32);\n\n    function allTaskResponses(\n        address operator,\n        uint32 taskIndex\n    ) external view returns (bytes memory);\n\n    function createNewTask(\n        string memory name\n    ) external returns (Task memory);\n\n    function respondToTask(\n        Task calldata task,\n        uint32 referenceTaskIndex,\n        bytes calldata signature\n    ) external;\n\n    function slashOperator(\n        Task calldata task,\n        uint32 referenceTaskIndex,\n        address operator\n    ) external;\n}"
  },
  {
    "path": "contracts/test/mockData/config/core/1337.json",
    "summary": "JSON file with keys: strategyManager, delegationManager, eigenPodManager, allocationManager, strategyFactory, avsDirectory, rewardsCoordinator.",
    "content": "{\n  \"strategyManager\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"initialStrategyWhitelister\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\n  },\n  \"delegationManager\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"minWithdrawalDelayBlocks\": 50400\n  },\n  \"eigenPodManager\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\n  },\n  \"allocationManager\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"deallocationDelay\": 0,\n    \"allocationConfigurationDelay\": 0\n  },\n  \"strategyFactory\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\n  },\n  \"avsDirectory\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\n  },\n  \"rewardsCoordinator\": {\n    \"initPausedStatus\": 0,\n    \"initialOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"rewardsUpdater\": \"0x1234567890123456789012345678901234567890\",\n    \"activationDelay\": 604800,\n    \"defaultSplitBips\": 1000,\n    \"calculationIntervalSeconds\": 86400,\n    \"maxRewardsDuration\": 864000,\n    \"maxRetroactiveLength\": 86400,\n    \"maxFutureLength\": 86400,\n    \"genesisRewardsTimestamp\": 1672531200\n  }\n}"
  },
  {
    "path": "contracts/test/mockData/config/hello-world/1337.json",
    "summary": "JSON file with keys: rewardsOwner, rewardsInitiator.",
    "content": "{\n  \"rewardsOwner\": \"0x\",\n  \"rewardsInitiator\": \"0x\"\n}"
  },
  {
    "path": "contracts/test/mockData/deployments/core/1337.json",
    "summary": "JSON file with keys: lastUpdate, addresses.",
    "content": "{\n  \"lastUpdate\": {\n    \"timestamp\": \"1740693626\",\n    \"block_number\": \"0\"\n  },\n  \"addresses\": {\n    \"proxyAdmin\": \"0x5fbdb2315678afecb367f032d93f642f64180aa3\",\n    \"delegationManager\": \"0x9fe46736679d2d9a65f0992f2272de9f3c7fa6e0\",\n    \"delegationManagerImpl\": \"0xa85233c63b9ee964add6f2cffe00fd84eb32338f\",\n    \"avsDirectory\": \"0xdc64a140aa3e981100a9beca4e685f962f0cf6c9\",\n    \"avsDirectoryImpl\": \"0x4a679253410272dd5232b3ff7cf5dbb88f295319\",\n    \"strategyManager\": \"0x0165878a594ca255338adfa4d48449f69242eb8f\",\n    \"strategyManagerImpl\": \"0x4ed7c70f96b99c776995fb64377f0d4ab3b0e1c1\",\n    \"eigenPodManager\": \"0x2279b7a0a67db372996a5fab50d91eaa73d2ebe6\",\n    \"eigenPodManagerImpl\": \"0xa82ff9afd8f496c3d6ac40e2a0f282e47488cfc9\",\n    \"allocationManager\": \"0x610178da211fef7d417bc0e6fed39f05609ad788\",\n    \"allocationManagerImpl\": \"0x322813fd9a801c5507c9de605d63cea4f2ce6c44\",\n    \"eigenPodBeacon\": \"0xa51c1fc2f0d1a1b8494ed1fe312d7c3a78ed91c0\",\n    \"pauserRegistry\": \"0x9a676e781a523b5d0c0e43731313a708cb607508\",\n    \"pauserRegistryImpl\": \"0x0dcd1bf9a1b36ce34237eeafef220932846bcd82\",\n    \"strategyFactory\": \"0x959922be3caee4b8cd9a407cc3ac1c251c2007b1\",\n    \"strategyFactoryImpl\": \"0x95401dc811bb5740090279ba06cfa8fcf6113778\",\n    \"strategyBeacon\": \"0xf5059a5d33d5853360d16c683c16e67980206f36\",\n    \"rewardsCoordinator\": \"0x68b1d87f95878fe05b998f19b66f4baba5de1aed\",\n    \"rewardsCoordinatorImpl\": \"0x70e0ba845a1a0f2da3359c97e0285013525ffc49\",\n    \"permissionController\": \"0xc6e7df5e7b4f2a278906862b61205850344d4e7d\",\n    \"permissionControllerImpl\": \"0x59b670e9fa9d0a427751af201d676719a970857b\"\n  }\n}"
  },
  {
    "path": "contracts/test/mockData/deployments/hello-world/1337.json",
    "summary": "JSON file with keys: lastUpdate, addresses.",
    "content": "{\n  \"lastUpdate\": {\n    \"timestamp\": \"1740693629\",\n    \"block_number\": \"39\"\n  },\n  \"addresses\": {\n    \"proxyAdmin\": \"0x8f86403a4de0bb5791fa46b8e795c547942fe4cf\",\n    \"helloWorldServiceManager\": \"0x5eb3bc0a489c5a8288765d2336659ebca68fcd00\",\n    \"helloWorldServiceManagerImpl\": \"0x5f3f1dbd7b74c6b46e8c44f98792a1daf8d69154\",\n    \"stakeRegistry\": \"0x809d550fca64d94bd9f66e60752a544199cfac3d\",\n    \"stakeRegistryImpl\": \"0x4c5859f0f772848b2d91f1d83e2fe57935348029\",\n    \"strategy\": \"0x24b3c7704709ed1491473f30393ffc93cfb0fc34\",\n    \"token\": \"0x99bba657f2bbc93c02d617f8ba121cb8fc104acf\"\n  }\n}"
  },
  {
    "path": "contracts/test/mockData/scratch/31337.json",
    "summary": "JSON file with keys: lastUpdate, addresses.",
    "content": "{\"lastUpdate\":{\"timestamp\":\"1\",\"block_number\":\"1\"},\"addresses\":{\"proxyAdmin\":\"0x5615deb798bb3e4dfa0139dfa1b3d433cc23b72f\",\"delegation\":\"0xf62849f9a0b5bf2913b396098f7c7019b51a820a\",\"delegationManagerImpl\":\"0xdb25a7b768311de128bbda7b8426c3f9c74f3240\",\"avsDirectory\":\"0xc7183455a4c133ae270771860664b6b7ec320bb1\",\"avsDirectoryImpl\":\"0x3381cd18e2fb4db236bf0525938ab6e43db0440f\",\"strategyManager\":\"0x1d1499e622d69689cdf9004d05ec547d650ff211\",\"strategyManagerImpl\":\"0x756e0562323adcda4430d6cb456d9151f605290b\",\"eigenPodManager\":\"0x03a6a84cd762d9707a21605b548aaab891562aab\",\"eigenPodManagerImpl\":\"0xe8dc788818033232ef9772cb2e6622f1ec8bc840\",\"strategyFactory\":\"0x13aa49bac059d709dd0a18d6bb63290076a702d7\",\"strategyFactoryImpl\":\"0x1af7f588a501ea2b5bb3feefa744892aa2cf00e6\",\"strategyBeacon\":\"0x886d6d1eb8d415b00052828cd6d5b321f072073d\",\"rewardsCoordinator\":\"0x15cf58144ef33af1e14b5208015d11f9143e27b9\"}}"
  },
  {
    "path": "contracts/test/mockData/scratch/payment_info.json",
    "summary": "JSON file with keys: paymentInfo.",
    "content": "{\n    \"paymentInfo\": {\n        \"recipient\": \"0x5555666677778888999900001111222233334444\",\n        \"numPayments\": 8,\n        \"amountPerPayment\": \"100000000000\",\n        \"duration\": 2592000,\n        \"startTimestamp\": 864000,\n        \"endTimestamp\": 1701907200,\n        \"indexToProve\": 0\n    }\n}"
  },
  {
    "path": "contracts/test/mockData/scratch/payments_test.json",
    "summary": "JSON file with keys: leaves, tokenLeaves.",
    "content": "{\n    \"leaves\": [\n      \"0x29036a1d92861ffd464a1e285030fad3978a36f953ae33c160e606d2ac746c42\",\n      \"0x29036a1d92861ffd464a1e285030fad3978a36f953ae33c160e606d2ac746c42\",\n      \"0x29036a1d92861ffd464a1e285030fad3978a36f953ae33c160e606d2ac746c42\",\n      \"0x29036a1d92861ffd464a1e285030fad3978a36f953ae33c160e606d2ac746c42\"\n    ],\n    \"tokenLeaves\": [\n      \"0xf5d87050cb923194fe63c7ed2c45cbc913fa6ecf322f3631149c36d9460b3ad6\"\n    ]\n  }"
  },
  {
    "path": "contracts/test/mockData/scratch/payments.json",
    "summary": "JSON file with keys: leaves, tokenLeaves.",
    "content": "{\n  \"leaves\": [\n    \"0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c\",\n    \"0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c\",\n    \"0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c\",\n    \"0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c\",\n    \"0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c\",\n    \"0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c\",\n    \"0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c\",\n    \"0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c\"\n  ],\n  \"tokenLeaves\": [\n    \"0xb85e3af535d0b85802155d225e67e51112a9404dba7a93c4dcfaca8ae5b9be9e\"\n  ]\n}"
  },
  {
    "path": "contracts/test/CoreDeploymentLib.t.sol",
    "summary": "File starts: // SPDX-License-Identifier: UNLICENSED",
    "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console2} from \"forge-std/console2.sol\";\nimport {\n    CoreDeployLib, CoreDeploymentParsingLib\n} from \"../script/utils/CoreDeploymentParsingLib.sol\";\nimport {UpgradeableProxyLib} from \"../script/utils/UpgradeableProxyLib.sol\";\n\ncontract CoreDeploymentParsingLibTest is Test {\n    using UpgradeableProxyLib for address;\n\n    address proxyAdmin;\n    CoreDeployLib.DeploymentData deploymentData;\n    CoreDeployLib.DeploymentConfigData configData;\n\n    function setUp() public {\n        proxyAdmin = UpgradeableProxyLib.deployProxyAdmin();\n    }\n\n    /// won't test specific functionality/values. Testing behavior of the library\n    function test_ReadConfig() public view {\n        CoreDeploymentParsingLib.readDeploymentConfigValues(\"test/mockData/config/core/\", 1337);\n    }\n\n    /// forge-config: default.allow_internal_expect_revert = true\n    function test_ReadConfig_Reverts() public {\n        vm.expectRevert();\n        /// Incorrect path\n        CoreDeploymentParsingLib.readDeploymentConfigValues(\"test/mockData/deployments/core/\", 1337);\n    }\n\n    function test_ReadDeployment() public view {\n        CoreDeploymentParsingLib.readDeploymentJson(\"test/mockData/deployments/core/\", 1337);\n    }\n\n    /// forge-config: default.allow_internal_expect_revert = true\n    function test_ReadDeployment_Reverts() public {\n        vm.expectRevert();\n        /// Incorrect path\n        CoreDeploymentParsingLib.readDeploymentJson(\"test/mockData/config/core/\", 1337);\n    }\n\n    function test_DeployContracts() public {\n        configData =\n            CoreDeploymentParsingLib.readDeploymentConfigValues(\"test/mockData/config/core/\", 1337);\n        deploymentData = CoreDeployLib.deployContracts(proxyAdmin, configData);\n\n        assertTrue(deploymentData.delegationManager != address(0), \"DelegationManager not deployed\");\n        assertTrue(deploymentData.avsDirectory != address(0), \"AVSDirectory not deployed\");\n        assertTrue(deploymentData.strategyManager != address(0), \"StrategyManager not deployed\");\n    }\n\n    function test_WriteDeploymentJson() public {\n        configData =\n            CoreDeploymentParsingLib.readDeploymentConfigValues(\"test/mockData/config/core/\", 1337);\n        deploymentData = CoreDeployLib.deployContracts(proxyAdmin, configData);\n\n        string memory scratchPath = \"test/mockData/scratch/test_WriteDeploymentJson/\";\n        CoreDeploymentParsingLib.writeDeploymentJson(scratchPath, block.chainid, deploymentData);\n\n        string memory fileName = string.concat(scratchPath, vm.toString(block.chainid), \".json\");\n        assertTrue(vm.exists(fileName), \"Deployment file not created\");\n\n        vm.removeFile(fileName);\n    }\n\n    function test_WriteAndReadDeploymentJson() public {\n        configData =\n            CoreDeploymentParsingLib.readDeploymentConfigValues(\"test/mockData/config/core/\", 1337);\n        deploymentData = CoreDeployLib.deployContracts(proxyAdmin, configData);\n\n        string memory scratchPath = \"test/mockData/scratch/test_WriteAndReadDeploymentJson/\";\n\n        CoreDeploymentParsingLib.writeDeploymentJson(scratchPath, block.chainid, deploymentData);\n\n        string memory fileName = string.concat(vm.toString(block.chainid), \".json\");\n\n        CoreDeploymentParsingLib.readDeploymentJson(scratchPath, fileName);\n\n        vm.removeFile(string.concat(scratchPath, fileName));\n    }\n\n    function test_ReadConfigFromM2DeploymentData() public {\n        /// TODO: Deployment json is missing the strategy factory\n        vm.skip(true);\n        // Path to the M2 deployment data JSON file\n        string memory m2DeploymentDataPath =\n            \"lib/eigenlayer-middleware/lib/eigenlayer-contracts/script/output/devnet/\";\n        string memory m2DeploymentFilename = \"M2_from_scratch_deployment_data.json\";\n\n        CoreDeploymentParsingLib.readDeploymentJson(m2DeploymentDataPath, m2DeploymentFilename);\n    }\n}"
  },
  {
    "path": "contracts/test/ERC20Mock.sol",
    "summary": "File starts: // SPDX-License-Identifier: MIT",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    constructor() ERC20(\"\", \"\") {}\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n}"
  },
  {
    "path": "contracts/test/HelloWorldServiceManager.t.sol",
    "summary": "File starts: // SPDX-License-Identifier: UNLICENSED",
    "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\nimport {HelloWorldServiceManager} from \"../src/HelloWorldServiceManager.sol\";\nimport {MockAVSDeployer} from \"@eigenlayer-middleware/test/utils/MockAVSDeployer.sol\";\nimport {ECDSAStakeRegistry} from \"@eigenlayer-middleware/src/unaudited/ECDSAStakeRegistry.sol\";\nimport {Vm} from \"forge-std/Vm.sol\";\nimport {console2} from \"forge-std/Test.sol\";\nimport {HelloWorldDeploymentLib} from \"../script/utils/HelloWorldDeploymentLib.sol\";\nimport {\n    CoreDeployLib, CoreDeploymentParsingLib\n} from \"../script/utils/CoreDeploymentParsingLib.sol\";\nimport {UpgradeableProxyLib} from \"../script/utils/UpgradeableProxyLib.sol\";\nimport {ERC20Mock} from \"./ERC20Mock.sol\";\nimport {IERC20, StrategyFactory} from \"@eigenlayer/contracts/strategies/StrategyFactory.sol\";\n\nimport {\n    IECDSAStakeRegistryTypes,\n    IStrategy\n} from \"@eigenlayer-middleware/src/interfaces/IECDSAStakeRegistry.sol\";\nimport {IStrategyManager} from \"@eigenlayer/contracts/interfaces/IStrategyManager.sol\";\nimport {\n    IDelegationManager,\n    IDelegationManagerTypes\n} from \"@eigenlayer/contracts/interfaces/IDelegationManager.sol\";\nimport {DelegationManager} from \"@eigenlayer/contracts/core/DelegationManager.sol\";\nimport {StrategyManager} from \"@eigenlayer/contracts/core/StrategyManager.sol\";\nimport {ISignatureUtilsMixinTypes} from \"@eigenlayer/contracts/interfaces/ISignatureUtilsMixin.sol\";\nimport {AVSDirectory} from \"@eigenlayer/contracts/core/AVSDirectory.sol\";\nimport {IAVSDirectoryTypes} from \"@eigenlayer/contracts/interfaces/IAVSDirectory.sol\";\nimport {Test, console2 as console} from \"forge-std/Test.sol\";\nimport {IHelloWorldServiceManager} from \"../src/IHelloWorldServiceManager.sol\";\nimport {ECDSAUpgradeable} from\n    \"@openzeppelin-upgrades/contracts/utils/cryptography/ECDSAUpgradeable.sol\";\n\ncontract HelloWorldTaskManagerSetup is Test {\n    // used for `toEthSignedMessageHash`\n    using ECDSAUpgradeable for bytes32;\n\n    IECDSAStakeRegistryTypes.Quorum internal quorum;\n\n    struct Operator {\n        Vm.Wallet key;\n        Vm.Wallet signingKey;\n    }\n\n    struct TrafficGenerator {\n        Vm.Wallet key;\n    }\n\n    struct AVSOwner {\n        Vm.Wallet key;\n    }\n\n    Operator[] internal operators;\n    TrafficGenerator internal generator;\n    AVSOwner internal owner;\n\n    HelloWorldDeploymentLib.DeploymentData internal helloWorldDeployment;\n    CoreDeployLib.DeploymentData internal coreDeployment;\n    CoreDeployLib.DeploymentConfigData coreConfigData;\n\n    address proxyAdmin;\n\n    ERC20Mock public mockToken;\n\n    mapping(address => IStrategy) public tokenToStrategy;\n\n    function setUp() public virtual {\n        generator = TrafficGenerator({key: vm.createWallet(\"generator_wallet\")});\n        owner = AVSOwner({key: vm.createWallet(\"owner_wallet\")});\n\n        proxyAdmin = UpgradeableProxyLib.deployProxyAdmin();\n\n        coreConfigData =\n            CoreDeploymentParsingLib.readDeploymentConfigValues(\"test/mockData/config/core/\", 1337);\n        coreDeployment = CoreDeployLib.deployContracts(proxyAdmin, coreConfigData);\n\n        vm.prank(coreConfigData.strategyManager.initialOwner);\n        StrategyManager(coreDeployment.strategyManager).setStrategyWhitelister(\n            coreDeployment.strategyFactory\n        );\n\n        mockToken = new ERC20Mock();\n\n        IStrategy strategy = addStrategy(address(mockToken));\n        quorum.strategies.push(\n            IECDSAStakeRegistryTypes.StrategyParams({strategy: strategy, multiplier: 10_000})\n        );\n\n        helloWorldDeployment = HelloWorldDeploymentLib.deployContracts(\n            proxyAdmin, coreDeployment, quorum, owner.key.addr, owner.key.addr\n        );\n        helloWorldDeployment.strategy = address(strategy);\n        helloWorldDeployment.token = address(mockToken);\n        labelContracts(coreDeployment, helloWorldDeployment);\n    }\n\n    function addStrategy(\n        address token\n    ) public returns (IStrategy) {\n        if (tokenToStrategy[token] != IStrategy(address(0))) {\n            return tokenToStrategy[token];\n        }\n\n        StrategyFactory strategyFactory = StrategyFactory(coreDeployment.strategyFactory);\n        IStrategy newStrategy = strategyFactory.deployNewStrategy(IERC20(token));\n        tokenToStrategy[token] = newStrategy;\n        return newStrategy;\n    }\n\n    function labelContracts(\n        CoreDeployLib.DeploymentData memory _coreDeployment,\n        HelloWorldDeploymentLib.DeploymentData memory _helloWorldDeployment\n    ) internal {\n        vm.label(_coreDeployment.delegationManager, \"DelegationManager\");\n        vm.label(_coreDeployment.avsDirectory, \"AVSDirectory\");\n        vm.label(_coreDeployment.strategyManager, \"StrategyManager\");\n        vm.label(_coreDeployment.eigenPodManager, \"EigenPodManager\");\n        vm.label(_coreDeployment.rewardsCoordinator, \"RewardsCoordinator\");\n        vm.label(_coreDeployment.eigenPodBeacon, \"EigenPodBeacon\");\n        vm.label(_coreDeployment.pauserRegistry, \"PauserRegistry\");\n        vm.label(_coreDeployment.strategyFactory, \"StrategyFactory\");\n        vm.label(_coreDeployment.strategyBeacon, \"StrategyBeacon\");\n        vm.label(_helloWorldDeployment.helloWorldServiceManager, \"HelloWorldServiceManager\");\n        vm.label(_helloWorldDeployment.stakeRegistry, \"StakeRegistry\");\n    }\n\n    function signWithOperatorKey(\n        Operator memory operator,\n        bytes32 digest\n    ) internal pure returns (bytes memory) {\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(operator.key.privateKey, digest);\n        return abi.encodePacked(r, s, v);\n    }\n\n    function signWithSigningKey(\n        Operator memory operator,\n        bytes32 digest\n    ) internal pure returns (bytes memory) {\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(operator.signingKey.privateKey, digest);\n        return abi.encodePacked(r, s, v);\n    }\n\n    function mintMockTokens(Operator memory operator, uint256 amount) internal {\n        mockToken.mint(operator.key.addr, amount);\n    }\n\n    function depositTokenIntoStrategy(\n        Operator memory operator,\n        address token,\n        uint256 amount\n    ) internal returns (uint256) {\n        IStrategy strategy = IStrategy(tokenToStrategy[token]);\n        require(address(strategy) != address(0), \"Strategy was not found\");\n        IStrategyManager strategyManager = IStrategyManager(coreDeployment.strategyManager);\n\n        vm.startPrank(operator.key.addr);\n        mockToken.approve(address(strategyManager), amount);\n        uint256 shares = strategyManager.depositIntoStrategy(strategy, IERC20(token), amount);\n        vm.stopPrank();\n\n        return shares;\n    }\n\n    function registerAsOperator(\n        Operator memory operator\n    ) internal {\n        IDelegationManager delegationManager = IDelegationManager(coreDeployment.delegationManager);\n\n        vm.prank(operator.key.addr);\n        delegationManager.registerAsOperator(address(0), 0, \"\");\n    }\n\n    function registerOperatorToAVS(\n        Operator memory operator\n    ) internal {\n        ECDSAStakeRegistry stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);\n        AVSDirectory avsDirectory = AVSDirectory(coreDeployment.avsDirectory);\n\n        bytes32 salt = keccak256(abi.encodePacked(block.timestamp, operator.key.addr));\n        uint256 expiry = block.timestamp + 1 hours;\n\n        bytes32 operatorRegistrationDigestHash = avsDirectory\n            .calculateOperatorAVSRegistrationDigestHash(\n            operator.key.addr, address(helloWorldDeployment.helloWorldServiceManager), salt, expiry\n        );\n\n        bytes memory signature = signWithOperatorKey(operator, operatorRegistrationDigestHash);\n\n        ISignatureUtilsMixinTypes.SignatureWithSaltAndExpiry memory operatorSignature =\n        ISignatureUtilsMixinTypes.SignatureWithSaltAndExpiry({\n            signature: signature,\n            salt: salt,\n            expiry: expiry\n        });\n\n        vm.prank(address(operator.key.addr));\n        stakeRegistry.registerOperatorWithSignature(operatorSignature, operator.signingKey.addr);\n    }\n\n    function deregisterOperatorFromAVS(\n        Operator memory operator\n    ) internal {\n        ECDSAStakeRegistry stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);\n\n        vm.prank(operator.key.addr);\n        stakeRegistry.deregisterOperator();\n    }\n\n    function createAndAddOperator() internal returns (Operator memory) {\n        Vm.Wallet memory operatorKey =\n            vm.createWallet(string.concat(\"operator\", vm.toString(operators.length)));\n        Vm.Wallet memory signingKey =\n            vm.createWallet(string.concat(\"signing\", vm.toString(operators.length)));\n\n        Operator memory newOperator = Operator({key: operatorKey, signingKey: signingKey});\n\n        operators.push(newOperator);\n        return newOperator;\n    }\n\n    function updateOperatorWeights(\n        Operator[] memory _operators\n    ) internal {\n        ECDSAStakeRegistry stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);\n\n        address[] memory operatorAddresses = new address[](_operators.length);\n        for (uint256 i = 0; i < _operators.length; i++) {\n            operatorAddresses[i] = _operators[i].key.addr;\n        }\n\n        stakeRegistry.updateOperators(operatorAddresses);\n    }\n\n    function getOperators(\n        uint256 numOperators\n    ) internal view returns (Operator[] memory) {\n        require(numOperators <= operators.length, \"Not enough operators\");\n\n        Operator[] memory operatorsMem = new Operator[](numOperators);\n        for (uint256 i = 0; i < numOperators; i++) {\n            operatorsMem[i] = operators[i];\n        }\n        // Sort the operators by address\n        for (uint256 i = 0; i < numOperators - 1; i++) {\n            uint256 minIndex = i;\n            // Find the minimum operator by address\n            for (uint256 j = i + 1; j < numOperators; j++) {\n                if (operatorsMem[minIndex].key.addr > operatorsMem[j].key.addr) {\n                    minIndex = j;\n                }\n            }\n            // Swap the minimum operator with the ith operator\n            Operator memory temp = operatorsMem[i];\n            operatorsMem[i] = operatorsMem[minIndex];\n            operatorsMem[minIndex] = temp;\n        }\n        return operatorsMem;\n    }\n\n    function createTask(\n        string memory taskName\n    ) internal returns (IHelloWorldServiceManager.Task memory task, uint32 taskIndex) {\n        IHelloWorldServiceManager helloWorldServiceManager =\n            IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager);\n\n        vm.prank(generator.key.addr);\n        taskIndex = helloWorldServiceManager.latestTaskNum();\n        task = helloWorldServiceManager.createNewTask(taskName);\n        return (task, taskIndex);\n    }\n\n    function respondToTask(\n        Operator[] memory operatorsMem,\n        IHelloWorldServiceManager.Task memory task,\n        uint32 referenceTaskIndex\n    ) internal {\n        bytes memory signedResponse = makeTaskResponse(operatorsMem, task);\n\n        IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager).respondToTask(\n            task, referenceTaskIndex, signedResponse\n        );\n    }\n\n    function makeTaskResponse(\n        Operator[] memory operatorsMem,\n        IHelloWorldServiceManager.Task memory task\n    ) internal pure returns (bytes memory) {\n        bytes32 messageHash = keccak256(abi.encodePacked(\"Hello, \", task.name));\n        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();\n\n        address[] memory operatorAddrs = new address[](operatorsMem.length);\n        for (uint256 i = 0; i < operatorsMem.length; i++) {\n            operatorAddrs[i] = operatorsMem[i].key.addr;\n        }\n        bytes[] memory signatures = new bytes[](operatorsMem.length);\n        for (uint256 i = 0; i < operatorsMem.length; i++) {\n            signatures[i] = signWithSigningKey(operatorsMem[i], ethSignedMessageHash);\n        }\n\n        bytes memory signedTask = abi.encode(operatorAddrs, signatures, task.taskCreatedBlock);\n\n        return signedTask;\n    }\n\n    function slashOperator(\n        IHelloWorldServiceManager.Task memory task,\n        uint32 referenceTaskIndex,\n        address operator\n    ) internal {\n        IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager).slashOperator(\n            task, referenceTaskIndex, operator\n        );\n    }\n}\n\ncontract HelloWorldServiceManagerInitialization is HelloWorldTaskManagerSetup {\n    function testInitialization() public view {\n        ECDSAStakeRegistry stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);\n\n        IECDSAStakeRegistryTypes.Quorum memory quorum = stakeRegistry.quorum();\n\n        assertGt(quorum.strategies.length, 0, \"No strategies in quorum\");\n        assertEq(\n            address(quorum.strategies[0].strategy),\n            address(tokenToStrategy[address(mockToken)]),\n            \"First strategy doesn't match mock token strategy\"\n        );\n\n        assertTrue(helloWorldDeployment.stakeRegistry != address(0), \"StakeRegistry not deployed\");\n        assertTrue(\n            helloWorldDeployment.helloWorldServiceManager != address(0),\n            \"HelloWorldServiceManager not deployed\"\n        );\n        assertTrue(coreDeployment.delegationManager != address(0), \"DelegationManager not deployed\");\n        assertTrue(coreDeployment.avsDirectory != address(0), \"AVSDirectory not deployed\");\n        assertTrue(coreDeployment.strategyManager != address(0), \"StrategyManager not deployed\");\n        assertTrue(coreDeployment.eigenPodManager != address(0), \"EigenPodManager not deployed\");\n        assertTrue(coreDeployment.strategyFactory != address(0), \"StrategyFactory not deployed\");\n        assertTrue(coreDeployment.strategyBeacon != address(0), \"StrategyBeacon not deployed\");\n    }\n}\n\ncontract RegisterOperator is HelloWorldTaskManagerSetup {\n    uint256 internal constant INITIAL_BALANCE = 100 ether;\n    uint256 internal constant DEPOSIT_AMOUNT = 1 ether;\n    uint256 internal constant OPERATOR_COUNT = 4;\n\n    DelegationManager internal delegationManager;\n    AVSDirectory internal avsDirectory;\n    IHelloWorldServiceManager internal sm;\n    ECDSAStakeRegistry internal stakeRegistry;\n\n    function setUp() public virtual override {\n        super.setUp();\n        /// Setting to internal state for convenience\n        delegationManager = DelegationManager(coreDeployment.delegationManager);\n        avsDirectory = AVSDirectory(coreDeployment.avsDirectory);\n        sm = IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager);\n        stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);\n\n        addStrategy(address(mockToken));\n\n        while (operators.length < OPERATOR_COUNT) {\n            createAndAddOperator();\n        }\n\n        for (uint256 i = 0; i < OPERATOR_COUNT; i++) {\n            mintMockTokens(operators[i], INITIAL_BALANCE);\n\n            depositTokenIntoStrategy(operators[i], address(mockToken), DEPOSIT_AMOUNT);\n\n            registerAsOperator(operators[i]);\n        }\n    }\n\n    function testVerifyOperatorStates() public view {\n        for (uint256 i = 0; i < OPERATOR_COUNT; i++) {\n            address operatorAddr = operators[i].key.addr;\n\n            uint256 operatorShares =\n                delegationManager.operatorShares(operatorAddr, tokenToStrategy[address(mockToken)]);\n            assertEq(\n                operatorShares, DEPOSIT_AMOUNT, \"Operator shares in DelegationManager incorrect\"\n            );\n        }\n    }\n\n    function test_RegisterOperatorToAVS() public {\n        address operatorAddr = operators[0].key.addr;\n        registerOperatorToAVS(operators[0]);\n        assertTrue(\n            avsDirectory.avsOperatorStatus(address(sm), operatorAddr)\n                == IAVSDirectoryTypes.OperatorAVSRegistrationStatus.REGISTERED,\n            \"Operator not registered in AVSDirectory\"\n        );\n\n        address signingKey = stakeRegistry.getLatestOperatorSigningKey(operatorAddr);\n        assertTrue(signingKey != address(0), \"Operator signing key not set in ECDSAStakeRegistry\");\n\n        uint256 operatorWeight = stakeRegistry.getLastCheckpointOperatorWeight(operatorAddr);\n        assertTrue(operatorWeight > 0, \"Operator weight not set in ECDSAStakeRegistry\");\n    }\n}\n\ncontract CreateTask is HelloWorldTaskManagerSetup {\n    IHelloWorldServiceManager internal sm;\n\n    function setUp() public override {\n        super.setUp();\n        sm = IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager);\n    }\n\n    function testCreateTask() public {\n        string memory taskName = \"Test Task\";\n\n        vm.prank(generator.key.addr);\n        IHelloWorldServiceManager.Task memory newTask = sm.createNewTask(taskName);\n\n        require(\n            sha256(abi.encodePacked(newTask.name)) == sha256(abi.encodePacked(taskName)),\n            \"Task name not set correctly\"\n        );\n        require(\n            newTask.taskCreatedBlock == uint32(block.number), \"Task created block not set correctly\"\n        );\n    }\n}\n\ncontract RespondToTask is HelloWorldTaskManagerSetup {\n    uint256 internal constant INITIAL_BALANCE = 100 ether;\n    uint256 internal constant DEPOSIT_AMOUNT = 1 ether;\n    uint256 internal constant OPERATOR_COUNT = 4;\n\n    IDelegationManager internal delegationManager;\n    AVSDirectory internal avsDirectory;\n    IHelloWorldServiceManager internal sm;\n    ECDSAStakeRegistry internal stakeRegistry;\n\n    function setUp() public override {\n        super.setUp();\n\n        delegationManager = IDelegationManager(coreDeployment.delegationManager);\n        avsDirectory = AVSDirectory(coreDeployment.avsDirectory);\n        sm = IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager);\n        stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);\n\n        addStrategy(address(mockToken));\n\n        while (operators.length < OPERATOR_COUNT) {\n            createAndAddOperator();\n        }\n\n        for (uint256 i = 0; i < OPERATOR_COUNT; i++) {\n            mintMockTokens(operators[i], INITIAL_BALANCE);\n\n            depositTokenIntoStrategy(operators[i], address(mockToken), DEPOSIT_AMOUNT);\n\n            registerAsOperator(operators[i]);\n\n            registerOperatorToAVS(operators[i]);\n        }\n    }\n\n    function testRespondToTask() public {\n        (IHelloWorldServiceManager.Task memory newTask, uint32 taskIndex) = createTask(\"TestTask\");\n\n        Operator[] memory operatorsMem = getOperators(1);\n        bytes memory signedResponse = makeTaskResponse(operatorsMem, newTask);\n\n        vm.roll(block.number + 1);\n        sm.respondToTask(newTask, taskIndex, signedResponse);\n    }\n\n    function testRespondToTaskWith2OperatorsAggregatedSignature() public {\n        (IHelloWorldServiceManager.Task memory newTask, uint32 taskIndex) =\n            createTask(\"TestTask2Aggregated\");\n\n        // Generate aggregated response with two operators\n        Operator[] memory operatorsMem = getOperators(2);\n        bytes memory signedResponse = makeTaskResponse(operatorsMem, newTask);\n\n        vm.roll(block.number + 1);\n        sm.respondToTask(newTask, taskIndex, signedResponse);\n    }\n\n    function testRespondToTaskWith3OperatorsAggregatedSignature() public {\n        (IHelloWorldServiceManager.Task memory newTask, uint32 taskIndex) =\n            createTask(\"TestTask3Aggregated\");\n\n        // Generate aggregated response with three operators\n        Operator[] memory operatorsMem = getOperators(3);\n        bytes memory signedResponse = makeTaskResponse(operatorsMem, newTask);\n\n        vm.roll(block.number + 1);\n        sm.respondToTask(newTask, taskIndex, signedResponse);\n    }\n}\n\ncontract SlashOperator is HelloWorldTaskManagerSetup {\n    uint256 internal constant INITIAL_BALANCE = 100 ether;\n    uint256 internal constant DEPOSIT_AMOUNT = 1 ether;\n    uint256 internal constant OPERATOR_COUNT = 4;\n\n    IDelegationManager internal delegationManager;\n    AVSDirectory internal avsDirectory;\n    IHelloWorldServiceManager internal sm;\n    ECDSAStakeRegistry internal stakeRegistry;\n\n    function setUp() public override {\n        super.setUp();\n\n        delegationManager = IDelegationManager(coreDeployment.delegationManager);\n        avsDirectory = AVSDirectory(coreDeployment.avsDirectory);\n        sm = IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager);\n        stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);\n\n        addStrategy(address(mockToken));\n\n        while (operators.length < OPERATOR_COUNT) {\n            createAndAddOperator();\n        }\n\n        for (uint256 i = 0; i < OPERATOR_COUNT; i++) {\n            mintMockTokens(operators[i], INITIAL_BALANCE);\n\n            depositTokenIntoStrategy(operators[i], address(mockToken), DEPOSIT_AMOUNT);\n\n            registerAsOperator(operators[i]);\n\n            registerOperatorToAVS(operators[i]);\n        }\n    }\n\n    function testValidResponseIsNotSlashable() public {\n        (IHelloWorldServiceManager.Task memory newTask, uint32 taskIndex) =\n            createTask(\"TestValidResponseIsNotSlashable\");\n\n        Operator[] memory operatorsMem = getOperators(1);\n\n        vm.roll(block.number + 1);\n        respondToTask(operatorsMem, newTask, taskIndex);\n\n        vm.expectRevert(\"Task has already been responded to\");\n        slashOperator(newTask, taskIndex, operatorsMem[0].key.addr);\n\n        // TODO: check the operator's balance was not reduced\n    }\n\n    function testNoResponseIsSlashable() public {\n        (IHelloWorldServiceManager.Task memory newTask, uint32 taskIndex) =\n            createTask(\"TestNoResponseIsSlashable\");\n\n        Operator[] memory operatorsMem = getOperators(1);\n\n        uint32 maxResponseIntervalBlocks =\n            HelloWorldServiceManager(address(sm)).MAX_RESPONSE_INTERVAL_BLOCKS();\n        vm.roll(block.number + maxResponseIntervalBlocks + 1);\n\n        slashOperator(newTask, taskIndex, operatorsMem[0].key.addr);\n\n        // TODO: check the operator's balance was reduced\n    }\n\n    function testMultipleSlashings() public {\n        (IHelloWorldServiceManager.Task memory newTask, uint32 taskIndex) =\n            createTask(\"TestMultipleSlashings\");\n\n        Operator[] memory operatorsMem = getOperators(3);\n\n        uint32 maxResponseIntervalBlocks =\n            HelloWorldServiceManager(address(sm)).MAX_RESPONSE_INTERVAL_BLOCKS();\n        vm.roll(block.number + maxResponseIntervalBlocks + 1);\n\n        slashOperator(newTask, taskIndex, operatorsMem[0].key.addr);\n        slashOperator(newTask, taskIndex, operatorsMem[1].key.addr);\n        slashOperator(newTask, taskIndex, operatorsMem[2].key.addr);\n\n        // TODO: check the operator's balance was reduced\n    }\n}"
  },
  {
    "path": "contracts/test/SetupPaymentsLib.t.sol",
    "summary": "File starts: // SPDX-License-Identifier: UNLICENSED",
    "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../script/utils/SetupDistributionsLib.sol\";\nimport \"../script/utils/CoreDeploymentParsingLib.sol\";\nimport \"../script/utils/HelloWorldDeploymentLib.sol\";\nimport \"@eigenlayer/contracts/interfaces/IRewardsCoordinator.sol\";\nimport \"../src/IHelloWorldServiceManager.sol\";\nimport \"@eigenlayer/contracts/interfaces/IStrategy.sol\";\nimport \"@eigenlayer/contracts/libraries/Merkle.sol\";\nimport \"../script/DeployEigenLayerCore.s.sol\";\nimport \"../script/HelloWorldDeployer.s.sol\";\nimport {StrategyFactory} from \"@eigenlayer/contracts/strategies/StrategyFactory.sol\";\nimport {HelloWorldTaskManagerSetup} from \"test/HelloWorldServiceManager.t.sol\";\nimport {ECDSAServiceManagerBase} from\n    \"@eigenlayer-middleware/src/unaudited/ECDSAServiceManagerBase.sol\";\nimport {\n    IECDSAStakeRegistryTypes,\n    IStrategy\n} from \"@eigenlayer-middleware/src/interfaces/IECDSAStakeRegistry.sol\";\nimport \"@openzeppelin-upgrades/contracts/access/OwnableUpgradeable.sol\";\n\ncontract TestConstants {\n    uint256 constant NUM_PAYMENTS = 8;\n    uint256 constant NUM_TOKEN_EARNINGS = 1;\n    uint256 constant TOKEN_EARNINGS = 100;\n\n    address RECIPIENT = address(1);\n    address EARNER = address(2);\n    uint256 INDEX_TO_PROVE = 0;\n    uint256 NUM_EARNERS = 4;\n}\n\ncontract SetupDistributionsLibTest is Test, TestConstants, HelloWorldTaskManagerSetup {\n    using SetupDistributionsLib for *;\n\n    Vm cheats = Vm(VM_ADDRESS);\n\n    IRewardsCoordinator public rewardsCoordinator;\n    IHelloWorldServiceManager public helloWorldServiceManager;\n    IStrategy public strategy;\n\n    address rewardsInitiator = address(1);\n    address rewardsOwner = address(2);\n\n    function setUp() public virtual override {\n        proxyAdmin = UpgradeableProxyLib.deployProxyAdmin();\n        coreConfigData =\n            CoreDeploymentParsingLib.readDeploymentConfigValues(\"test/mockData/config/core/\", 1337);\n        coreDeployment = CoreDeployLib.deployContracts(proxyAdmin, coreConfigData);\n\n        vm.prank(coreConfigData.strategyManager.initialOwner);\n        StrategyManager(coreDeployment.strategyManager).setStrategyWhitelister(\n            coreDeployment.strategyFactory\n        );\n\n        mockToken = new ERC20Mock();\n\n        strategy = addStrategy(address(mockToken)); // Similar function to HW_SM test using strategy factory\n        quorum.strategies.push(\n            IECDSAStakeRegistryTypes.StrategyParams({strategy: strategy, multiplier: 10_000})\n        );\n\n        helloWorldDeployment = HelloWorldDeploymentLib.deployContracts(\n            proxyAdmin, coreDeployment, quorum, rewardsInitiator, rewardsOwner\n        );\n        labelContracts(coreDeployment, helloWorldDeployment);\n\n        cheats.prank(rewardsOwner);\n        ECDSAServiceManagerBase(helloWorldDeployment.helloWorldServiceManager).setRewardsInitiator(\n            rewardsInitiator\n        );\n\n        rewardsCoordinator = IRewardsCoordinator(coreDeployment.rewardsCoordinator);\n\n        mockToken.mint(address(this), 100_000);\n        mockToken.mint(address(rewardsCoordinator), 100_000);\n        mockToken.mint(rewardsInitiator, 100_000);\n    }\n\n    function testSubmitRoot() public {\n        address[] memory earners = new address[](NUM_EARNERS);\n        for (uint256 i = 0; i < earners.length; i++) {\n            earners[i] = address(1);\n        }\n        uint32 endTimestamp = rewardsCoordinator.currRewardsCalculationEndTimestamp() + 1 weeks;\n        cheats.warp(endTimestamp + 1);\n\n        bytes32[] memory tokenLeaves = SetupDistributionsLib.createTokenLeaves(\n            rewardsCoordinator, NUM_TOKEN_EARNINGS, TOKEN_EARNINGS, address(strategy)\n        );\n        IRewardsCoordinator.EarnerTreeMerkleLeaf[] memory earnerLeaves =\n            SetupDistributionsLib.createEarnerLeaves(earners, tokenLeaves);\n\n        string memory filePath = \"testSubmitRoot.json\";\n\n        cheats.startPrank(rewardsCoordinator.rewardsUpdater());\n        SetupDistributionsLib.submitRoot(\n            rewardsCoordinator, tokenLeaves, earnerLeaves, endTimestamp, NUM_EARNERS, 1, filePath\n        );\n        cheats.stopPrank();\n        vm.removeFile(filePath);\n    }\n\n    function testWriteLeavesToJson() public {\n        bytes32[] memory leaves = new bytes32[](2);\n        leaves[0] = bytes32(uint256(1));\n        leaves[1] = bytes32(uint256(2));\n\n        bytes32[] memory tokenLeaves = new bytes32[](2);\n        tokenLeaves[0] = bytes32(uint256(3));\n        tokenLeaves[1] = bytes32(uint256(4));\n\n        string memory filePath = \"testWriteLeavesToJson.json\";\n\n        SetupDistributionsLib.writeLeavesToJson(leaves, tokenLeaves, filePath);\n\n        assertTrue(vm.exists(filePath), \"JSON file should be created\");\n        vm.removeFile(filePath);\n    }\n\n    function testParseLeavesFromJson() public {\n        string memory filePath = \"test_parse_payments.json\";\n        string memory jsonContent = '{\"leaves\":[\"0x1234\"], \"tokenLeaves\":[\"0x5678\"]}';\n        vm.writeFile(filePath, jsonContent);\n\n        SetupDistributionsLib.PaymentLeaves memory paymentLeaves =\n            SetupDistributionsLib.parseLeavesFromJson(filePath);\n\n        assertEq(paymentLeaves.leaves.length, 1, \"Incorrect number of leaves\");\n        assertEq(paymentLeaves.tokenLeaves.length, 1, \"Incorrect number of token leaves\");\n\n        vm.removeFile(filePath);\n    }\n\n    function testGenerateMerkleProof() public view {\n        SetupDistributionsLib.PaymentLeaves memory paymentLeaves =\n            SetupDistributionsLib.parseLeavesFromJson(\"test/mockData/scratch/payments_test.json\");\n\n        bytes32[] memory leaves = paymentLeaves.leaves;\n        uint256 indexToProve = 0;\n\n        bytes32[] memory proof = new bytes32[](2);\n        proof[0] = leaves[1];\n        proof[1] = keccak256(abi.encodePacked(leaves[2], leaves[3]));\n\n        bytes memory proofBytesConstructed = abi.encodePacked(proof);\n        bytes memory proofBytesCalculated =\n            SetupDistributionsLib.generateMerkleProof(leaves, indexToProve);\n\n        require(\n            keccak256(proofBytesConstructed) == keccak256(proofBytesCalculated),\n            \"Proofs do not match\"\n        );\n\n        bytes32 root = SetupDistributionsLib.merkleizeKeccak(leaves);\n\n        require(\n            Merkle.verifyInclusionKeccak(\n                proofBytesCalculated, root, leaves[indexToProve], indexToProve\n            )\n        );\n    }\n\n    function testProcessClaim() public {\n        emit log_named_address(\"token address\", address(mockToken));\n        string memory filePath = \"testProcessClaim.json\";\n\n        address[] memory earners = new address[](NUM_EARNERS);\n        for (uint256 i = 0; i < earners.length; i++) {\n            earners[i] = address(1);\n        }\n        uint32 endTimestamp = rewardsCoordinator.currRewardsCalculationEndTimestamp() + 1 weeks;\n        cheats.warp(endTimestamp + 1);\n\n        bytes32[] memory tokenLeaves = SetupDistributionsLib.createTokenLeaves(\n            rewardsCoordinator, NUM_TOKEN_EARNINGS, TOKEN_EARNINGS, address(strategy)\n        );\n        IRewardsCoordinator.EarnerTreeMerkleLeaf[] memory earnerLeaves =\n            SetupDistributionsLib.createEarnerLeaves(earners, tokenLeaves);\n\n        cheats.startPrank(rewardsCoordinator.rewardsUpdater());\n        SetupDistributionsLib.submitRoot(\n            rewardsCoordinator, tokenLeaves, earnerLeaves, endTimestamp, NUM_EARNERS, 1, filePath\n        );\n        cheats.stopPrank();\n\n        cheats.warp(block.timestamp + 2 weeks);\n\n        cheats.startPrank(earnerLeaves[INDEX_TO_PROVE].earner, earnerLeaves[INDEX_TO_PROVE].earner);\n        SetupDistributionsLib.processClaim(\n            rewardsCoordinator,\n            filePath,\n            INDEX_TO_PROVE,\n            RECIPIENT,\n            earnerLeaves[INDEX_TO_PROVE],\n            NUM_TOKEN_EARNINGS,\n            address(strategy),\n            uint32(TOKEN_EARNINGS)\n        );\n\n        cheats.stopPrank();\n\n        vm.removeFile(filePath);\n    }\n\n    function testCreateAVSRewardsSubmissions() public {\n        uint256 numPayments = 5;\n        uint256 amountPerPayment = 100;\n        uint32 duration = rewardsCoordinator.MAX_REWARDS_DURATION();\n        uint32 genesisTimestamp = rewardsCoordinator.GENESIS_REWARDS_TIMESTAMP();\n        uint32 startTimestamp = genesisTimestamp + 10 days;\n        cheats.warp(startTimestamp + 1);\n\n        cheats.prank(rewardsInitiator);\n        mockToken.increaseAllowance(\n            helloWorldDeployment.helloWorldServiceManager, amountPerPayment * numPayments\n        );\n\n        cheats.startPrank(rewardsInitiator);\n        SetupDistributionsLib.createAVSRewardsSubmissions(\n            address(helloWorldDeployment.helloWorldServiceManager),\n            address(strategy),\n            numPayments,\n            amountPerPayment,\n            duration,\n            startTimestamp\n        );\n    }\n}"
  },
  {
    "path": "contracts/.env.example",
    "summary": "File starts: PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5e",
    "content": "PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\nHOLESKY_PRIVATE_KEY=\nHOLESKY_RPC_URL=\nETHERSCAN_API_KEY="
  },
  {
    "path": "contracts/.gitignore",
    "summary": "File starts: # Compiler files",
    "content": "# Compiler files\ncache/\nout/\n\n# Ignores development broadcast logs\nbroadcast/*\n\n# Docs\ndocs/\n\n# Dotenv file\n.env\n\n\n# DS_store files\n.DS_Store\nlib/.DS_Store"
  },
  {
    "path": "contracts/foundry.toml",
    "summary": "File starts: [profile.default]",
    "content": "[profile.default]\nsrc = \"src\"\nout = \"out\"\nlibs = [\"lib\"]\nfs_permissions = [{ access = \"read-write\", path = \"./\" }]\nsolc = \"0.8.27\"\noptimizer = true\nvia_ir = true\n\nremappings = [\n    \"@eigenlayer/=lib/eigenlayer-middleware/lib/eigenlayer-contracts/src/\",\n    \"@eigenlayer-scripts/=lib/eigenlayer-middleware/lib/eigenlayer-contracts/script/\",\n    \"@eigenlayer-middleware/=lib/eigenlayer-middleware/\",\n    \"@openzeppelin/=lib/eigenlayer-middleware/lib/openzeppelin-contracts/\",\n    \"@openzeppelin-upgrades/=lib/eigenlayer-middleware/lib/openzeppelin-contracts-upgradeable/\",\n    \"forge-std/=lib/forge-std/src/\",\n]\n\n# Ignore warnings from middleware\nignored_warnings_from = [\"lib/eigenlayer-middleware\"]\n\n[rpc_endpoints]\nmainnet = \"${MAINNET_RPC_URL}\"\nholesky = \"${HOLESKY_RPC_URL}\"\nsepolia = \"${SEPOLIA_RPC_URL}\"\nanvil = \"${ANVIL_RPC_URL}\"\n\n[etherscan]\nmainnet = { key = \"${ETHERSCAN_API_KEY}\" }\nsepolia = { key = \"${ETHERSCAN_API_KEY}\" }\nholesky = { key = \"${ETHERSCAN_API_KEY}\" }\n\n[fmt]\nbracket_spacing = false\nint_types = \"long\"\nline_length = 100\nmultiline_func_header = \"params_first\"\nnumber_underscore = \"thousands\"\nquote_style = \"double\"\ntab_width = 4"
  },
  {
    "path": "docs/FAQ.md",
    "summary": "File starts: FAQ About The Repo",
    "content": "FAQ About The Repo\n\nThe goal is to be a list of random bespoke things that might not be immediately clear and if using an AI tool to ask questions about the repo can be a source for the AI to surface information to the user\n\nTypescript Notes:\n\n- We used ts-node in the repo as a dev dependency and dev commands use ts-node to run the typescript files so that there isn't an intermediate build step that the developer must call in the process to compile the typescript files to javascript and then separately use the output javascript.  This allows us to directly run the typescript files which get compiled on the fly.  We will still use tsc when creating production builds of our code but during development using ts-node has better UX and is more clear for developing\n\nSolidity Notes:\n\n- If you're running into low level errors with transactions being executed by ethers.js ie, code: BAD_DATA or returned with No Data related errors, then one solution to get more verbose errors is to compile and deploy your smart contracts with --revert-strings debug.  This will insert verbose revert strings to catch before a low level revert would happen in an anvil instance."
  },
  {
    "path": "operator/e2e.test.ts",
    "summary": "TypeScript source file.",
    "content": "import { createAnvil, Anvil } from \"@viem/anvil\";\nimport { describe, beforeAll, afterAll, it, expect } from '@jest/globals';\nimport { exec } from 'child_process';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport util from 'util';\nimport { ethers } from \"ethers\";\n⋮----\nasync function loadJsonFile(filePath: string): Promise<any>\nasync function loadDeployments(): Promise<Record<string, any>>"
  },
  {
    "path": "operator/index.ts",
    "summary": "TypeScript source file.",
    "content": "import { ethers } from \"ethers\";\n⋮----\n// Check if the process.env object is empty\n⋮----\n// Setup env variables\n⋮----\n/// TODO: Hack\n⋮----\n// Load core deployment data\n⋮----\nconst delegationManagerAddress = coreDeploymentData.addresses.delegationManager; // todo: reminder to fix the naming of this contract in the deployment file, change to delegationManager\n⋮----\n// Load ABIs\n⋮----\n// Initialize contract objects from ABIs\n⋮----\nconst signAndRespondToTask = async (taskIndex: number, taskCreatedBlock: number, taskName: string) =>\nconst registerOperator = async () =>\n⋮----\n// Registers as an Operator in EigenLayer.\n⋮----\n\"0x0000000000000000000000000000000000000000\", // initDelegationApprover\n0, // allocationDelay\n\"\", // metadataURI\n⋮----\nconst expiry = Math.floor(Date.now() / 1000) + 3600; // Example expiry, 1 hour from now\n// Define the output structure\n⋮----\n// Calculate the digest hash, which is a unique value representing the operator, avs, unique value (salt) and expiration date.\n⋮----\n// Sign the digest hash with the operator's private key\n⋮----\n// Encode the signature in the required format\n⋮----\n// Register Operator to AVS\n// Per release here: https://github.com/Layr-Labs/eigenlayer-middleware/blob/v0.2.1-mainnet-rewards/src/unaudited/ECDSAStakeRegistry.sol#L49\n⋮----\nconst monitorNewTasks = async () =>\n⋮----\n//console.log(`Creating new task \"EigenWorld\"`);\n//await helloWorldServiceManager.createNewTask(\"EigenWorld\");\n⋮----\nconst main = async () =>"
  },
  {
    "path": "scripts/rewards-script-check.sh",
    "summary": "File starts: #!/bin/bash",
    "content": "#!/bin/bash\n# This flags makes the script exit if any command has a non-zero exit status, or \n# if tries to use a non defined variable\nset -e -o nounset\n# Execute anvil in background\nanvil -q &\n# Deploy contracts\nmake deploy-eigenlayer-contracts\nmake deploy-helloworld-contracts\n# Check that at first, claimer balance in token is zero\ninitialBalance=$(make claimer-account-token-balance | tail -n1 | tr -d '[:space:]')\necho \"Initial balance: '$initialBalance'\"\nif [ \"$initialBalance\" -ne 0 ]; then\n    echo \"claimer balance in token should be zero\"\n    exit 2\nfi\n# Create and claim normal distribution root\necho \"Creating distribution root:\"\nmake create-avs-distributions-root\necho \"Claiming distribution root:\"\nmake claim-distributions\n# Check that after claim, claimer balance in token is 100\nbalanceAfterClaim=$(make claimer-account-token-balance | tail -n1 | tr -d '[:space:]')\necho \"Balance after first claim: '$balanceAfterClaim'\"\nif [ \"$balanceAfterClaim\" -ne 100 ]; then\n    echo \"After first claim, claimer balance in token should be 100\"\n    exit 3\nfi\n# Create and claim operator directed distribution root\necho \"Creating operator directed distribution root:\"\nmake create-operator-directed-distributions-root\necho \"Claiming distribution root:\"\nmake claim-distributions\n# Check that after another claim, claimer balance in token is 200\nbalanceAfterClaim=$(make claimer-account-token-balance | tail -n1 | tr -d '[:space:]')\necho \"Balance after second claim: '$balanceAfterClaim'\"\nif [ \"$balanceAfterClaim\" -ne 200 ]; then\n    echo \"After second claim, claimer balance in token should be 200\"\n    exit 3\nfi\n# Kill anvil executing in background\nkill $(pgrep anvil)"
  },
  {
    "path": "utils/abis.js",
    "summary": "JavaScript source file.",
    "content": "const artifactsDir = path.join(contractsDir, 'out');\n⋮----\nif (!fs.existsSync(abiDir)) {\nfs.mkdirSync(abiDir);\n⋮----\nfunction checkArtifactsDirectory() {\nif (!fs.existsSync(artifactsDir)) {\nconsole.error(`The artifacts directory '${artifactsDir}' does not exist.`);\nconsole.log('Please compile your contracts first using \"forge build\"');\nprocess.exit(1);\n⋮----\nconst files = fs.readdirSync(artifactsDir);\n⋮----\nconsole.error(`The artifacts directory '${artifactsDir}' is empty.`);\nconsole.log('Please compile your contracts first using \"forge build\" or confirm the path is correct.');\n⋮----\nfunction extractAbi(contractName) {\nconst outputPath = path.join(artifactsDir, `${contractName}.sol`, `${contractName}.json`);\nconst abiOutputPath = path.join(abiDir, `${contractName}.json`);\n⋮----\nconst contractData = JSON.parse(fs.readFileSync(outputPath, 'utf8'));\nconst abi = JSON.stringify(contractData.abi, null, 2);\nfs.writeFileSync(abiOutputPath, abi);\nconsole.log(`Extracted ABI for ${contractName}`);\n⋮----\nconsole.error(`Error extracting ABI for ${contractName}:`, error.message);\n⋮----\ncheckArtifactsDirectory();\n⋮----\nextractAbi(contractName);\n⋮----\nconsole.log('ABI extraction complete. Check the \"abis\" directory for the output.');"
  },
  {
    "path": ".dockerignore",
    "summary": "File starts: node_modules/",
    "content": "node_modules/\ntarget/"
  },
  {
    "path": ".env.example",
    "summary": "File starts: PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5e",
    "content": "PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\nOPERATOR_RESPONSE_PERCENTAGE=80\nRPC_URL=http://localhost:8545\nWS_URL=ws://localhost:8545"
  },
  {
    "path": ".gitignore",
    "summary": "File starts: # Ignore node_modules directory",
    "content": "# Ignore node_modules directory\nnode_modules/\n\n# Ignore built output\ndist/\n\n# Ignore environment-specific files\n.env\n\n# Ignore nixos related environment-specific files\n.envrc\n.cargo/\n.direnv/\n\n# Ignore editor-specific files\n.vscode/\n.idea/\n\n# Ignore TypeScript build artifacts\ndist/**/*.js\ndist/*.js.map\ndist/*.d.ts\n\n# Ignore local anvil state\n# utils/anvil/*.json\ncontracts/anvil/state.json\n\noldUtils\n\ntarget/\ndebug/\n\nyarn.lock\ncontracts/deployments/\n\n**/.DS_Store"
  },
  {
    "path": ".gitmodules",
    "summary": "File starts: [submodule \"contracts/lib/forge-std\"]",
    "content": "[submodule \"contracts/lib/forge-std\"]\n\tpath = contracts/lib/forge-std\n\turl = https://github.com/foundry-rs/forge-std\n[submodule \"contracts/lib/eigenlayer-middleware\"]\n\tpath = contracts/lib/eigenlayer-middleware\n\turl = https://github.com/Layr-Labs/eigenlayer-middleware"
  },
  {
    "path": "Dockerfile",
    "summary": "File starts: FROM node:22",
    "content": "FROM node:22\n\nWORKDIR /app\n\nCOPY package.json ./\nCOPY tsconfig.json ./\nRUN npm install\n\nCOPY . .\n\nCMD [\"npm\", \"start\"]"
  },
  {
    "path": "jest.config.ts",
    "summary": "TypeScript source file.",
    "content": "import type { Config } from '@jest/types';\n⋮----\ntestTimeout: 60000, // 60 seconds\nmaxWorkers: 1, // Run tests sequentially"
  },
  {
    "path": "LICENSE",
    "summary": "File starts: Copyright 2024 Eigen Labs, Inc.",
    "content": "Copyright 2024 Eigen Labs, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "path": "Makefile",
    "summary": "File starts: ############################# HELP MESSAGE #################",
    "content": "############################# HELP MESSAGE #############################\n# Make sure the help command stays first, so that it's printed by default when `make` is called without arguments\n.PHONY: help tests\nhelp:\n\t@grep -E '^[a-zA-Z0-9_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = \":.*?## \"}; {printf \"\\033[36m%-30s\\033[0m %s\\n\", $$1, $$2}'\n\n\nRUST_BINDINGS_PATH:=operator/rust/crates/utils/src/bindings\n\n-----------------------------: ##\n\n___ANVIL_STATE___: ##\nbuild-anvil-state-with-deployed-contracts: ## builds anvil state with deployed contracts and generates a state\n\t@chmod +x ./contracts/anvil/build-state.sh\n\t./contracts/anvil/build-state.sh\n\n___CONTRACTS___: ##\n\nbuild-contracts: ## builds all contracts\n\tcd contracts && forge build\n\ndeploy-eigenlayer-contracts:\n\t@chmod +x ./contracts/anvil/deploy-el.sh\n\t./contracts/anvil/deploy-el.sh\n\ndeploy-helloworld-contracts:\n\t@chmod +x ./contracts/anvil/deploy-helloworld.sh\n\t./contracts/anvil/deploy-helloworld.sh\n\ngenerate-bindings:\n\tcd contracts && forge build --force --skip test --skip script\n\trm -rf ${RUST_BINDINGS_PATH}\n\tforge bind --alloy --skip-build --overwrite --module \\\n\t\t--root contracts/  \\\n\t\t--bindings-path ${RUST_BINDINGS_PATH} \\\n\t\t--select '^ECDSAStakeRegistry$$' --select '^HelloWorldServiceManager$$'\n\n__CLI__: ##\n\nsend-fund: ## sends fund to the operator saved in tests/keys/test.ecdsa.key.json\n\tcast send 0x860B6912C2d0337ef05bbC89b0C2CB6CbAEAB4A5 --value 10ether \\\n\t\t--private-key \n\n-----------------------------: ##\n# We pipe all zapper logs through https://github.com/maoueh/zap-pretty so make sure to install it\n# TODO: piping to zap-pretty only works when zapper environment is set to production, unsure why\n____OFFCHAIN_SOFTWARE___:\nstart-operator: ## start operator (part of quickstart)\n\ttsc && node dist/index.js\n\nspam-tasks: ## start tasks spamming (part of quickstart)\n\ttsc && node dist/createNewTasks.js\n\n-----------------------------: ##\n_____HELPER_____: ##\ntests-contract: ## runs all forge tests\n\tcd contracts && forge test\n\n___RUST_OFFCHAIN_SOFTWARE___:\nstart-rust-operator: ## start operator (part of quickstart) \n\tcargo run --bin start_operator\n\nspam-rust-tasks:  ## start tasks spamming (part of quickstart)\n\tcargo run --bin spam_tasks\n\nstart-rust-challenger: ## start challenger (part of quickstart)\n\tcargo run --bin challenger\n\n__REWARDS__: ##\n\nTOKEN_ADDRESS=$(shell jq -r '.addresses.token' contracts/deployments/hello-world/31337.json)\n\ncreate-avs-distributions-root:\n\tnpm run create-distributions-root\n\nclaim-distributions:\n\tnpm run claim-distributions\n\ncreate-operator-directed-distributions-root:\n\tnpm run create-operator-directed-distributions-root\n\nget-deployed-token-address:\n\t@echo \"Deployed token Address: $(TOKEN_ADDRESS)\"\n\nclaimer-account-token-balance:\n\tcast balance --erc20 $(TOKEN_ADDRESS) 0x0000000000000000000000000000000000000001"
  },
  {
    "path": "package.json",
    "summary": "JSON file with keys: name, version, main, scripts, dependencies, devDependencies.",
    "content": "{\n  \"name\": \"hello-world-avs\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start:operator\": \"ts-node operator/index.ts\",\n    \"start:traffic\": \"ts-node operator/createNewTasks.ts\",\n    \"start:anvil\": \"anvil\",\n    \"deploy:core\": \"cd contracts && forge script script/DeployEigenLayerCore.s.sol --rpc-url http://localhost:8545 --broadcast --optimize --optimizer-runs 200 --via-ir\",\n    \"deploy:hello-world\": \"cd contracts && forge script script/HelloWorldDeployer.s.sol --rpc-url http://localhost:8545 --broadcast --optimize --optimizer-runs 200 --via-ir\",\n    \"deploy:core-debug\": \"cd contracts && forge script script/DeployEigenLayerCore.s.sol --rpc-url http://localhost:8545 --broadcast --revert-strings debug --optimize --optimizer-runs 200 --via-ir\",\n    \"deploy:hello-world-debug\": \"cd contracts && forge script script/HelloWorldDeployer.s.sol --rpc-url http://localhost:8545 --broadcast --revert-strings debug\",\n    \"create-distributions-root\": \"cd contracts && forge script script/SetupDistributions.s.sol --rpc-url http://localhost:8545 --broadcast -v --sender 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\",\n    \"claim-distributions\": \"cd contracts && forge script script/SetupDistributions.s.sol --rpc-url http://localhost:8545 --broadcast --sig \\\"executeProcessClaim()\\\" -v --sender 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\",\n    \"create-operator-directed-distributions-root\": \"cd contracts && forge script script/SetupDistributions.s.sol --rpc-url http://localhost:8545 --broadcast --sig \\\"runOperatorDirected()\\\" -v --sender 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\",\n    \"build\": \"tsc\",\n    \"build:forge\": \"cd contracts && forge build\",\n    \"extract:abis\": \"node utils/abis.js\",\n    \"test\": \"NODE_OPTIONS=\\\"$NODE_OPTIONS --experimental-vm-modules\\\" npx jest\"\n  },\n  \"dependencies\": {\n    \"dotenv\": \"^10.0.0\",\n    \"ethers\": \"^6.13.2\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"^29.5.13\",\n    \"@types/node\": \"^20.12.12\",\n    \"@viem/anvil\": \"^0.0.10\",\n    \"jest\": \"^29.7.0\",\n    \"ts-jest\": \"^29.2.5\",\n    \"ts-node\": \"^10.9.2\",\n    \"typescript\": \"^5.4.5\"\n  }\n}"
  },
  {
    "path": "README.md",
    "summary": "File starts: # Hello World AVS",
    "content": "# Hello World AVS\n\nWelcome to the Hello World AVS. This project shows you the simplest functionality you can expect from an AVS. It will give you a concrete understanding of the basic components. For new users, please find [this video walkthrough](https://drive.google.com/file/d/1P6uA6kYWCbpeorTjADuoTlQ-q8uqwPZf/view?usp=sharing) of the hello world AVS repository.\n\n## Architecture\n\n![hello-world-png](./assets/hello-world-diagramv2.png)\n\n### AVS User Flow\n\n1) AVS consumer requests a \"Hello World\" message to be generated and signed.\n2) HelloWorld contract receives the request and emits a NewTaskCreated event for the request.\n3) All Operators who are registered to the AVS and has staked, delegated assets takes this request. Operator generates the requested message, hashes it, and signs the hash with their private key.\n4) Each Operator submits their signed hash back to the HelloWorld AVS contract.\n5) If the Operator is registered to the AVS and has the minimum needed stake, the submission is accepted.\n\nThat's it. This simple flow highlights some of the core mechanics of how AVSs work.\n\n\n## Local Devnet Deployment\n\nThe following instructions explain how to manually deploy the AVS from scratch including EigenLayer and AVS specific contracts using Foundry (forge) to a local anvil chain, and start Typescript Operator application and tasks.\n\n## Development Environment\n\nThis section describes the tooling required for local development.\n\nInstall dependencies:\n\n- [Node](https://nodejs.org/en/download/)\n- [Typescript](https://www.typescriptlang.org/download)\n- [ts-node](https://www.npmjs.com/package/ts-node)\n- [tcs](https://www.npmjs.com/package/tcs#installation)\n- [npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)\n- [Foundry](https://getfoundry.sh/)\n- [ethers](https://www.npmjs.com/package/ethers)\n\n\n\n## Quick start (TypeScript)\n\n### Start Anvil Chain\n\nIn terminal window #1, execute the following commands:\n\n```sh\n\n# Install npm packages\nnpm install\n\n# Start local anvil chain\nnpm run start:anvil\n```\n\n### Deploy Contracts and Start Operator\n\nOpen a separate terminal window #2, execute the following commands\n\n```sh\n# Setup .env file\ncp .env.example .env\ncp contracts/.env.example contracts/.env\n\n# Updates dependencies if necessary and builds the contracts \nnpm run build:forge\n\n# Deploy the EigenLayer contracts\nnpm run deploy:core\n\n# Deploy the Hello World AVS contracts\nnpm run deploy:hello-world\n\n# (Optional) Update ABIs\nnpm run extract:abis\n\n# Start the Operator application\nnpm run start:operator\n```\n\n### Create Hello-World-AVS Tasks\n\nOpen a separate terminal window #3, execute the following commands\n\n```sh\n# Start the createNewTasks application \nnpm run start:traffic\n```\n\n### Create and Claim Distribution\n\nIn a terminal, start a new instance of anvil and deploy the core and avs contracts\n\n```sh\n# Start anvil\nnpm run start:anvil\n# Deploy the EigenLayer contracts\nnpm run deploy:core\n\n# Deploy the Hello World AVS contracts\nnpm run deploy:hello-world\n\n```\n\nIn another terminal, run:\n\n```sh\n# Create distribution roots\nnpm run create-distributions-root\n\n# Claim created distribution\nnpm run claim-distributions\n```\n\nTo run operator directed rewards distribution, run:\n\n```sh\n#Create distribution roots\nnpm run create-operator-directed-distributions-root\n\n# Claim created rewards distribution\nnpm run claim-distributions\n```\n\n\n\n## Help and Support\n\nFor help and support deploying and modifying this repo for your AVS, please:\n\n1. Open a ticket via the intercom link at [support.eigenlayer.xyz](https://support.eigenlayer.xyz).\n2. Include the necessary troubleshooting information for your environment:\n  * Local anvil testing:\n    * Redeploy your local test using `--revert-strings debug` flag via the following commands and retest: `npm run deploy:core-debug && npm run deploy:hello-world-debug`\n    * Include the full stacktrace from your error as a .txt file attachment.\n    * Create a minimal repo that demonstrates the behavior (fork or otherwise)\n    * Steps require to reproduce issue (compile and cause the error)\n  * Holesky testing:\n    * Ensure contracts are verified on Holesky. Eg `forge verify-contract --chain-id 17000 --num-of-optimizations 200 src/YourContract.sol:YourContract YOUR_CONTRACT_ADDRESS`\n    * Send us your transaction hash where your contract is failing. We will use Tenderly to debug (adjust gas limit) and/or cast to re-run the transaction (eg `cast call --trace \"trace_replayTransaction(0xTransactionHash)\"`).\n\n## Contact Us\n\nIf you're planning to build an AVS and would like to speak with a member of the EigenLayer DevRel team to discuss your ideas or architecture, please fill out this form and we'll be in touch shortly: [EigenLayer AVS Intro Call](https://share.hsforms.com/1BksFoaPjSk2l3pQ5J4EVCAein6l)\n\n## Disclaimers\n\n- This repo is meant currently intended for _local anvil development testing_. Holesky deployment support will be added shortly.\n- Users who wish to build an AVS for Production purposes will want to migrate from the `ECDSAServiceManagerBase` implementation in `HelloWorldServiceManager.sol` to a BLS style architecture using [RegistryCoordinator](https://github.com/Layr-Labs/eigenlayer-middleware/blob/dev/docs/RegistryCoordinator.md).\n\n## Appendix (Future Capabilities In Progress)\n\n### Adding a New Strategy\n\n### Potential Enhancements to the AVS (for learning purposes)\n\nThe architecture can be further enhanced via:\n\n- the nature of the request is more sophisticated than generating a constant string\n- the operators might need to coordinate with each other\n- the type of signature is different based on the constraints of the service\n- the type and amount of security used to secure the AVS"
  },
  {
    "path": "tsconfig.json",
    "summary": "JSON file.",
    "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES6\",\n    \"module\": \"commonjs\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true\n  },\n  \"exclude\": [\n    \"node_modules\",\n    \"contracts\"\n  ]\n}\n\n\n\n====\nEnd of Codebase\n===="
  }
]