
================
File: abis/ECDSAStakeRegistry.json
================
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_delegationManager",
        "type": "address",
        "internalType": "contract IDelegationManager"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "deregisterOperator",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getLastCheckpointOperatorWeight",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLastCheckpointThresholdWeight",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLastCheckpointThresholdWeightAtBlock",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLastCheckpointTotalWeight",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLastCheckpointTotalWeightAtBlock",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLatestOperatorSigningKey",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorSigningKeyAtBlock",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorWeight",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorWeightAtBlock",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "blockNumber",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "_serviceManager",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "thresholdWeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "quorum",
        "type": "tuple",
        "internalType": "struct IECDSAStakeRegistryTypes.Quorum",
        "components": [
          {
            "name": "strategies",
            "type": "tuple[]",
            "internalType": "struct IECDSAStakeRegistryTypes.StrategyParams[]",
            "components": [
              {
                "name": "strategy",
                "type": "address",
                "internalType": "contract IStrategy"
              },
              {
                "name": "multiplier",
                "type": "uint96",
                "internalType": "uint96"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isValidSignature",
    "inputs": [
      {
        "name": "digest",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "_signatureData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "minimumWeight",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "operatorRegistered",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "quorum",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct IECDSAStakeRegistryTypes.Quorum",
        "components": [
          {
            "name": "strategies",
            "type": "tuple[]",
            "internalType": "struct IECDSAStakeRegistryTypes.StrategyParams[]",
            "components": [
              {
                "name": "strategy",
                "type": "address",
                "internalType": "contract IStrategy"
              },
              {
                "name": "multiplier",
                "type": "uint96",
                "internalType": "uint96"
              }
            ]
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "registerOperatorWithSignature",
    "inputs": [
      {
        "name": "operatorSignature",
        "type": "tuple",
        "internalType": "struct ISignatureUtils.SignatureWithSaltAndExpiry",
        "components": [
          {
            "name": "signature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "salt",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "expiry",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "signingKey",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateMinimumWeight",
    "inputs": [
      {
        "name": "newMinimumWeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "operators",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateOperatorSigningKey",
    "inputs": [
      {
        "name": "newSigningKey",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateOperators",
    "inputs": [
      {
        "name": "operators",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateOperatorsForQuorum",
    "inputs": [
      {
        "name": "operatorsPerQuorum",
        "type": "address[][]",
        "internalType": "address[][]"
      },
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateQuorumConfig",
    "inputs": [
      {
        "name": "quorum",
        "type": "tuple",
        "internalType": "struct IECDSAStakeRegistryTypes.Quorum",
        "components": [
          {
            "name": "strategies",
            "type": "tuple[]",
            "internalType": "struct IECDSAStakeRegistryTypes.StrategyParams[]",
            "components": [
              {
                "name": "strategy",
                "type": "address",
                "internalType": "contract IStrategy"
              },
              {
                "name": "multiplier",
                "type": "uint96",
                "internalType": "uint96"
              }
            ]
          }
        ]
      },
      {
        "name": "operators",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateStakeThreshold",
    "inputs": [
      {
        "name": "thresholdWeight",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "MinimumWeightUpdated",
    "inputs": [
      {
        "name": "previous",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "current",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorDeregistered",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "avs",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorRegistered",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "avs",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorWeightUpdated",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "oldWeight",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newWeight",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "QuorumUpdated",
    "inputs": [
      {
        "name": "previous",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct IECDSAStakeRegistryTypes.Quorum",
        "components": [
          {
            "name": "strategies",
            "type": "tuple[]",
            "internalType": "struct IECDSAStakeRegistryTypes.StrategyParams[]",
            "components": [
              {
                "name": "strategy",
                "type": "address",
                "internalType": "contract IStrategy"
              },
              {
                "name": "multiplier",
                "type": "uint96",
                "internalType": "uint96"
              }
            ]
          }
        ]
      },
      {
        "name": "current",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct IECDSAStakeRegistryTypes.Quorum",
        "components": [
          {
            "name": "strategies",
            "type": "tuple[]",
            "internalType": "struct IECDSAStakeRegistryTypes.StrategyParams[]",
            "components": [
              {
                "name": "strategy",
                "type": "address",
                "internalType": "contract IStrategy"
              },
              {
                "name": "multiplier",
                "type": "uint96",
                "internalType": "uint96"
              }
            ]
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SigningKeyUpdate",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "updateBlock",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "newSigningKey",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "oldSigningKey",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ThresholdWeightUpdated",
    "inputs": [
      {
        "name": "thresholdWeight",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TotalWeightUpdated",
    "inputs": [
      {
        "name": "oldTotalWeight",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newTotalWeight",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdateMinimumWeight",
    "inputs": [
      {
        "name": "oldMinimumWeight",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newMinimumWeight",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "InsufficientSignedStake",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientWeight",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidLength",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidQuorum",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidReferenceBlock",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidSignedWeight",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidThreshold",
    "inputs": []
  },
  {
    "type": "error",
    "name": "LengthMismatch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "MustUpdateAllOperators",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotSorted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OperatorAlreadyRegistered",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OperatorNotRegistered",
    "inputs": []
  }
]

================
File: abis/HelloWorldServiceManager.json
================
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_avsDirectory",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_stakeRegistry",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_rewardsCoordinator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_delegationManager",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_allocationManager",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addPendingAdmin",
    "inputs": [
      {
        "name": "admin",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allTaskHashes",
    "inputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allTaskResponses",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allocationManager",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "avsDirectory",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "createAVSRewardsSubmission",
    "inputs": [
      {
        "name": "rewardsSubmissions",
        "type": "tuple[]",
        "internalType": "struct IRewardsCoordinatorTypes.RewardsSubmission[]",
        "components": [
          {
            "name": "strategiesAndMultipliers",
            "type": "tuple[]",
            "internalType": "struct IRewardsCoordinatorTypes.StrategyAndMultiplier[]",
            "components": [
              {
                "name": "strategy",
                "type": "address",
                "internalType": "contract IStrategy"
              },
              {
                "name": "multiplier",
                "type": "uint96",
                "internalType": "uint96"
              }
            ]
          },
          {
            "name": "token",
            "type": "address",
            "internalType": "contract IERC20"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "startTimestamp",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "duration",
            "type": "uint32",
            "internalType": "uint32"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createNewTask",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct IHelloWorldServiceManager.Task",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "taskCreatedBlock",
            "type": "uint32",
            "internalType": "uint32"
          }
        ]
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createOperatorDirectedAVSRewardsSubmission",
    "inputs": [
      {
        "name": "operatorDirectedRewardsSubmissions",
        "type": "tuple[]",
        "internalType": "struct IRewardsCoordinatorTypes.OperatorDirectedRewardsSubmission[]",
        "components": [
          {
            "name": "strategiesAndMultipliers",
            "type": "tuple[]",
            "internalType": "struct IRewardsCoordinatorTypes.StrategyAndMultiplier[]",
            "components": [
              {
                "name": "strategy",
                "type": "address",
                "internalType": "contract IStrategy"
              },
              {
                "name": "multiplier",
                "type": "uint96",
                "internalType": "uint96"
              }
            ]
          },
          {
            "name": "token",
            "type": "address",
            "internalType": "contract IERC20"
          },
          {
            "name": "operatorRewards",
            "type": "tuple[]",
            "internalType": "struct IRewardsCoordinatorTypes.OperatorReward[]",
            "components": [
              {
                "name": "operator",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "startTimestamp",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "duration",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "description",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "deregisterOperatorFromAVS",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "deregisterOperatorFromOperatorSets",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "operatorSetIds",
        "type": "uint32[]",
        "internalType": "uint32[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getOperatorRestakedStrategies",
    "inputs": [
      {
        "name": "_operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRestakeableStrategies",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "initialOwner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_rewardsInitiator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "latestTaskNum",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "registerOperatorToAVS",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "operatorSignature",
        "type": "tuple",
        "internalType": "struct ISignatureUtils.SignatureWithSaltAndExpiry",
        "components": [
          {
            "name": "signature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "salt",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "expiry",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeAdmin",
    "inputs": [
      {
        "name": "admin",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeAppointee",
    "inputs": [
      {
        "name": "appointee",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "selector",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removePendingAdmin",
    "inputs": [
      {
        "name": "pendingAdmin",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "respondToTask",
    "inputs": [
      {
        "name": "task",
        "type": "tuple",
        "internalType": "struct IHelloWorldServiceManager.Task",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "taskCreatedBlock",
            "type": "uint32",
            "internalType": "uint32"
          }
        ]
      },
      {
        "name": "referenceTaskIndex",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "rewardsInitiator",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setAVSRegistrar",
    "inputs": [
      {
        "name": "registrar",
        "type": "address",
        "internalType": "contract IAVSRegistrar"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setAppointee",
    "inputs": [
      {
        "name": "appointee",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "selector",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setClaimerFor",
    "inputs": [
      {
        "name": "claimer",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setRewardsInitiator",
    "inputs": [
      {
        "name": "newRewardsInitiator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stakeRegistry",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateAVSMetadataURI",
    "inputs": [
      {
        "name": "_metadataURI",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NewTaskCreated",
    "inputs": [
      {
        "name": "taskIndex",
        "type": "uint32",
        "indexed": true,
        "internalType": "uint32"
      },
      {
        "name": "task",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct IHelloWorldServiceManager.Task",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "taskCreatedBlock",
            "type": "uint32",
            "internalType": "uint32"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RewardsInitiatorUpdated",
    "inputs": [
      {
        "name": "prevRewardsInitiator",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "newRewardsInitiator",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TaskResponded",
    "inputs": [
      {
        "name": "taskIndex",
        "type": "uint32",
        "indexed": true,
        "internalType": "uint32"
      },
      {
        "name": "task",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct IHelloWorldServiceManager.Task",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "taskCreatedBlock",
            "type": "uint32",
            "internalType": "uint32"
          }
        ]
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "DelayPeriodNotPassed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OnlyRegistryCoordinator",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OnlyRewardsInitiator",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OnlyStakeRegistry",
    "inputs": []
  }
]

================
File: abis/IAVSDirectory.json
================
[
  {
    "type": "function",
    "name": "OPERATOR_AVS_REGISTRATION_TYPEHASH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "OPERATOR_SET_REGISTRATION_TYPEHASH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "calculateOperatorAVSRegistrationDigestHash",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "avs",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "cancelSalt",
    "inputs": [
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "deregisterOperatorFromAVS",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "initialOwner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "initialPausedStatus",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "operatorSaltIsSpent",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "registerOperatorToAVS",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "operatorSignature",
        "type": "tuple",
        "internalType": "struct ISignatureUtils.SignatureWithSaltAndExpiry",
        "components": [
          {
            "name": "signature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "salt",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "expiry",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateAVSMetadataURI",
    "inputs": [
      {
        "name": "metadataURI",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "AVSMetadataURIUpdated",
    "inputs": [
      {
        "name": "avs",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "metadataURI",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorAVSRegistrationStatusUpdated",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "avs",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "status",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum IAVSDirectoryTypes.OperatorAVSRegistrationStatus"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "InvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OperatorAlreadyRegisteredToAVS",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OperatorNotRegisteredToAVS",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OperatorNotRegisteredToEigenLayer",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SaltSpent",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SignatureExpired",
    "inputs": []
  }
]

================
File: abis/IDelegationManager.json
================
[
  {
    "type": "function",
    "name": "DELEGATION_APPROVAL_TYPEHASH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "beaconChainETHStrategy",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IStrategy"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "burnOperatorShares",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "strategy",
        "type": "address",
        "internalType": "contract IStrategy"
      },
      {
        "name": "prevMaxMagnitude",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "newMaxMagnitude",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "calculateDelegationApprovalDigestHash",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_delegationApprover",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "approverSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "calculateWithdrawalRoot",
    "inputs": [
      {
        "name": "withdrawal",
        "type": "tuple",
        "internalType": "struct IDelegationManagerTypes.Withdrawal",
        "components": [
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "delegatedTo",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "withdrawer",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "startBlock",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "strategies",
            "type": "address[]",
            "internalType": "contract IStrategy[]"
          },
          {
            "name": "scaledShares",
            "type": "uint256[]",
            "internalType": "uint256[]"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "completeQueuedWithdrawal",
    "inputs": [
      {
        "name": "withdrawal",
        "type": "tuple",
        "internalType": "struct IDelegationManagerTypes.Withdrawal",
        "components": [
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "delegatedTo",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "withdrawer",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "startBlock",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "strategies",
            "type": "address[]",
            "internalType": "contract IStrategy[]"
          },
          {
            "name": "scaledShares",
            "type": "uint256[]",
            "internalType": "uint256[]"
          }
        ]
      },
      {
        "name": "tokens",
        "type": "address[]",
        "internalType": "contract IERC20[]"
      },
      {
        "name": "receiveAsTokens",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "completeQueuedWithdrawals",
    "inputs": [
      {
        "name": "withdrawals",
        "type": "tuple[]",
        "internalType": "struct IDelegationManagerTypes.Withdrawal[]",
        "components": [
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "delegatedTo",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "withdrawer",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "startBlock",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "strategies",
            "type": "address[]",
            "internalType": "contract IStrategy[]"
          },
          {
            "name": "scaledShares",
            "type": "uint256[]",
            "internalType": "uint256[]"
          }
        ]
      },
      {
        "name": "tokens",
        "type": "address[][]",
        "internalType": "contract IERC20[][]"
      },
      {
        "name": "receiveAsTokens",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "convertToDepositShares",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "strategies",
        "type": "address[]",
        "internalType": "contract IStrategy[]"
      },
      {
        "name": "withdrawableShares",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "cumulativeWithdrawalsQueued",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "decreaseDelegatedShares",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "curDepositShares",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "beaconChainSlashingFactorDecrease",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegateTo",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "approverSignatureAndExpiry",
        "type": "tuple",
        "internalType": "struct ISignatureUtils.SignatureWithExpiry",
        "components": [
          {
            "name": "signature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "expiry",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "approverSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegatedTo",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "delegationApprover",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "delegationApproverSaltIsSpent",
    "inputs": [
      {
        "name": "_delegationApprover",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "depositScalingFactor",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "strategy",
        "type": "address",
        "internalType": "contract IStrategy"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDepositedShares",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "contract IStrategy[]"
      },
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorShares",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "strategies",
        "type": "address[]",
        "internalType": "contract IStrategy[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorsShares",
    "inputs": [
      {
        "name": "operators",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "strategies",
        "type": "address[]",
        "internalType": "contract IStrategy[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256[][]",
        "internalType": "uint256[][]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getQueuedWithdrawal",
    "inputs": [
      {
        "name": "withdrawalRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct IDelegationManagerTypes.Withdrawal",
        "components": [
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "delegatedTo",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "withdrawer",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "startBlock",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "strategies",
            "type": "address[]",
            "internalType": "contract IStrategy[]"
          },
          {
            "name": "scaledShares",
            "type": "uint256[]",
            "internalType": "uint256[]"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getQueuedWithdrawalRoots",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getQueuedWithdrawals",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "withdrawals",
        "type": "tuple[]",
        "internalType": "struct IDelegationManagerTypes.Withdrawal[]",
        "components": [
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "delegatedTo",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "withdrawer",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "startBlock",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "strategies",
            "type": "address[]",
            "internalType": "contract IStrategy[]"
          },
          {
            "name": "scaledShares",
            "type": "uint256[]",
            "internalType": "uint256[]"
          }
        ]
      },
      {
        "name": "shares",
        "type": "uint256[][]",
        "internalType": "uint256[][]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSlashableSharesInQueue",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "strategy",
        "type": "address",
        "internalType": "contract IStrategy"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getWithdrawableShares",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "strategies",
        "type": "address[]",
        "internalType": "contract IStrategy[]"
      }
    ],
    "outputs": [
      {
        "name": "withdrawableShares",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "depositShares",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "increaseDelegatedShares",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "strategy",
        "type": "address",
        "internalType": "contract IStrategy"
      },
      {
        "name": "prevDepositShares",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "addedShares",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "initialOwner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "initialPausedStatus",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isDelegated",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isOperator",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "minWithdrawalDelayBlocks",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "modifyOperatorDetails",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "newDelegationApprover",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "queueWithdrawals",
    "inputs": [
      {
        "name": "params",
        "type": "tuple[]",
        "internalType": "struct IDelegationManagerTypes.QueuedWithdrawalParams[]",
        "components": [
          {
            "name": "strategies",
            "type": "address[]",
            "internalType": "contract IStrategy[]"
          },
          {
            "name": "depositShares",
            "type": "uint256[]",
            "internalType": "uint256[]"
          },
          {
            "name": "__deprecated_withdrawer",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "redelegate",
    "inputs": [
      {
        "name": "newOperator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "newOperatorApproverSig",
        "type": "tuple",
        "internalType": "struct ISignatureUtils.SignatureWithExpiry",
        "components": [
          {
            "name": "signature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "expiry",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "approverSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "withdrawalRoots",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "registerAsOperator",
    "inputs": [
      {
        "name": "initDelegationApprover",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "allocationDelay",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "metadataURI",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "undelegate",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "withdrawalRoots",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateOperatorMetadataURI",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "metadataURI",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "DelegationApproverUpdated",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newDelegationApprover",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DepositScalingFactorUpdated",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "strategy",
        "type": "address",
        "indexed": false,
        "internalType": "contract IStrategy"
      },
      {
        "name": "newDepositScalingFactor",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorMetadataURIUpdated",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "metadataURI",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorRegistered",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "delegationApprover",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorSharesBurned",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "strategy",
        "type": "address",
        "indexed": false,
        "internalType": "contract IStrategy"
      },
      {
        "name": "shares",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorSharesDecreased",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "staker",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "strategy",
        "type": "address",
        "indexed": false,
        "internalType": "contract IStrategy"
      },
      {
        "name": "shares",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorSharesIncreased",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "staker",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "strategy",
        "type": "address",
        "indexed": false,
        "internalType": "contract IStrategy"
      },
      {
        "name": "shares",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SlashingWithdrawalCompleted",
    "inputs": [
      {
        "name": "withdrawalRoot",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SlashingWithdrawalQueued",
    "inputs": [
      {
        "name": "withdrawalRoot",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "withdrawal",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct IDelegationManagerTypes.Withdrawal",
        "components": [
          {
            "name": "staker",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "delegatedTo",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "withdrawer",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "startBlock",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "strategies",
            "type": "address[]",
            "internalType": "contract IStrategy[]"
          },
          {
            "name": "scaledShares",
            "type": "uint256[]",
            "internalType": "uint256[]"
          }
        ]
      },
      {
        "name": "sharesToWithdraw",
        "type": "uint256[]",
        "indexed": false,
        "internalType": "uint256[]"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "StakerDelegated",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "StakerForceUndelegated",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "StakerUndelegated",
    "inputs": [
      {
        "name": "staker",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "ActivelyDelegated",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CallerCannotUndelegate",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FullySlashed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InputArrayLengthMismatch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InputArrayLengthZero",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotActivelyDelegated",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OnlyAllocationManager",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OnlyEigenPodManager",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OnlyStrategyManagerOrEigenPodManager",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OperatorNotRegistered",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OperatorsCannotUndelegate",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SaltSpent",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SignatureExpired",
    "inputs": []
  },
  {
    "type": "error",
    "name": "WithdrawalDelayNotElapsed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "WithdrawalNotQueued",
    "inputs": []
  },
  {
    "type": "error",
    "name": "WithdrawerNotCaller",
    "inputs": []
  }
]

================
File: contracts/anvil/build-state.sh
================
#!/usr/bin/env bash
set -e
STATE_FILE="contracts/anvil/state.json"
mkdir -p "$(dirname "$STATE_FILE")"
echo "Starting Anvil with state dump in background"
anvil --dump-state "$STATE_FILE" --port 8545 --base-fee 0 --gas-price 0 > /dev/null 2>&1 &
ANVIL_PID=$!
sleep 3
cp .env.example .env
cp contracts/.env.example contracts/.env
echo "Building contracts"
make build-contracts > /dev/null 2>&1
echo "Deploying EigenLayer contracts."
make deploy-eigenlayer-contracts > /dev/null 2>&1
echo "Deploying HelloWorld contracts."
make deploy-helloworld-contracts > /dev/null 2>&1
echo "Killed Anvil"
kill $ANVIL_PID || true

================
File: contracts/anvil/deploy-el.sh
================
#!/usr/bin/env bash
set -e
RPC_URL=http://localhost:8545
PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
# cd to the directory of this script so that this can be run from anywhere
parent_path=$(
    cd "$(dirname "${BASH_SOURCE[0]}")"
    pwd -P
)
cd "$parent_path"
cd ../
forge script script/DeployEigenLayerCore.s.sol --rpc-url http://localhost:8545 --broadcast

================
File: contracts/anvil/deploy-helloworld.sh
================
#!/usr/bin/env bash
set -e
RPC_URL=http://localhost:8545
PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
# cd to the directory of this script so that this can be run from anywhere
parent_path=$(
    cd "$(dirname "${BASH_SOURCE[0]}")"
    pwd -P
)
cd "$parent_path"
cd ../
forge script script/HelloWorldDeployer.s.sol --rpc-url http://localhost:8545 --broadcast

================
File: contracts/config/core/31337.json
================
{
  "strategyManager": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "initialStrategyWhitelister": "0x959922be3caee4b8cd9a407cc3ac1c251c2007b1"
  },
  "delegationManager": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "minWithdrawalDelayBlocks": 50400
  },
  "eigenPodManager": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
  },
  "allocationManager": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "deallocationDelay": 0,
    "allocationConfigurationDelay": 0
  },
  "strategyFactory": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
  },
  "avsDirectory": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
  },
  "rewardsCoordinator": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "rewardsUpdater": "0x14dC79964da2C08b23698B3D3cc7Ca32193d9955",
    "activationDelay": 0,
    "defaultSplitBips": 1000,
    "calculationIntervalSeconds": 86400,
    "maxRewardsDuration": 864000,
    "maxRetroactiveLength": 432000,
    "maxFutureLength": 86400,
    "genesisRewardsTimestamp": 1672531200
  }
}

================
File: contracts/config/hello-world/31337.json
================
{
  "addresses": {
    "rewardsOwner": "0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f",
    "rewardsInitiator": "0xa0Ee7A142d267C1f36714E4a8F75612F20a79720"
  },
  "keys": {
    "rewardsOwner": "0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97",
    "rewardsInitiator": "0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6"
  }
}

================
File: contracts/mocks/MockStrategy.sol
================
// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@eigenlayer/contracts/interfaces/IStrategy.sol";

contract MockStrategy is IStrategy {
    IERC20 public override underlyingToken;
    uint256 public override totalShares;
    mapping(address => uint256) public userShares;
    uint256 public constant EXCHANGE_RATE = 1e18; // 1:1 exchange rate for simplicity

    constructor(IERC20 _underlyingToken) {
        underlyingToken = _underlyingToken;
        emit StrategyTokenSet(_underlyingToken, 18); // Assuming 18 decimals for simplicity
    }

    function deposit(IERC20 token, uint256 amount) external override returns (uint256) {
        require(token == underlyingToken, "Invalid token");
        uint256 newShares = amount;
        totalShares += newShares;
        userShares[msg.sender] += newShares;
        emit ExchangeRateEmitted(EXCHANGE_RATE);
        return newShares;
    }

    function withdraw(address recipient, IERC20 token, uint256 amountShares) external override {
        require(token == underlyingToken, "Invalid token");
        require(userShares[msg.sender] >= amountShares, "Insufficient shares");
        userShares[msg.sender] -= amountShares;
        totalShares -= amountShares;
        underlyingToken.transfer(recipient, amountShares);
    }

    function sharesToUnderlying(uint256 amountShares) external pure override returns (uint256) {
        return amountShares;
    }

    function underlyingToShares(uint256 amountUnderlying) external pure override returns (uint256) {
        return amountUnderlying;
    }

    function userUnderlying(address user) external view override returns (uint256) {
        return userShares[user];
    }

    function shares(address user) external view override returns (uint256) {
        return userShares[user];
    }

    function sharesToUnderlyingView(uint256 amountShares) external pure override returns (uint256) {
        return amountShares;
    }

    function underlyingToSharesView(uint256 amountUnderlying) external pure override returns (uint256) {
        return amountUnderlying;
    }

    function userUnderlyingView(address user) external view override returns (uint256) {
        return userShares[user];
    }

    function explanation() external pure override returns (string memory) {
        return "Mock Strategy for testing purposes";
    }
}

================
File: contracts/script/utils/CoreDeploymentParsingLib.sol
================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import {ProxyAdmin} from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
import {TransparentUpgradeableProxy} from
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
import {UpgradeableBeacon} from "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol";
import {console2} from "forge-std/Test.sol";
import {Vm} from "forge-std/Vm.sol";
import {stdJson} from "forge-std/StdJson.sol";
import {DelegationManager} from "@eigenlayer/contracts/core/DelegationManager.sol";
import {StrategyManager} from "@eigenlayer/contracts/core/StrategyManager.sol";
import {AVSDirectory} from "@eigenlayer/contracts/core/AVSDirectory.sol";
import {EigenPodManager} from "@eigenlayer/contracts/pods/EigenPodManager.sol";
import {RewardsCoordinator} from "@eigenlayer/contracts/core/RewardsCoordinator.sol";
import {StrategyBase} from "@eigenlayer/contracts/strategies/StrategyBase.sol";
import {EigenPod} from "@eigenlayer/contracts/pods/EigenPod.sol";
import {IETHPOSDeposit} from "@eigenlayer/contracts/interfaces/IETHPOSDeposit.sol";
import {StrategyBaseTVLLimits} from "@eigenlayer/contracts/strategies/StrategyBaseTVLLimits.sol";
import {PauserRegistry} from "@eigenlayer/contracts/permissions/PauserRegistry.sol";
import {IStrategy} from "@eigenlayer/contracts/interfaces/IStrategy.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ISignatureUtilsMixin} from "@eigenlayer/contracts/interfaces/ISignatureUtilsMixin.sol";
import {IDelegationManager} from "@eigenlayer/contracts/interfaces/IDelegationManager.sol";
import {IBeacon} from "@openzeppelin/contracts/proxy/beacon/IBeacon.sol";
import {IStrategyManager} from "@eigenlayer/contracts/interfaces/IStrategyManager.sol";
import {ISlasher} from "@eigenlayer-middleware/src/interfaces/ISlasher.sol";
import {IEigenPodManager} from "@eigenlayer/contracts/interfaces/IEigenPodManager.sol";
import {IAVSDirectory} from "@eigenlayer/contracts/interfaces/IAVSDirectory.sol";
import {IPauserRegistry} from "@eigenlayer/contracts/interfaces/IPauserRegistry.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
import {StrategyFactory} from "@eigenlayer/contracts/strategies/StrategyFactory.sol";

import {UpgradeableProxyLib} from "./UpgradeableProxyLib.sol";
import {CoreDeployLib} from "@eigenlayer-middleware/test/utils/CoreDeployLib.sol";

library CoreDeploymentParsingLib {
    using stdJson for *;
    using Strings for *;
    using UpgradeableProxyLib for address;

    Vm internal constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));

    function readDeploymentConfigValues(
        string memory directoryPath,
        string memory fileName
    ) internal view returns (CoreDeployLib.DeploymentConfigData memory) {
        string memory pathToFile = string.concat(directoryPath, fileName);

        require(vm.exists(pathToFile), "CoreDeployment: Deployment config file does not exist");

        string memory json = vm.readFile(pathToFile);

        CoreDeployLib.DeploymentConfigData memory data;

        // StrategyManager start
        data.strategyManager.initPausedStatus = json.readUint(".strategyManager.initPausedStatus");
        data.strategyManager.initialOwner = json.readAddress(".strategyManager.initialOwner");
        data.strategyManager.initialStrategyWhitelister =
            json.readAddress(".strategyManager.initialStrategyWhitelister");
        // StrategyManager config end

        // DelegationManager config start
        data.delegationManager.initPausedStatus =
            json.readUint(".delegationManager.initPausedStatus");
        data.delegationManager.initialOwner = json.readAddress(".delegationManager.initialOwner");
        data.delegationManager.minWithdrawalDelayBlocks =
            uint32(json.readUint(".delegationManager.minWithdrawalDelayBlocks"));
        // DelegationManager config end

        // EigenPodManager config start
        data.eigenPodManager.initPausedStatus = json.readUint(".eigenPodManager.initPausedStatus");
        data.eigenPodManager.initialOwner = json.readAddress(".eigenPodManager.initialOwner");
        // EigenPodManager config end

        // AllocationManager config start
        data.allocationManager.initPausedStatus =
            json.readUint(".allocationManager.initPausedStatus");
        data.allocationManager.initialOwner = json.readAddress(".allocationManager.initialOwner");
        data.allocationManager.deallocationDelay =
            uint32(json.readUint(".allocationManager.deallocationDelay"));
        data.allocationManager.allocationConfigurationDelay =
            uint32(json.readUint(".allocationManager.allocationConfigurationDelay"));
        // AllocationManager config end

        // StrategyFactory config start
        data.strategyFactory.initPausedStatus = json.readUint(".strategyFactory.initPausedStatus");
        data.strategyFactory.initialOwner = json.readAddress(".strategyFactory.initialOwner");
        // StrategyFactory config end

        // AVSDirectory config start
        data.avsDirectory.initPausedStatus = json.readUint(".avsDirectory.initPausedStatus");
        data.avsDirectory.initialOwner = json.readAddress(".avsDirectory.initialOwner");
        // AVSDirectory config end

        // RewardsCoordinator config start
        data.rewardsCoordinator.initPausedStatus =
            json.readUint(".rewardsCoordinator.initPausedStatus");
        data.rewardsCoordinator.initialOwner = json.readAddress(".rewardsCoordinator.initialOwner");
        data.rewardsCoordinator.rewardsUpdater =
            json.readAddress(".rewardsCoordinator.rewardsUpdater");

        data.rewardsCoordinator.activationDelay =
            uint32(json.readUint(".rewardsCoordinator.activationDelay"));
        data.rewardsCoordinator.defaultSplitBips =
            uint16(json.readUint(".rewardsCoordinator.defaultSplitBips"));
        data.rewardsCoordinator.calculationIntervalSeconds =
            uint32(json.readUint(".rewardsCoordinator.calculationIntervalSeconds"));
        data.rewardsCoordinator.maxRewardsDuration =
            uint32(json.readUint(".rewardsCoordinator.maxRewardsDuration"));
        data.rewardsCoordinator.maxRetroactiveLength =
            uint32(json.readUint(".rewardsCoordinator.maxRetroactiveLength"));
        data.rewardsCoordinator.maxFutureLength =
            uint32(json.readUint(".rewardsCoordinator.maxFutureLength"));
        data.rewardsCoordinator.genesisRewardsTimestamp =
            uint32(json.readUint(".rewardsCoordinator.genesisRewardsTimestamp"));
        // RewardsCoordinator config end

        data.ethPOSDeposit.ethPOSDepositAddress = address(1);

        return data;
    }

    function readDeploymentConfigValues(
        string memory directoryPath,
        uint256 chainId
    ) internal view returns (CoreDeployLib.DeploymentConfigData memory) {
        return
            readDeploymentConfigValues(directoryPath, string.concat(vm.toString(chainId), ".json"));
    }

    function readDeploymentJson(
        string memory directoryPath,
        uint256 chainId
    ) internal view returns (CoreDeployLib.DeploymentData memory) {
        return readDeploymentJson(directoryPath, string.concat(vm.toString(chainId), ".json"));
    }

    function readDeploymentJson(
        string memory path,
        string memory fileName
    ) internal view returns (CoreDeployLib.DeploymentData memory) {
        string memory pathToFile = string.concat(path, fileName);

        require(vm.exists(pathToFile), "CoreDeployment: Deployment file does not exist");

        string memory json = vm.readFile(pathToFile);

        CoreDeployLib.DeploymentData memory data;
        data.delegationManager = json.readAddress(".addresses.delegationManager");
        data.avsDirectory = json.readAddress(".addresses.avsDirectory");
        data.strategyManager = json.readAddress(".addresses.strategyManager");
        data.eigenPodManager = json.readAddress(".addresses.eigenPodManager");
        data.allocationManager = json.readAddress(".addresses.allocationManager");
        data.eigenPodBeacon = json.readAddress(".addresses.eigenPodBeacon");
        data.pauserRegistry = json.readAddress(".addresses.pauserRegistry");
        data.strategyFactory = json.readAddress(".addresses.strategyFactory");
        data.strategyBeacon = json.readAddress(".addresses.strategyBeacon");
        data.rewardsCoordinator = json.readAddress(".addresses.rewardsCoordinator");
        data.permissionController = json.readAddress(".addresses.permissionController");

        return data;
    }

    /// TODO: Need to be able to read json from eigenlayer-contracts repo for holesky/mainnet and output the json here
    function writeDeploymentJson(
        CoreDeployLib.DeploymentData memory data
    ) internal {
        writeDeploymentJson("deployments/core/", block.chainid, data);
    }

    function writeDeploymentJson(
        string memory path,
        uint256 chainId,
        CoreDeployLib.DeploymentData memory data
    ) internal {
        address proxyAdmin = address(UpgradeableProxyLib.getProxyAdmin(data.strategyManager));

        string memory deploymentData = _generateDeploymentJson(data, proxyAdmin);

        string memory fileName = string.concat(path, vm.toString(chainId), ".json");
        if (!vm.exists(path)) {
            vm.createDir(path, true);
        }

        vm.writeFile(fileName, deploymentData);
        console2.log("Deployment artifacts written to:", fileName);
    }

    function _generateDeploymentJson(
        CoreDeployLib.DeploymentData memory data,
        address proxyAdmin
    ) private view returns (string memory) {
        return string.concat(
            '{"lastUpdate":{"timestamp":"',
            vm.toString(block.timestamp),
            '","block_number":"',
            vm.toString(block.number),
            '"},"addresses":',
            _generateContractsJson(data, proxyAdmin),
            "}"
        );
    }

    function _generateContractsJson(
        CoreDeployLib.DeploymentData memory data,
        address proxyAdmin
    ) private view returns (string memory) {
        /// TODO: namespace contracts -> {avs, core}
        return string.concat(
            '{"proxyAdmin":"',
            proxyAdmin.toHexString(),
            '","delegationManager":"',
            data.delegationManager.toHexString(),
            '","delegationManagerImpl":"',
            data.delegationManager.getImplementation().toHexString(),
            '","avsDirectory":"',
            data.avsDirectory.toHexString(),
            '","avsDirectoryImpl":"',
            data.avsDirectory.getImplementation().toHexString(),
            '","strategyManager":"',
            data.strategyManager.toHexString(),
            '","strategyManagerImpl":"',
            data.strategyManager.getImplementation().toHexString(),
            '","eigenPodManager":"',
            data.eigenPodManager.toHexString(),
            '","eigenPodManagerImpl":"',
            data.eigenPodManager.getImplementation().toHexString(),
            '","allocationManager":"',
            data.allocationManager.toHexString(),
            '","allocationManagerImpl":"',
            data.allocationManager.getImplementation().toHexString(),
            '","eigenPodBeacon":"',
            data.eigenPodBeacon.toHexString(),
            '","pauserRegistry":"',
            data.pauserRegistry.toHexString(),
            '","pauserRegistryImpl":"',
            data.pauserRegistry.getImplementation().toHexString(),
            '","strategyFactory":"',
            data.strategyFactory.toHexString(),
            '","strategyFactoryImpl":"',
            data.strategyFactory.getImplementation().toHexString(),
            '","strategyBeacon":"',
            data.strategyBeacon.toHexString(),
            '","rewardsCoordinator":"',
            data.rewardsCoordinator.toHexString(),
            '","rewardsCoordinatorImpl":"',
            data.rewardsCoordinator.getImplementation().toHexString(),
            '","permissionController":"',
            data.permissionController.toHexString(),
            '","permissionControllerImpl":"',
            data.permissionController.getImplementation().toHexString(),
            '"}'
        );
    }
}

================
File: contracts/script/utils/HelloWorldDeploymentLib.sol
================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import {ProxyAdmin} from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
import {TransparentUpgradeableProxy} from
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
import {Script} from "forge-std/Script.sol";
import {console2} from "forge-std/Test.sol";
import {Vm} from "forge-std/Vm.sol";
import {stdJson} from "forge-std/StdJson.sol";
import {ECDSAStakeRegistry} from "@eigenlayer-middleware/src/unaudited/ECDSAStakeRegistry.sol";
import {HelloWorldServiceManager} from "../../src/HelloWorldServiceManager.sol";
import {IDelegationManager} from "@eigenlayer/contracts/interfaces/IDelegationManager.sol";
import {IECDSAStakeRegistryTypes} from
    "@eigenlayer-middleware/src/interfaces/IECDSAStakeRegistry.sol";
import {UpgradeableProxyLib} from "./UpgradeableProxyLib.sol";
import {CoreDeployLib, CoreDeploymentParsingLib} from "./CoreDeploymentParsingLib.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";

library HelloWorldDeploymentLib {
    using stdJson for *;
    using Strings for *;
    using UpgradeableProxyLib for address;

    Vm internal constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));

    struct DeploymentData {
        address helloWorldServiceManager;
        address stakeRegistry;
        address strategy;
        address token;
    }

    struct DeploymentConfigData {
        address rewardsOwner;
        address rewardsInitiator;
        uint256 rewardsOwnerKey;
        uint256 rewardsInitiatorKey;
    }

    function deployContracts(
        address proxyAdmin,
        CoreDeployLib.DeploymentData memory core,
        IECDSAStakeRegistryTypes.Quorum memory quorum,
        address rewardsInitiator,
        address owner
    ) internal returns (DeploymentData memory) {
        DeploymentData memory result;

        {
            // First, deploy upgradeable proxy contracts that will point to the implementations.
            result.helloWorldServiceManager = UpgradeableProxyLib.setUpEmptyProxy(proxyAdmin);
            result.stakeRegistry = UpgradeableProxyLib.setUpEmptyProxy(proxyAdmin);
        }
        deployAndUpgradeStakeRegistryImpl(result, core, quorum);
        deployAndUpgradeServiceManagerImpl(result, core, owner, rewardsInitiator);

        return result;
    }

    function deployAndUpgradeStakeRegistryImpl(
        DeploymentData memory deployment,
        CoreDeployLib.DeploymentData memory core,
        IECDSAStakeRegistryTypes.Quorum memory quorum
    ) private {
        address stakeRegistryImpl =
            address(new ECDSAStakeRegistry(IDelegationManager(core.delegationManager)));

        bytes memory upgradeCall = abi.encodeCall(
            ECDSAStakeRegistry.initialize, (deployment.helloWorldServiceManager, 0, quorum)
        );
        UpgradeableProxyLib.upgradeAndCall(deployment.stakeRegistry, stakeRegistryImpl, upgradeCall);
    }

    function deployAndUpgradeServiceManagerImpl(
        DeploymentData memory deployment,
        CoreDeployLib.DeploymentData memory core,
        address owner,
        address rewardsInitiator
    ) private {
        address helloWorldServiceManager = deployment.helloWorldServiceManager;
        address helloWorldServiceManagerImpl = address(
            new HelloWorldServiceManager(
                core.avsDirectory,
                deployment.stakeRegistry,
                core.rewardsCoordinator,
                core.delegationManager,
                core.allocationManager,
                4
            )
        );

        bytes memory upgradeCall =
            abi.encodeCall(HelloWorldServiceManager.initialize, (owner, rewardsInitiator));

        UpgradeableProxyLib.upgradeAndCall(
            helloWorldServiceManager, helloWorldServiceManagerImpl, upgradeCall
        );
    }

    function readDeploymentJson(
        uint256 chainId
    ) internal view returns (DeploymentData memory) {
        return readDeploymentJson("deployments/", chainId);
    }

    function readDeploymentJson(
        string memory directoryPath,
        uint256 chainId
    ) internal view returns (DeploymentData memory) {
        string memory fileName = string.concat(directoryPath, vm.toString(chainId), ".json");

        require(vm.exists(fileName), "HelloWorldDeployment: Deployment file does not exist");

        string memory json = vm.readFile(fileName);

        DeploymentData memory data;
        /// TODO: 2 Step for reading deployment json.  Read to the core and the AVS data
        data.helloWorldServiceManager = json.readAddress(".addresses.helloWorldServiceManager");
        data.stakeRegistry = json.readAddress(".addresses.stakeRegistry");
        data.strategy = json.readAddress(".addresses.strategy");
        data.token = json.readAddress(".addresses.token");

        return data;
    }

    /// write to default output path
    function writeDeploymentJson(
        DeploymentData memory data
    ) internal {
        writeDeploymentJson("deployments/hello-world/", block.chainid, data);
    }

    function writeDeploymentJson(
        string memory outputPath,
        uint256 chainId,
        DeploymentData memory data
    ) internal {
        address proxyAdmin =
            address(UpgradeableProxyLib.getProxyAdmin(data.helloWorldServiceManager));

        string memory deploymentData = _generateDeploymentJson(data, proxyAdmin);

        string memory fileName = string.concat(outputPath, vm.toString(chainId), ".json");
        if (!vm.exists(outputPath)) {
            vm.createDir(outputPath, true);
        }

        vm.writeFile(fileName, deploymentData);
        console2.log("Deployment artifacts written to:", fileName);
    }

    function readDeploymentConfigValues(
        string memory directoryPath,
        string memory fileName
    ) internal view returns (DeploymentConfigData memory) {
        string memory pathToFile = string.concat(directoryPath, fileName);

        require(
            vm.exists(pathToFile), "HelloWorldDeployment: Deployment Config file does not exist"
        );

        string memory json = vm.readFile(pathToFile);

        DeploymentConfigData memory data;
        data.rewardsOwner = json.readAddress(".addresses.rewardsOwner");
        data.rewardsInitiator = json.readAddress(".addresses.rewardsInitiator");
        data.rewardsOwnerKey = json.readUint(".keys.rewardsOwner");
        data.rewardsInitiatorKey = json.readUint(".keys.rewardsInitiator");
        return data;
    }

    function readDeploymentConfigValues(
        string memory directoryPath,
        uint256 chainId
    ) internal view returns (DeploymentConfigData memory) {
        return
            readDeploymentConfigValues(directoryPath, string.concat(vm.toString(chainId), ".json"));
    }

    function _generateDeploymentJson(
        DeploymentData memory data,
        address proxyAdmin
    ) private view returns (string memory) {
        return string.concat(
            '{"lastUpdate":{"timestamp":"',
            vm.toString(block.timestamp),
            '","block_number":"',
            vm.toString(block.number),
            '"},"addresses":',
            _generateContractsJson(data, proxyAdmin),
            "}"
        );
    }

    function _generateContractsJson(
        DeploymentData memory data,
        address proxyAdmin
    ) private view returns (string memory) {
        return string.concat(
            '{"proxyAdmin":"',
            proxyAdmin.toHexString(),
            '","helloWorldServiceManager":"',
            data.helloWorldServiceManager.toHexString(),
            '","helloWorldServiceManagerImpl":"',
            data.helloWorldServiceManager.getImplementation().toHexString(),
            '","stakeRegistry":"',
            data.stakeRegistry.toHexString(),
            '","stakeRegistryImpl":"',
            data.stakeRegistry.getImplementation().toHexString(),
            '","strategy":"',
            data.strategy.toHexString(),
            '","token":"',
            data.token.toHexString(),
            '"}'
        );
    }
}

================
File: contracts/script/utils/SetupDistributionsLib.sol
================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import {
    IRewardsCoordinator,
    IRewardsCoordinatorTypes
} from "@eigenlayer/contracts/interfaces/IRewardsCoordinator.sol";
import {IStrategy} from "eigenlayer-contracts/src/contracts/interfaces/IStrategyManager.sol";
import {ECDSAServiceManagerBase} from
    "@eigenlayer-middleware/src/unaudited/ECDSAServiceManagerBase.sol";
import {Vm} from "forge-std/Vm.sol";
import {console} from "forge-std/console.sol";

library SetupDistributionsLib {
    Vm internal constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));

    struct PaymentLeaves {
        bytes32[] leaves;
        bytes32[] tokenLeaves;
    }

    function createAVSRewardsSubmissions(
        address helloWorldServiceManager,
        address strategy,
        uint256 numPayments,
        uint256 amountPerPayment,
        uint32 duration,
        uint32 startTimestamp
    ) internal {
        IRewardsCoordinatorTypes.RewardsSubmission[] memory rewardsSubmissions =
            new IRewardsCoordinatorTypes.RewardsSubmission[](numPayments);
        for (uint256 i = 0; i < numPayments; i++) {
            IRewardsCoordinatorTypes.StrategyAndMultiplier[] memory strategiesAndMultipliers =
                new IRewardsCoordinatorTypes.StrategyAndMultiplier[](1);
            strategiesAndMultipliers[0] = IRewardsCoordinatorTypes.StrategyAndMultiplier({
                strategy: IStrategy(strategy),
                multiplier: 10_000
            });

            IRewardsCoordinatorTypes.RewardsSubmission memory rewardsSubmission =
            IRewardsCoordinatorTypes.RewardsSubmission({
                strategiesAndMultipliers: strategiesAndMultipliers,
                token: IStrategy(strategy).underlyingToken(),
                amount: amountPerPayment,
                startTimestamp: startTimestamp,
                duration: duration
            });

            rewardsSubmissions[i] = rewardsSubmission;
        }
        ECDSAServiceManagerBase(helloWorldServiceManager).createAVSRewardsSubmission(
            rewardsSubmissions
        );
    }

    function createOperatorDirectedAVSRewardsSubmissions(
        address helloWorldServiceManager,
        address[] memory operators,
        address strategy,
        uint256 numPayments,
        uint256 amountPerPayment,
        uint32 duration,
        uint32 startTimestamp
    ) internal {
        uint256 operatorRewardAmount = amountPerPayment / operators.length;

        IRewardsCoordinatorTypes.OperatorReward[] memory operatorRewards =
            new IRewardsCoordinatorTypes.OperatorReward[](operators.length);
        for (uint256 i = 0; i < operators.length; i++) {
            operatorRewards[i] = IRewardsCoordinatorTypes.OperatorReward({
                operator: operators[i],
                amount: operatorRewardAmount
            });
        }

        IRewardsCoordinatorTypes.OperatorDirectedRewardsSubmission[] memory rewardsSubmissions =
            new IRewardsCoordinatorTypes.OperatorDirectedRewardsSubmission[](numPayments);
        for (uint256 i = 0; i < numPayments; i++) {
            IRewardsCoordinatorTypes.StrategyAndMultiplier[] memory strategiesAndMultipliers =
                new IRewardsCoordinatorTypes.StrategyAndMultiplier[](1);
            strategiesAndMultipliers[0] = IRewardsCoordinatorTypes.StrategyAndMultiplier({
                strategy: IStrategy(strategy),
                multiplier: 10_000
            });

            IRewardsCoordinatorTypes.OperatorDirectedRewardsSubmission memory rewardsSubmission =
            IRewardsCoordinatorTypes.OperatorDirectedRewardsSubmission({
                strategiesAndMultipliers: strategiesAndMultipliers,
                token: IStrategy(strategy).underlyingToken(),
                operatorRewards: operatorRewards,
                startTimestamp: startTimestamp,
                duration: duration,
                description: "test"
            });
            console.log("rrr");
            console.log(startTimestamp);
            console.log(duration);
            console.log(block.timestamp);

            rewardsSubmissions[i] = rewardsSubmission;
        }
        ECDSAServiceManagerBase(helloWorldServiceManager).createOperatorDirectedAVSRewardsSubmission(
            rewardsSubmissions
        );
    }

    function processClaim(
        IRewardsCoordinator rewardsCoordinator,
        string memory filePath,
        uint256 indexToProve,
        address recipient,
        IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf memory earnerLeaf,
        uint256 NUM_TOKEN_EARNINGS,
        address strategy,
        uint32 amountPerPayment
    ) internal {
        PaymentLeaves memory paymentLeaves = parseLeavesFromJson(filePath);

        bytes memory proof = generateMerkleProof(paymentLeaves.leaves, indexToProve);
        //we only have one token leaf
        bytes memory tokenProof = generateMerkleProof(paymentLeaves.tokenLeaves, 0);

        uint32[] memory tokenIndices = new uint32[](NUM_TOKEN_EARNINGS);
        bytes[] memory tokenProofs = new bytes[](NUM_TOKEN_EARNINGS);
        tokenProofs[0] = tokenProof;

        IRewardsCoordinatorTypes.TokenTreeMerkleLeaf[] memory tokenLeaves =
            new IRewardsCoordinatorTypes.TokenTreeMerkleLeaf[](NUM_TOKEN_EARNINGS);
        tokenLeaves[0] = defaultTokenLeaf(amountPerPayment, strategy);

        // this workflow assumes a new root submitted for every payment claimed.  So we get the latest rood index to process a claim for
        uint256 rootIndex = rewardsCoordinator.getDistributionRootsLength() - 1;

        IRewardsCoordinatorTypes.RewardsMerkleClaim memory claim = IRewardsCoordinatorTypes
            .RewardsMerkleClaim({
            rootIndex: uint32(rootIndex),
            earnerIndex: uint32(indexToProve),
            earnerTreeProof: proof,
            earnerLeaf: earnerLeaf,
            tokenIndices: tokenIndices,
            tokenTreeProofs: tokenProofs,
            tokenLeaves: tokenLeaves
        });

        rewardsCoordinator.processClaim(claim, recipient);
    }

    function submitRoot(
        IRewardsCoordinator rewardsCoordinator,
        bytes32[] memory tokenLeaves,
        IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf[] memory earnerLeaves,
        uint32 rewardsCalculationEndTimestamp,
        uint256 NUM_PAYMENTS,
        uint256 NUM_TOKEN_EARNINGS,
        string memory filePath
    ) internal {
        bytes32 paymentRoot = createPaymentRoot(
            rewardsCoordinator,
            tokenLeaves,
            earnerLeaves,
            NUM_PAYMENTS,
            NUM_TOKEN_EARNINGS,
            filePath
        );
        rewardsCoordinator.submitRoot(paymentRoot, rewardsCalculationEndTimestamp);
    }

    function createPaymentRoot(
        IRewardsCoordinator rewardsCoordinator,
        bytes32[] memory tokenLeaves,
        IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf[] memory earnerLeaves,
        uint256 NUM_PAYMENTS,
        uint256 NUM_TOKEN_EARNINGS,
        string memory filePath
    ) internal returns (bytes32) {
        require(
            earnerLeaves.length == NUM_PAYMENTS, "Number of earners must match number of payments"
        );
        bytes32[] memory leaves = new bytes32[](NUM_PAYMENTS);

        require(
            tokenLeaves.length == NUM_TOKEN_EARNINGS,
            "Number of token leaves must match number of token earnings"
        );
        for (uint256 i = 0; i < NUM_PAYMENTS; i++) {
            leaves[i] = rewardsCoordinator.calculateEarnerLeafHash(earnerLeaves[i]);
        }

        writeLeavesToJson(leaves, tokenLeaves, filePath);
        return (merkleizeKeccak(leaves));
    }

    function createEarnerLeaves(
        address[] calldata earners,
        bytes32[] memory tokenLeaves
    ) public pure returns (IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf[] memory) {
        IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf[] memory leaves =
            new IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf[](earners.length);
        for (uint256 i = 0; i < earners.length; i++) {
            leaves[i] = IRewardsCoordinatorTypes.EarnerTreeMerkleLeaf({
                earner: earners[i],
                earnerTokenRoot: createTokenRoot(tokenLeaves)
            });
        }
        return leaves;
    }

    function createTokenRoot(
        bytes32[] memory tokenLeaves
    ) public pure returns (bytes32) {
        return merkleizeKeccak(tokenLeaves);
    }

    function createTokenLeaves(
        IRewardsCoordinator rewardsCoordinator,
        uint256 NUM_TOKEN_EARNINGS,
        uint256 TOKEN_EARNINGS,
        address strategy
    ) internal view returns (bytes32[] memory) {
        bytes32[] memory leaves = new bytes32[](NUM_TOKEN_EARNINGS);
        for (uint256 i = 0; i < NUM_TOKEN_EARNINGS; i++) {
            IRewardsCoordinatorTypes.TokenTreeMerkleLeaf memory leaf =
                defaultTokenLeaf(TOKEN_EARNINGS, strategy);
            leaves[i] = rewardsCoordinator.calculateTokenLeafHash(leaf);
        }
        return leaves;
    }

    function defaultTokenLeaf(
        uint256 TOKEN_EARNINGS,
        address strategy
    ) internal view returns (IRewardsCoordinatorTypes.TokenTreeMerkleLeaf memory) {
        IRewardsCoordinatorTypes.TokenTreeMerkleLeaf memory leaf = IRewardsCoordinatorTypes
            .TokenTreeMerkleLeaf({
            token: IStrategy(strategy).underlyingToken(),
            cumulativeEarnings: TOKEN_EARNINGS
        });
        return leaf;
    }

    function writeLeavesToJson(
        bytes32[] memory leaves,
        bytes32[] memory tokenLeaves,
        string memory filePath
    ) internal {
        string memory parent_object = "parent_object";
        vm.serializeBytes32(parent_object, "leaves", leaves);
        string memory finalJson = vm.serializeBytes32(parent_object, "tokenLeaves", tokenLeaves);
        vm.writeJson(finalJson, filePath);
    }

    function parseLeavesFromJson(
        string memory filePath
    ) internal view returns (PaymentLeaves memory) {
        string memory json = vm.readFile(filePath);
        bytes memory data = vm.parseJson(json);
        return abi.decode(data, (PaymentLeaves));
    }

    function generateMerkleProof(
        bytes32[] memory leaves,
        uint256 index
    ) internal pure returns (bytes memory) {
        require(leaves.length > 0, "Leaves array cannot be empty");
        require(index < leaves.length, "Index out of bounds");

        leaves = padLeaves(leaves);

        uint256 n = leaves.length;
        uint256 depth = 0;
        while ((1 << depth) < n) {
            depth++;
        }

        bytes32[] memory proof = new bytes32[](depth);
        uint256 proofIndex = 0;

        for (uint256 i = 0; i < depth; i++) {
            uint256 levelSize = (n + 1) / 2;
            uint256 siblingIndex = (index % 2 == 0) ? index + 1 : index - 1;

            if (siblingIndex < n) {
                proof[proofIndex] = leaves[siblingIndex];
                proofIndex++;
            }

            for (uint256 j = 0; j < levelSize; j++) {
                if (2 * j + 1 < n) {
                    leaves[j] = keccak256(abi.encodePacked(leaves[2 * j], leaves[2 * j + 1]));
                } else {
                    leaves[j] = leaves[2 * j];
                }
            }

            n = levelSize;
            index /= 2;
        }

        return abi.encodePacked(proof);
    }

    /**
     * @notice this function returns the merkle root of a tree created from a set of leaves using keccak256 as its hash function
     *  @param leaves the leaves of the merkle tree
     *  @return The computed Merkle root of the tree.
     *  @dev This pads to the next power of 2. very inefficient! just for POC
     */
    function merkleizeKeccak(
        bytes32[] memory leaves
    ) internal pure returns (bytes32) {
        // uint256 paddedLength = 2;
        // while(paddedLength < leaves.length) {
        //     paddedLength <<= 1;
        // }

        // bytes32[] memory paddedLeaves = new bytes32[](paddedLength);
        // for (uint256 i = 0; i < leaves.length; i++) {
        //     paddedLeaves[i] = leaves[i];
        // }
        leaves = padLeaves(leaves);

        //there are half as many nodes in the layer above the leaves
        uint256 numNodesInLayer = leaves.length / 2;
        //create a layer to store the internal nodes
        bytes32[] memory layer = new bytes32[](numNodesInLayer);
        //fill the layer with the pairwise hashes of the leaves
        for (uint256 i = 0; i < numNodesInLayer; i++) {
            layer[i] = keccak256(abi.encodePacked(leaves[2 * i], leaves[2 * i + 1]));
        }
        //the next layer above has half as many nodes
        numNodesInLayer /= 2;
        //while we haven't computed the root
        while (numNodesInLayer != 0) {
            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children
            for (uint256 i = 0; i < numNodesInLayer; i++) {
                layer[i] = keccak256(abi.encodePacked(layer[2 * i], layer[2 * i + 1]));
            }
            //the next layer above has half as many nodes
            numNodesInLayer /= 2;
        }
        //the first node in the layer is the root
        return layer[0];
    }

    function padLeaves(
        bytes32[] memory leaves
    ) internal pure returns (bytes32[] memory) {
        uint256 paddedLength = 2;
        while (paddedLength < leaves.length) {
            paddedLength <<= 1;
        }

        bytes32[] memory paddedLeaves = new bytes32[](paddedLength);
        for (uint256 i = 0; i < leaves.length; i++) {
            paddedLeaves[i] = leaves[i];
        }
        return paddedLeaves;
    }
}

================
File: contracts/script/utils/UpgradeableProxyLib.sol
================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import {Vm} from "forge-std/Vm.sol";
import {ProxyAdmin} from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
import {
    ITransparentUpgradeableProxy,
    TransparentUpgradeableProxy
} from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
import {EmptyContract} from "@eigenlayer/test/mocks/EmptyContract.sol";

library UpgradeableProxyLib {
    bytes32 internal constant IMPLEMENTATION_SLOT =
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    bytes32 internal constant ADMIN_SLOT =
        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    Vm internal constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));

    function deployProxyAdmin() internal returns (address) {
        return address(new ProxyAdmin());
    }

    function setUpEmptyProxy(
        address admin
    ) internal returns (address) {
        address emptyContract = address(new EmptyContract());
        return address(new TransparentUpgradeableProxy(emptyContract, admin, ""));
    }

    function upgrade(address proxy, address impl) internal {
        ProxyAdmin admin = getProxyAdmin(proxy);
        admin.upgrade(ITransparentUpgradeableProxy(payable(proxy)), impl);
    }

    function upgradeAndCall(address proxy, address impl, bytes memory initData) internal {
        ProxyAdmin admin = getProxyAdmin(proxy);
        admin.upgradeAndCall(ITransparentUpgradeableProxy(payable(proxy)), impl, initData);
    }

    function getImplementation(
        address proxy
    ) internal view returns (address) {
        bytes32 value = vm.load(proxy, IMPLEMENTATION_SLOT);
        return address(uint160(uint256(value)));
    }

    function getProxyAdmin(
        address proxy
    ) internal view returns (ProxyAdmin) {
        bytes32 value = vm.load(proxy, ADMIN_SLOT);
        return ProxyAdmin(address(uint160(uint256(value))));
    }
}

================
File: contracts/script/DeployEigenLayerCore.s.sol
================
// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.12;

import {Script} from "forge-std/Script.sol";

import {CoreDeployLib, CoreDeploymentParsingLib} from "./utils/CoreDeploymentParsingLib.sol";
import {UpgradeableProxyLib} from "./utils/UpgradeableProxyLib.sol";

import {IRewardsCoordinator} from "@eigenlayer/contracts/interfaces/IRewardsCoordinator.sol";
import {StrategyManager} from "@eigenlayer/contracts/core/StrategyManager.sol";

import "forge-std/Test.sol";

contract DeployEigenLayerCore is Script, Test {
    using CoreDeployLib for *;
    using UpgradeableProxyLib for address;

    address internal deployer;
    address internal proxyAdmin;
    CoreDeployLib.DeploymentData internal deploymentData;
    CoreDeployLib.DeploymentConfigData internal configData;

    function setUp() public virtual {
        deployer = vm.rememberKey(vm.envUint("PRIVATE_KEY"));
        vm.label(deployer, "Deployer");
    }

    function run() external {
        vm.startBroadcast(deployer);
        //set the rewards updater to the deployer address for payment flow
        configData =
            CoreDeploymentParsingLib.readDeploymentConfigValues("config/core/", block.chainid);
        configData.rewardsCoordinator.rewardsUpdater = deployer;
        proxyAdmin = UpgradeableProxyLib.deployProxyAdmin();
        deploymentData = CoreDeployLib.deployContracts(proxyAdmin, configData);

        // TODO: the deployer lib should probably do this
        StrategyManager(deploymentData.strategyManager).setStrategyWhitelister(
            deploymentData.strategyFactory
        );
        vm.stopBroadcast();
        string memory deploymentPath = "deployments/core/";
        CoreDeploymentParsingLib.writeDeploymentJson(deploymentPath, block.chainid, deploymentData);
    }
}

================
File: contracts/script/HelloWorldDeployer.s.sol
================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import {Script} from "forge-std/Script.sol";
import {console2} from "forge-std/Test.sol";
import {HelloWorldDeploymentLib} from "./utils/HelloWorldDeploymentLib.sol";
import {CoreDeployLib, CoreDeploymentParsingLib} from "./utils/CoreDeploymentParsingLib.sol";
import {UpgradeableProxyLib} from "./utils/UpgradeableProxyLib.sol";
import {StrategyBase} from "@eigenlayer/contracts/strategies/StrategyBase.sol";
import {ERC20Mock} from "../test/ERC20Mock.sol";
import {TransparentUpgradeableProxy} from
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
import {StrategyFactory} from "@eigenlayer/contracts/strategies/StrategyFactory.sol";
import {StrategyManager} from "@eigenlayer/contracts/core/StrategyManager.sol";
import {IRewardsCoordinator} from "@eigenlayer/contracts/interfaces/IRewardsCoordinator.sol";

import {
    IECDSAStakeRegistryTypes,
    IStrategy
} from "@eigenlayer-middleware/src/interfaces/IECDSAStakeRegistry.sol";

import "forge-std/Test.sol";

contract HelloWorldDeployer is Script, Test {
    using CoreDeployLib for *;
    using UpgradeableProxyLib for address;

    address private deployer;
    address proxyAdmin;
    address rewardsOwner;
    address rewardsInitiator;
    IStrategy helloWorldStrategy;
    CoreDeployLib.DeploymentData coreDeployment;
    HelloWorldDeploymentLib.DeploymentData helloWorldDeployment;
    HelloWorldDeploymentLib.DeploymentConfigData helloWorldConfig;
    IECDSAStakeRegistryTypes.Quorum internal quorum;
    ERC20Mock token;

    function setUp() public virtual {
        deployer = vm.rememberKey(vm.envUint("PRIVATE_KEY"));
        vm.label(deployer, "Deployer");

        helloWorldConfig =
            HelloWorldDeploymentLib.readDeploymentConfigValues("config/hello-world/", block.chainid);

        coreDeployment =
            CoreDeploymentParsingLib.readDeploymentJson("deployments/core/", block.chainid);
    }

    function run() external {
        vm.startBroadcast(deployer);
        rewardsOwner = helloWorldConfig.rewardsOwner;
        rewardsInitiator = helloWorldConfig.rewardsInitiator;

        token = new ERC20Mock();
        // NOTE: if this fails, it's because the initialStrategyWhitelister is not set to be the StrategyFactory
        helloWorldStrategy =
            IStrategy(StrategyFactory(coreDeployment.strategyFactory).deployNewStrategy(token));

        quorum.strategies.push(
            IECDSAStakeRegistryTypes.StrategyParams({
                strategy: helloWorldStrategy,
                multiplier: 10_000
            })
        );

        token.mint(deployer, 2000);
        token.increaseAllowance(address(coreDeployment.strategyManager), 1000);
        StrategyManager(coreDeployment.strategyManager).depositIntoStrategy(
            helloWorldStrategy, token, 1000
        );

        proxyAdmin = UpgradeableProxyLib.deployProxyAdmin();

        helloWorldDeployment = HelloWorldDeploymentLib.deployContracts(
            proxyAdmin, coreDeployment, quorum, rewardsInitiator, rewardsOwner
        );

        helloWorldDeployment.strategy = address(helloWorldStrategy);
        helloWorldDeployment.token = address(token);

        vm.stopBroadcast();
        verifyDeployment();
        HelloWorldDeploymentLib.writeDeploymentJson(helloWorldDeployment);
    }

    function verifyDeployment() internal view {
        require(
            helloWorldDeployment.stakeRegistry != address(0), "StakeRegistry address cannot be zero"
        );
        require(
            helloWorldDeployment.helloWorldServiceManager != address(0),
            "HelloWorldServiceManager address cannot be zero"
        );
        require(helloWorldDeployment.strategy != address(0), "Strategy address cannot be zero");
        require(proxyAdmin != address(0), "ProxyAdmin address cannot be zero");
        require(
            coreDeployment.delegationManager != address(0),
            "DelegationManager address cannot be zero"
        );
        require(coreDeployment.avsDirectory != address(0), "AVSDirectory address cannot be zero");
    }
}

================
File: contracts/script/SetupDistributions.s.sol
================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import {Script} from "forge-std/Script.sol";
import {HelloWorldDeploymentLib} from "./utils/HelloWorldDeploymentLib.sol";
import {CoreDeployLib, CoreDeploymentParsingLib} from "./utils/CoreDeploymentParsingLib.sol";
import {SetupDistributionsLib} from "./utils/SetupDistributionsLib.sol";
import {IRewardsCoordinator} from "@eigenlayer/contracts/interfaces/IRewardsCoordinator.sol";
import {RewardsCoordinator} from "@eigenlayer/contracts/core/RewardsCoordinator.sol";
import {IStrategy} from "@eigenlayer/contracts/interfaces/IStrategy.sol";
import {ERC20Mock} from "../test/ERC20Mock.sol";

import "forge-std/Test.sol";

contract SetupDistributions is Script, Test {
    struct PaymentInfo {
        address recipient;
        uint32 numPayments;
        uint32 amountPerPayment;
        uint32 duration;
        uint32 startTimestamp;
        uint32 endTimestamp;
        uint256 indexToProve;
    }

    address private deployer;
    CoreDeployLib.DeploymentData coreDeployment;
    CoreDeployLib.DeploymentConfigData coreConfig;

    HelloWorldDeploymentLib.DeploymentData helloWorldDeployment;
    HelloWorldDeploymentLib.DeploymentConfigData helloWorldConfig;

    RewardsCoordinator rewardsCoordinator;
    string internal constant paymentInfofilePath = "test/mockData/scratch/payment_info.json";
    string internal constant filePath = "test/mockData/scratch/payments.json";

    uint32 constant CALCULATION_INTERVAL_SECONDS = 1 days;
    uint256 constant NUM_TOKEN_EARNINGS = 1;
    //duration MUST be a multiple of CALCULATION_INTERVAL_SECONDS .
    //https://github.com/Layr-Labs/eigenlayer-contracts/blob/865e723a6b5c634cf45cce1817dec0ea95f0e03b/src/contracts/core/RewardsCoordinator.sol#L439
    uint32 constant DURATION = 172_800;
    uint32 constant REWARDS_END_TIMESTAMP_GAP = 1 days;
    uint256 constant NUM_EARNERS = 8;

    uint32 numPayments = 8;
    uint32 indexToProve = 0;
    uint32 amountPerPayment = 100;

    address recipient = address(1);
    IRewardsCoordinator.EarnerTreeMerkleLeaf[] public earnerLeaves;
    address[] public earners;
    uint32 startTimestamp;
    uint32 endTimestamp;
    uint256 cumumlativePaymentMultiplier;
    address nonceSender = 0x998abeb3E57409262aE5b751f60747921B33613E;

    address operator1 = address(1);
    address operator2 = address(2);

    function setUp() public {
        deployer = vm.rememberKey(vm.envUint("PRIVATE_KEY"));
        vm.label(deployer, "Deployer");

        coreDeployment =
            CoreDeploymentParsingLib.readDeploymentJson("deployments/core/", block.chainid);
        coreConfig =
            CoreDeploymentParsingLib.readDeploymentConfigValues("config/core/", block.chainid);
        helloWorldDeployment =
            HelloWorldDeploymentLib.readDeploymentJson("deployments/hello-world/", block.chainid);
        helloWorldConfig =
            HelloWorldDeploymentLib.readDeploymentConfigValues("config/hello-world/", block.chainid);

        rewardsCoordinator = RewardsCoordinator(coreDeployment.rewardsCoordinator);

        // TODO: Get the filePath from config
    }

    function run() external {
        vm.startBroadcast(helloWorldConfig.rewardsInitiatorKey);

        // Go back 4 days
        uint256 targetStartTimestamp = block.timestamp - 4 days;
        // Start Timestamp must be a multiple of CALCULATION_INTERVAL_SECONDS
        uint32 diff = (uint32(targetStartTimestamp) % CALCULATION_INTERVAL_SECONDS);
        startTimestamp = uint32(targetStartTimestamp) - diff;

        endTimestamp = uint32(block.timestamp) - REWARDS_END_TIMESTAMP_GAP;
        emit log_named_uint("startTimestamp", startTimestamp);
        emit log_named_uint("endTimestamp", endTimestamp);
        emit log_named_uint("block.timestamp", block.timestamp);
        emit log_named_uint("MAX_RETROACTIVE_LENGTH", rewardsCoordinator.MAX_RETROACTIVE_LENGTH());
        if (endTimestamp > block.timestamp) {
            revert("RewardsEndTimestampNotElapsed.  Please wait to generate new payments.");
        }

        // sets a multiplier based on block number such that cumulativeEarnings increase accordingly for multiple runs of this script in the same session
        uint256 nonce = rewardsCoordinator.getDistributionRootsLength();
        amountPerPayment = uint32(amountPerPayment * (nonce + 1));

        createAVSRewardsSubmissions(numPayments, amountPerPayment, startTimestamp);
        vm.stopBroadcast();
        vm.startBroadcast(deployer);
        earners = _getEarners(deployer);
        submitPaymentRoot(earners, endTimestamp, numPayments, amountPerPayment);
        vm.stopBroadcast();
    }

    function runOperatorDirected() external {
        vm.startBroadcast(helloWorldConfig.rewardsInitiatorKey);

        // Go back 4 days
        uint256 targetStartTimestamp = block.timestamp - 4 days;
        // Start Timestamp must be a multiple of CALCULATION_INTERVAL_SECONDS
        uint32 diff = (uint32(targetStartTimestamp) % CALCULATION_INTERVAL_SECONDS);
        startTimestamp = uint32(targetStartTimestamp) - diff;

        endTimestamp = uint32(block.timestamp) - REWARDS_END_TIMESTAMP_GAP;
        emit log_named_uint("startTimestamp", startTimestamp);
        emit log_named_uint("endTimestamp", endTimestamp);
        emit log_named_uint("block.timestamp", block.timestamp);
        emit log_named_uint("MAX_RETROACTIVE_LENGTH", rewardsCoordinator.MAX_RETROACTIVE_LENGTH());
        if (endTimestamp > block.timestamp) {
            revert("RewardsEndTimestampNotElapsed.  Please wait to generate new payments.");
        }

        // sets a multiplier based on block number such that cumulativeEarnings increase accordingly for multiple runs of this script in the same session
        uint256 nonce = rewardsCoordinator.getDistributionRootsLength();
        amountPerPayment = uint32(amountPerPayment * (nonce + 1));

        createOperatorDirectedAVSRewardsSubmissions(
            numPayments, amountPerPayment, startTimestamp, DURATION
        );
        vm.stopBroadcast();
        vm.startBroadcast(deployer);
        earners = _getEarners(deployer);
        submitPaymentRoot(earners, endTimestamp, numPayments, amountPerPayment);
        vm.stopBroadcast();
    }

    function executeProcessClaim() public {
        uint256 nonce = rewardsCoordinator.getDistributionRootsLength();
        amountPerPayment = uint32(amountPerPayment * nonce);

        vm.startBroadcast(deployer);
        earnerLeaves =
            _getEarnerLeaves(_getEarners(deployer), amountPerPayment, helloWorldDeployment.strategy);
        processClaim(
            filePath, indexToProve, recipient, earnerLeaves[indexToProve], amountPerPayment
        );
        vm.stopBroadcast();
    }

    function createAVSRewardsSubmissions(
        uint256 _numPayments,
        uint256 _amountPerPayment,
        uint32 _startTimestamp
    ) public {
        ERC20Mock(helloWorldDeployment.token).mint(
            helloWorldConfig.rewardsInitiator, _amountPerPayment * _numPayments
        );
        ERC20Mock(helloWorldDeployment.token).increaseAllowance(
            helloWorldDeployment.helloWorldServiceManager, _amountPerPayment * _numPayments
        );
        uint32 duration = rewardsCoordinator.MAX_REWARDS_DURATION();
        SetupDistributionsLib.createAVSRewardsSubmissions(
            helloWorldDeployment.helloWorldServiceManager,
            helloWorldDeployment.strategy,
            _numPayments,
            _amountPerPayment,
            duration,
            _startTimestamp
        );
    }

    function createOperatorDirectedAVSRewardsSubmissions(
        uint256 _numPayments,
        uint256 _amountPerPayment,
        uint32 _startTimestamp,
        uint32 duration
    ) public {
        ERC20Mock(helloWorldDeployment.token).mint(
            helloWorldConfig.rewardsInitiator, _amountPerPayment * _numPayments
        );
        ERC20Mock(helloWorldDeployment.token).increaseAllowance(
            helloWorldDeployment.helloWorldServiceManager, _amountPerPayment * _numPayments
        );
        address[] memory operators = new address[](2);
        operators[0] = operator1;
        operators[1] = operator2;

        SetupDistributionsLib.createOperatorDirectedAVSRewardsSubmissions(
            helloWorldDeployment.helloWorldServiceManager,
            operators,
            helloWorldDeployment.strategy,
            _numPayments,
            _amountPerPayment,
            duration,
            _startTimestamp
        );
    }

    function processClaim(
        string memory _filePath,
        uint256 _indexToProve,
        address _recipient,
        IRewardsCoordinator.EarnerTreeMerkleLeaf memory _earnerLeaf,
        uint32 _amountPerPayment
    ) public {
        SetupDistributionsLib.processClaim(
            IRewardsCoordinator(coreDeployment.rewardsCoordinator),
            _filePath,
            _indexToProve,
            _recipient,
            _earnerLeaf,
            NUM_TOKEN_EARNINGS,
            helloWorldDeployment.strategy,
            _amountPerPayment
        );
    }

    function submitPaymentRoot(
        address[] memory _earners,
        uint32 _endTimestamp,
        uint32 _numPayments,
        uint32 _amountPerPayment
    ) public {
        emit log_named_uint("cumumlativePaymentMultiplier", cumumlativePaymentMultiplier);
        bytes32[] memory tokenLeaves = SetupDistributionsLib.createTokenLeaves(
            IRewardsCoordinator(coreDeployment.rewardsCoordinator),
            NUM_TOKEN_EARNINGS,
            _amountPerPayment,
            helloWorldDeployment.strategy
        );
        IRewardsCoordinator.EarnerTreeMerkleLeaf[] memory _earnerLeaves =
            SetupDistributionsLib.createEarnerLeaves(_earners, tokenLeaves);
        emit log_named_uint("Earner Leaves Length", _earnerLeaves.length);
        emit log_named_uint("numPayments", _numPayments);

        SetupDistributionsLib.submitRoot(
            IRewardsCoordinator(coreDeployment.rewardsCoordinator),
            tokenLeaves,
            _earnerLeaves,
            _endTimestamp,
            _numPayments,
            NUM_TOKEN_EARNINGS,
            filePath
        );
    }

    function _getEarnerLeaves(
        address[] memory _earners,
        uint32 _amountPerPayment,
        address _strategy
    ) internal view returns (IRewardsCoordinator.EarnerTreeMerkleLeaf[] memory) {
        bytes32[] memory tokenLeaves = SetupDistributionsLib.createTokenLeaves(
            IRewardsCoordinator(coreDeployment.rewardsCoordinator),
            NUM_TOKEN_EARNINGS,
            _amountPerPayment,
            _strategy
        );

        IRewardsCoordinator.EarnerTreeMerkleLeaf[] memory _earnerLeaves =
            SetupDistributionsLib.createEarnerLeaves(_earners, tokenLeaves);

        return _earnerLeaves;
    }

    function _getEarners(
        address _deployer
    ) internal pure returns (address[] memory) {
        address[] memory _earners = new address[](NUM_EARNERS);
        for (uint256 i = 0; i < _earners.length; i++) {
            _earners[i] = _deployer;
        }
        return _earners;
    }
}

================
File: contracts/src/HelloWorldServiceManager.sol
================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

import {ECDSAServiceManagerBase} from
    "@eigenlayer-middleware/src/unaudited/ECDSAServiceManagerBase.sol";
import {ECDSAStakeRegistry} from "@eigenlayer-middleware/src/unaudited/ECDSAStakeRegistry.sol";
import {IServiceManager} from "@eigenlayer-middleware/src/interfaces/IServiceManager.sol";
import {ECDSAUpgradeable} from
    "@openzeppelin-upgrades/contracts/utils/cryptography/ECDSAUpgradeable.sol";
import {IERC1271Upgradeable} from
    "@openzeppelin-upgrades/contracts/interfaces/IERC1271Upgradeable.sol";
import {IHelloWorldServiceManager} from "./IHelloWorldServiceManager.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@eigenlayer/contracts/interfaces/IRewardsCoordinator.sol";
import {IAllocationManager} from "@eigenlayer/contracts/interfaces/IAllocationManager.sol";
import {TransparentUpgradeableProxy} from
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";

/**
 * @title Primary entrypoint for procuring services from HelloWorld.
 * @author Eigen Labs, Inc.
 */
contract HelloWorldServiceManager is ECDSAServiceManagerBase, IHelloWorldServiceManager {
    using ECDSAUpgradeable for bytes32;

    uint32 public latestTaskNum;

    // mapping of task indices to all tasks hashes
    // when a task is created, task hash is stored here,
    // and responses need to pass the actual task,
    // which is hashed onchain and checked against this mapping
    mapping(uint32 => bytes32) public allTaskHashes;

    // mapping of task indices to hash of abi.encode(taskResponse, taskResponseMetadata)
    mapping(address => mapping(uint32 => bytes)) public allTaskResponses;

    // mapping of task indices to task status (true if task has been responded to, false otherwise)
    // TODO: use bitmap?
    mapping(uint32 => bool) public taskWasResponded;

    // max interval in blocks for responding to a task
    // operators can be penalized if they don't respond in time
    uint32 public immutable MAX_RESPONSE_INTERVAL_BLOCKS;

    modifier onlyOperator() {
        require(
            ECDSAStakeRegistry(stakeRegistry).operatorRegistered(msg.sender),
            "Operator must be the caller"
        );
        _;
    }

    constructor(
        address _avsDirectory,
        address _stakeRegistry,
        address _rewardsCoordinator,
        address _delegationManager,
        address _allocationManager,
        uint32 _maxResponseIntervalBlocks
    )
        ECDSAServiceManagerBase(
            _avsDirectory,
            _stakeRegistry,
            _rewardsCoordinator,
            _delegationManager,
            _allocationManager
        )
    {
        MAX_RESPONSE_INTERVAL_BLOCKS = _maxResponseIntervalBlocks;
    }

    function initialize(address initialOwner, address _rewardsInitiator) external initializer {
        __ServiceManagerBase_init(initialOwner, _rewardsInitiator);
    }

    // These are just to comply with IServiceManager interface
    function addPendingAdmin(
        address admin
    ) external onlyOwner {}

    function removePendingAdmin(
        address pendingAdmin
    ) external onlyOwner {}

    function removeAdmin(
        address admin
    ) external onlyOwner {}

    function setAppointee(address appointee, address target, bytes4 selector) external onlyOwner {}

    function removeAppointee(
        address appointee,
        address target,
        bytes4 selector
    ) external onlyOwner {}

    function deregisterOperatorFromOperatorSets(
        address operator,
        uint32[] memory operatorSetIds
    ) external {
        // unused
    }

    /* FUNCTIONS */
    // NOTE: this function creates new task, assigns it a taskId
    function createNewTask(
        string memory name
    ) external returns (Task memory) {
        // create a new task struct
        Task memory newTask;
        newTask.name = name;
        newTask.taskCreatedBlock = uint32(block.number);

        // store hash of task onchain, emit event, and increase taskNum
        allTaskHashes[latestTaskNum] = keccak256(abi.encode(newTask));
        emit NewTaskCreated(latestTaskNum, newTask);
        latestTaskNum = latestTaskNum + 1;

        return newTask;
    }

    function respondToTask(
        Task calldata task,
        uint32 referenceTaskIndex,
        bytes memory signature
    ) external {
        // check that the task is valid, hasn't been responded yet, and is being responded in time
        require(
            keccak256(abi.encode(task)) == allTaskHashes[referenceTaskIndex],
            "supplied task does not match the one recorded in the contract"
        );
        require(
            block.number <= task.taskCreatedBlock + MAX_RESPONSE_INTERVAL_BLOCKS,
            "Task response time has already expired"
        );

        // The message that was signed
        bytes32 messageHash = keccak256(abi.encodePacked("Hello, ", task.name));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        bytes4 magicValue = IERC1271Upgradeable.isValidSignature.selector;

        // Decode the signature data to get operators and their signatures
        (address[] memory operators, bytes[] memory signatures, uint32 referenceBlock) =
            abi.decode(signature, (address[], bytes[], uint32));

        // Check that referenceBlock matches task creation block
        require(
            referenceBlock == task.taskCreatedBlock,
            "Reference block must match task creation block"
        );

        // Store each operator's signature
        for (uint256 i = 0; i < operators.length; i++) {
            // Check that this operator hasn't already responded
            require(
                allTaskResponses[operators[i]][referenceTaskIndex].length == 0,
                "Operator has already responded to the task"
            );

            // Store the operator's signature
            allTaskResponses[operators[i]][referenceTaskIndex] = signatures[i];

            // Emit event for this operator
            emit TaskResponded(referenceTaskIndex, task, operators[i]);
        }

        taskWasResponded[referenceTaskIndex] = true;

        // Verify all signatures at once
        bytes4 isValidSignatureResult =
            ECDSAStakeRegistry(stakeRegistry).isValidSignature(ethSignedMessageHash, signature);

        require(magicValue == isValidSignatureResult, "Invalid signature");
    }

    function slashOperator(
        Task calldata task,
        uint32 referenceTaskIndex,
        address operator
    ) external {
        // check that the task is valid, hasn't been responsed yet
        require(
            keccak256(abi.encode(task)) == allTaskHashes[referenceTaskIndex],
            "supplied task does not match the one recorded in the contract"
        );
        require(!taskWasResponded[referenceTaskIndex], "Task has already been responded to");
        require(
            allTaskResponses[operator][referenceTaskIndex].length == 0,
            "Operator has already responded to the task"
        );
        require(
            block.number > task.taskCreatedBlock + MAX_RESPONSE_INTERVAL_BLOCKS,
            "Task response time has not expired yet"
        );
        // check operator was registered when task was created
        uint256 operatorWeight = ECDSAStakeRegistry(stakeRegistry).getOperatorWeightAtBlock(
            operator, task.taskCreatedBlock
        );
        require(operatorWeight > 0, "Operator was not registered when task was created");

        // we update the storage with a sentinel value
        allTaskResponses[operator][referenceTaskIndex] = "slashed";

        // TODO: slash operator
    }
}

================
File: contracts/src/IHelloWorldServiceManager.sol
================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

interface IHelloWorldServiceManager {
    event NewTaskCreated(uint32 indexed taskIndex, Task task);

    event TaskResponded(uint32 indexed taskIndex, Task task, address operator);

    struct Task {
        string name;
        uint32 taskCreatedBlock;
    }

    function latestTaskNum() external view returns (uint32);

    function allTaskHashes(
        uint32 taskIndex
    ) external view returns (bytes32);

    function allTaskResponses(
        address operator,
        uint32 taskIndex
    ) external view returns (bytes memory);

    function createNewTask(
        string memory name
    ) external returns (Task memory);

    function respondToTask(
        Task calldata task,
        uint32 referenceTaskIndex,
        bytes calldata signature
    ) external;

    function slashOperator(
        Task calldata task,
        uint32 referenceTaskIndex,
        address operator
    ) external;
}

================
File: contracts/test/mockData/config/core/1337.json
================
{
  "strategyManager": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "initialStrategyWhitelister": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
  },
  "delegationManager": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "minWithdrawalDelayBlocks": 50400
  },
  "eigenPodManager": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
  },
  "allocationManager": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "deallocationDelay": 0,
    "allocationConfigurationDelay": 0
  },
  "strategyFactory": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
  },
  "avsDirectory": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
  },
  "rewardsCoordinator": {
    "initPausedStatus": 0,
    "initialOwner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "rewardsUpdater": "0x1234567890123456789012345678901234567890",
    "activationDelay": 604800,
    "defaultSplitBips": 1000,
    "calculationIntervalSeconds": 86400,
    "maxRewardsDuration": 864000,
    "maxRetroactiveLength": 86400,
    "maxFutureLength": 86400,
    "genesisRewardsTimestamp": 1672531200
  }
}

================
File: contracts/test/mockData/config/hello-world/1337.json
================
{
  "rewardsOwner": "0x",
  "rewardsInitiator": "0x"
}

================
File: contracts/test/mockData/deployments/core/1337.json
================
{
  "lastUpdate": {
    "timestamp": "1740693626",
    "block_number": "0"
  },
  "addresses": {
    "proxyAdmin": "0x5fbdb2315678afecb367f032d93f642f64180aa3",
    "delegationManager": "0x9fe46736679d2d9a65f0992f2272de9f3c7fa6e0",
    "delegationManagerImpl": "0xa85233c63b9ee964add6f2cffe00fd84eb32338f",
    "avsDirectory": "0xdc64a140aa3e981100a9beca4e685f962f0cf6c9",
    "avsDirectoryImpl": "0x4a679253410272dd5232b3ff7cf5dbb88f295319",
    "strategyManager": "0x0165878a594ca255338adfa4d48449f69242eb8f",
    "strategyManagerImpl": "0x4ed7c70f96b99c776995fb64377f0d4ab3b0e1c1",
    "eigenPodManager": "0x2279b7a0a67db372996a5fab50d91eaa73d2ebe6",
    "eigenPodManagerImpl": "0xa82ff9afd8f496c3d6ac40e2a0f282e47488cfc9",
    "allocationManager": "0x610178da211fef7d417bc0e6fed39f05609ad788",
    "allocationManagerImpl": "0x322813fd9a801c5507c9de605d63cea4f2ce6c44",
    "eigenPodBeacon": "0xa51c1fc2f0d1a1b8494ed1fe312d7c3a78ed91c0",
    "pauserRegistry": "0x9a676e781a523b5d0c0e43731313a708cb607508",
    "pauserRegistryImpl": "0x0dcd1bf9a1b36ce34237eeafef220932846bcd82",
    "strategyFactory": "0x959922be3caee4b8cd9a407cc3ac1c251c2007b1",
    "strategyFactoryImpl": "0x95401dc811bb5740090279ba06cfa8fcf6113778",
    "strategyBeacon": "0xf5059a5d33d5853360d16c683c16e67980206f36",
    "rewardsCoordinator": "0x68b1d87f95878fe05b998f19b66f4baba5de1aed",
    "rewardsCoordinatorImpl": "0x70e0ba845a1a0f2da3359c97e0285013525ffc49",
    "permissionController": "0xc6e7df5e7b4f2a278906862b61205850344d4e7d",
    "permissionControllerImpl": "0x59b670e9fa9d0a427751af201d676719a970857b"
  }
}

================
File: contracts/test/mockData/deployments/hello-world/1337.json
================
{
  "lastUpdate": {
    "timestamp": "1740693629",
    "block_number": "39"
  },
  "addresses": {
    "proxyAdmin": "0x8f86403a4de0bb5791fa46b8e795c547942fe4cf",
    "helloWorldServiceManager": "0x5eb3bc0a489c5a8288765d2336659ebca68fcd00",
    "helloWorldServiceManagerImpl": "0x5f3f1dbd7b74c6b46e8c44f98792a1daf8d69154",
    "stakeRegistry": "0x809d550fca64d94bd9f66e60752a544199cfac3d",
    "stakeRegistryImpl": "0x4c5859f0f772848b2d91f1d83e2fe57935348029",
    "strategy": "0x24b3c7704709ed1491473f30393ffc93cfb0fc34",
    "token": "0x99bba657f2bbc93c02d617f8ba121cb8fc104acf"
  }
}

================
File: contracts/test/mockData/scratch/31337.json
================
{"lastUpdate":{"timestamp":"1","block_number":"1"},"addresses":{"proxyAdmin":"0x5615deb798bb3e4dfa0139dfa1b3d433cc23b72f","delegation":"0xf62849f9a0b5bf2913b396098f7c7019b51a820a","delegationManagerImpl":"0xdb25a7b768311de128bbda7b8426c3f9c74f3240","avsDirectory":"0xc7183455a4c133ae270771860664b6b7ec320bb1","avsDirectoryImpl":"0x3381cd18e2fb4db236bf0525938ab6e43db0440f","strategyManager":"0x1d1499e622d69689cdf9004d05ec547d650ff211","strategyManagerImpl":"0x756e0562323adcda4430d6cb456d9151f605290b","eigenPodManager":"0x03a6a84cd762d9707a21605b548aaab891562aab","eigenPodManagerImpl":"0xe8dc788818033232ef9772cb2e6622f1ec8bc840","strategyFactory":"0x13aa49bac059d709dd0a18d6bb63290076a702d7","strategyFactoryImpl":"0x1af7f588a501ea2b5bb3feefa744892aa2cf00e6","strategyBeacon":"0x886d6d1eb8d415b00052828cd6d5b321f072073d","rewardsCoordinator":"0x15cf58144ef33af1e14b5208015d11f9143e27b9"}}

================
File: contracts/test/mockData/scratch/payment_info.json
================
{
    "paymentInfo": {
        "recipient": "0x5555666677778888999900001111222233334444",
        "numPayments": 8,
        "amountPerPayment": "100000000000",
        "duration": 2592000,
        "startTimestamp": 864000,
        "endTimestamp": 1701907200,
        "indexToProve": 0
    }
}

================
File: contracts/test/mockData/scratch/payments_test.json
================
{
    "leaves": [
      "0x29036a1d92861ffd464a1e285030fad3978a36f953ae33c160e606d2ac746c42",
      "0x29036a1d92861ffd464a1e285030fad3978a36f953ae33c160e606d2ac746c42",
      "0x29036a1d92861ffd464a1e285030fad3978a36f953ae33c160e606d2ac746c42",
      "0x29036a1d92861ffd464a1e285030fad3978a36f953ae33c160e606d2ac746c42"
    ],
    "tokenLeaves": [
      "0xf5d87050cb923194fe63c7ed2c45cbc913fa6ecf322f3631149c36d9460b3ad6"
    ]
  }

================
File: contracts/test/mockData/scratch/payments.json
================
{
  "leaves": [
    "0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c",
    "0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c",
    "0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c",
    "0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c",
    "0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c",
    "0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c",
    "0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c",
    "0x356fc063496b2cb93d500f88a326bc90c734137e93310643119b81618f40273c"
  ],
  "tokenLeaves": [
    "0xb85e3af535d0b85802155d225e67e51112a9404dba7a93c4dcfaca8ae5b9be9e"
  ]
}

================
File: contracts/test/CoreDeploymentLib.t.sol
================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import {Test} from "forge-std/Test.sol";
import {console2} from "forge-std/console2.sol";
import {
    CoreDeployLib, CoreDeploymentParsingLib
} from "../script/utils/CoreDeploymentParsingLib.sol";
import {UpgradeableProxyLib} from "../script/utils/UpgradeableProxyLib.sol";

contract CoreDeploymentParsingLibTest is Test {
    using UpgradeableProxyLib for address;

    address proxyAdmin;
    CoreDeployLib.DeploymentData deploymentData;
    CoreDeployLib.DeploymentConfigData configData;

    function setUp() public {
        proxyAdmin = UpgradeableProxyLib.deployProxyAdmin();
    }

    /// won't test specific functionality/values. Testing behavior of the library
    function test_ReadConfig() public view {
        CoreDeploymentParsingLib.readDeploymentConfigValues("test/mockData/config/core/", 1337);
    }

    /// forge-config: default.allow_internal_expect_revert = true
    function test_ReadConfig_Reverts() public {
        vm.expectRevert();
        /// Incorrect path
        CoreDeploymentParsingLib.readDeploymentConfigValues("test/mockData/deployments/core/", 1337);
    }

    function test_ReadDeployment() public view {
        CoreDeploymentParsingLib.readDeploymentJson("test/mockData/deployments/core/", 1337);
    }

    /// forge-config: default.allow_internal_expect_revert = true
    function test_ReadDeployment_Reverts() public {
        vm.expectRevert();
        /// Incorrect path
        CoreDeploymentParsingLib.readDeploymentJson("test/mockData/config/core/", 1337);
    }

    function test_DeployContracts() public {
        configData =
            CoreDeploymentParsingLib.readDeploymentConfigValues("test/mockData/config/core/", 1337);
        deploymentData = CoreDeployLib.deployContracts(proxyAdmin, configData);

        assertTrue(deploymentData.delegationManager != address(0), "DelegationManager not deployed");
        assertTrue(deploymentData.avsDirectory != address(0), "AVSDirectory not deployed");
        assertTrue(deploymentData.strategyManager != address(0), "StrategyManager not deployed");
    }

    function test_WriteDeploymentJson() public {
        configData =
            CoreDeploymentParsingLib.readDeploymentConfigValues("test/mockData/config/core/", 1337);
        deploymentData = CoreDeployLib.deployContracts(proxyAdmin, configData);

        string memory scratchPath = "test/mockData/scratch/test_WriteDeploymentJson/";
        CoreDeploymentParsingLib.writeDeploymentJson(scratchPath, block.chainid, deploymentData);

        string memory fileName = string.concat(scratchPath, vm.toString(block.chainid), ".json");
        assertTrue(vm.exists(fileName), "Deployment file not created");

        vm.removeFile(fileName);
    }

    function test_WriteAndReadDeploymentJson() public {
        configData =
            CoreDeploymentParsingLib.readDeploymentConfigValues("test/mockData/config/core/", 1337);
        deploymentData = CoreDeployLib.deployContracts(proxyAdmin, configData);

        string memory scratchPath = "test/mockData/scratch/test_WriteAndReadDeploymentJson/";

        CoreDeploymentParsingLib.writeDeploymentJson(scratchPath, block.chainid, deploymentData);

        string memory fileName = string.concat(vm.toString(block.chainid), ".json");

        CoreDeploymentParsingLib.readDeploymentJson(scratchPath, fileName);

        vm.removeFile(string.concat(scratchPath, fileName));
    }

    function test_ReadConfigFromM2DeploymentData() public {
        /// TODO: Deployment json is missing the strategy factory
        vm.skip(true);
        // Path to the M2 deployment data JSON file
        string memory m2DeploymentDataPath =
            "lib/eigenlayer-middleware/lib/eigenlayer-contracts/script/output/devnet/";
        string memory m2DeploymentFilename = "M2_from_scratch_deployment_data.json";

        CoreDeploymentParsingLib.readDeploymentJson(m2DeploymentDataPath, m2DeploymentFilename);
    }
}

================
File: contracts/test/ERC20Mock.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract ERC20Mock is ERC20 {
    constructor() ERC20("", "") {}

    function mint(address account, uint256 amount) public {
        _mint(account, amount);
    }
}

================
File: contracts/test/HelloWorldServiceManager.t.sol
================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.12;

import {HelloWorldServiceManager} from "../src/HelloWorldServiceManager.sol";
import {MockAVSDeployer} from "@eigenlayer-middleware/test/utils/MockAVSDeployer.sol";
import {ECDSAStakeRegistry} from "@eigenlayer-middleware/src/unaudited/ECDSAStakeRegistry.sol";
import {Vm} from "forge-std/Vm.sol";
import {console2} from "forge-std/Test.sol";
import {HelloWorldDeploymentLib} from "../script/utils/HelloWorldDeploymentLib.sol";
import {
    CoreDeployLib, CoreDeploymentParsingLib
} from "../script/utils/CoreDeploymentParsingLib.sol";
import {UpgradeableProxyLib} from "../script/utils/UpgradeableProxyLib.sol";
import {ERC20Mock} from "./ERC20Mock.sol";
import {IERC20, StrategyFactory} from "@eigenlayer/contracts/strategies/StrategyFactory.sol";

import {
    IECDSAStakeRegistryTypes,
    IStrategy
} from "@eigenlayer-middleware/src/interfaces/IECDSAStakeRegistry.sol";
import {IStrategyManager} from "@eigenlayer/contracts/interfaces/IStrategyManager.sol";
import {
    IDelegationManager,
    IDelegationManagerTypes
} from "@eigenlayer/contracts/interfaces/IDelegationManager.sol";
import {DelegationManager} from "@eigenlayer/contracts/core/DelegationManager.sol";
import {StrategyManager} from "@eigenlayer/contracts/core/StrategyManager.sol";
import {ISignatureUtilsMixinTypes} from "@eigenlayer/contracts/interfaces/ISignatureUtilsMixin.sol";
import {AVSDirectory} from "@eigenlayer/contracts/core/AVSDirectory.sol";
import {IAVSDirectoryTypes} from "@eigenlayer/contracts/interfaces/IAVSDirectory.sol";
import {Test, console2 as console} from "forge-std/Test.sol";
import {IHelloWorldServiceManager} from "../src/IHelloWorldServiceManager.sol";
import {ECDSAUpgradeable} from
    "@openzeppelin-upgrades/contracts/utils/cryptography/ECDSAUpgradeable.sol";

contract HelloWorldTaskManagerSetup is Test {
    // used for `toEthSignedMessageHash`
    using ECDSAUpgradeable for bytes32;

    IECDSAStakeRegistryTypes.Quorum internal quorum;

    struct Operator {
        Vm.Wallet key;
        Vm.Wallet signingKey;
    }

    struct TrafficGenerator {
        Vm.Wallet key;
    }

    struct AVSOwner {
        Vm.Wallet key;
    }

    Operator[] internal operators;
    TrafficGenerator internal generator;
    AVSOwner internal owner;

    HelloWorldDeploymentLib.DeploymentData internal helloWorldDeployment;
    CoreDeployLib.DeploymentData internal coreDeployment;
    CoreDeployLib.DeploymentConfigData coreConfigData;

    address proxyAdmin;

    ERC20Mock public mockToken;

    mapping(address => IStrategy) public tokenToStrategy;

    function setUp() public virtual {
        generator = TrafficGenerator({key: vm.createWallet("generator_wallet")});
        owner = AVSOwner({key: vm.createWallet("owner_wallet")});

        proxyAdmin = UpgradeableProxyLib.deployProxyAdmin();

        coreConfigData =
            CoreDeploymentParsingLib.readDeploymentConfigValues("test/mockData/config/core/", 1337);
        coreDeployment = CoreDeployLib.deployContracts(proxyAdmin, coreConfigData);

        vm.prank(coreConfigData.strategyManager.initialOwner);
        StrategyManager(coreDeployment.strategyManager).setStrategyWhitelister(
            coreDeployment.strategyFactory
        );

        mockToken = new ERC20Mock();

        IStrategy strategy = addStrategy(address(mockToken));
        quorum.strategies.push(
            IECDSAStakeRegistryTypes.StrategyParams({strategy: strategy, multiplier: 10_000})
        );

        helloWorldDeployment = HelloWorldDeploymentLib.deployContracts(
            proxyAdmin, coreDeployment, quorum, owner.key.addr, owner.key.addr
        );
        helloWorldDeployment.strategy = address(strategy);
        helloWorldDeployment.token = address(mockToken);
        labelContracts(coreDeployment, helloWorldDeployment);
    }

    function addStrategy(
        address token
    ) public returns (IStrategy) {
        if (tokenToStrategy[token] != IStrategy(address(0))) {
            return tokenToStrategy[token];
        }

        StrategyFactory strategyFactory = StrategyFactory(coreDeployment.strategyFactory);
        IStrategy newStrategy = strategyFactory.deployNewStrategy(IERC20(token));
        tokenToStrategy[token] = newStrategy;
        return newStrategy;
    }

    function labelContracts(
        CoreDeployLib.DeploymentData memory _coreDeployment,
        HelloWorldDeploymentLib.DeploymentData memory _helloWorldDeployment
    ) internal {
        vm.label(_coreDeployment.delegationManager, "DelegationManager");
        vm.label(_coreDeployment.avsDirectory, "AVSDirectory");
        vm.label(_coreDeployment.strategyManager, "StrategyManager");
        vm.label(_coreDeployment.eigenPodManager, "EigenPodManager");
        vm.label(_coreDeployment.rewardsCoordinator, "RewardsCoordinator");
        vm.label(_coreDeployment.eigenPodBeacon, "EigenPodBeacon");
        vm.label(_coreDeployment.pauserRegistry, "PauserRegistry");
        vm.label(_coreDeployment.strategyFactory, "StrategyFactory");
        vm.label(_coreDeployment.strategyBeacon, "StrategyBeacon");
        vm.label(_helloWorldDeployment.helloWorldServiceManager, "HelloWorldServiceManager");
        vm.label(_helloWorldDeployment.stakeRegistry, "StakeRegistry");
    }

    function signWithOperatorKey(
        Operator memory operator,
        bytes32 digest
    ) internal pure returns (bytes memory) {
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(operator.key.privateKey, digest);
        return abi.encodePacked(r, s, v);
    }

    function signWithSigningKey(
        Operator memory operator,
        bytes32 digest
    ) internal pure returns (bytes memory) {
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(operator.signingKey.privateKey, digest);
        return abi.encodePacked(r, s, v);
    }

    function mintMockTokens(Operator memory operator, uint256 amount) internal {
        mockToken.mint(operator.key.addr, amount);
    }

    function depositTokenIntoStrategy(
        Operator memory operator,
        address token,
        uint256 amount
    ) internal returns (uint256) {
        IStrategy strategy = IStrategy(tokenToStrategy[token]);
        require(address(strategy) != address(0), "Strategy was not found");
        IStrategyManager strategyManager = IStrategyManager(coreDeployment.strategyManager);

        vm.startPrank(operator.key.addr);
        mockToken.approve(address(strategyManager), amount);
        uint256 shares = strategyManager.depositIntoStrategy(strategy, IERC20(token), amount);
        vm.stopPrank();

        return shares;
    }

    function registerAsOperator(
        Operator memory operator
    ) internal {
        IDelegationManager delegationManager = IDelegationManager(coreDeployment.delegationManager);

        vm.prank(operator.key.addr);
        delegationManager.registerAsOperator(address(0), 0, "");
    }

    function registerOperatorToAVS(
        Operator memory operator
    ) internal {
        ECDSAStakeRegistry stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);
        AVSDirectory avsDirectory = AVSDirectory(coreDeployment.avsDirectory);

        bytes32 salt = keccak256(abi.encodePacked(block.timestamp, operator.key.addr));
        uint256 expiry = block.timestamp + 1 hours;

        bytes32 operatorRegistrationDigestHash = avsDirectory
            .calculateOperatorAVSRegistrationDigestHash(
            operator.key.addr, address(helloWorldDeployment.helloWorldServiceManager), salt, expiry
        );

        bytes memory signature = signWithOperatorKey(operator, operatorRegistrationDigestHash);

        ISignatureUtilsMixinTypes.SignatureWithSaltAndExpiry memory operatorSignature =
        ISignatureUtilsMixinTypes.SignatureWithSaltAndExpiry({
            signature: signature,
            salt: salt,
            expiry: expiry
        });

        vm.prank(address(operator.key.addr));
        stakeRegistry.registerOperatorWithSignature(operatorSignature, operator.signingKey.addr);
    }

    function deregisterOperatorFromAVS(
        Operator memory operator
    ) internal {
        ECDSAStakeRegistry stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);

        vm.prank(operator.key.addr);
        stakeRegistry.deregisterOperator();
    }

    function createAndAddOperator() internal returns (Operator memory) {
        Vm.Wallet memory operatorKey =
            vm.createWallet(string.concat("operator", vm.toString(operators.length)));
        Vm.Wallet memory signingKey =
            vm.createWallet(string.concat("signing", vm.toString(operators.length)));

        Operator memory newOperator = Operator({key: operatorKey, signingKey: signingKey});

        operators.push(newOperator);
        return newOperator;
    }

    function updateOperatorWeights(
        Operator[] memory _operators
    ) internal {
        ECDSAStakeRegistry stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);

        address[] memory operatorAddresses = new address[](_operators.length);
        for (uint256 i = 0; i < _operators.length; i++) {
            operatorAddresses[i] = _operators[i].key.addr;
        }

        stakeRegistry.updateOperators(operatorAddresses);
    }

    function getOperators(
        uint256 numOperators
    ) internal view returns (Operator[] memory) {
        require(numOperators <= operators.length, "Not enough operators");

        Operator[] memory operatorsMem = new Operator[](numOperators);
        for (uint256 i = 0; i < numOperators; i++) {
            operatorsMem[i] = operators[i];
        }
        // Sort the operators by address
        for (uint256 i = 0; i < numOperators - 1; i++) {
            uint256 minIndex = i;
            // Find the minimum operator by address
            for (uint256 j = i + 1; j < numOperators; j++) {
                if (operatorsMem[minIndex].key.addr > operatorsMem[j].key.addr) {
                    minIndex = j;
                }
            }
            // Swap the minimum operator with the ith operator
            Operator memory temp = operatorsMem[i];
            operatorsMem[i] = operatorsMem[minIndex];
            operatorsMem[minIndex] = temp;
        }
        return operatorsMem;
    }

    function createTask(
        string memory taskName
    ) internal returns (IHelloWorldServiceManager.Task memory task, uint32 taskIndex) {
        IHelloWorldServiceManager helloWorldServiceManager =
            IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager);

        vm.prank(generator.key.addr);
        taskIndex = helloWorldServiceManager.latestTaskNum();
        task = helloWorldServiceManager.createNewTask(taskName);
        return (task, taskIndex);
    }

    function respondToTask(
        Operator[] memory operatorsMem,
        IHelloWorldServiceManager.Task memory task,
        uint32 referenceTaskIndex
    ) internal {
        bytes memory signedResponse = makeTaskResponse(operatorsMem, task);

        IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager).respondToTask(
            task, referenceTaskIndex, signedResponse
        );
    }

    function makeTaskResponse(
        Operator[] memory operatorsMem,
        IHelloWorldServiceManager.Task memory task
    ) internal pure returns (bytes memory) {
        bytes32 messageHash = keccak256(abi.encodePacked("Hello, ", task.name));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();

        address[] memory operatorAddrs = new address[](operatorsMem.length);
        for (uint256 i = 0; i < operatorsMem.length; i++) {
            operatorAddrs[i] = operatorsMem[i].key.addr;
        }
        bytes[] memory signatures = new bytes[](operatorsMem.length);
        for (uint256 i = 0; i < operatorsMem.length; i++) {
            signatures[i] = signWithSigningKey(operatorsMem[i], ethSignedMessageHash);
        }

        bytes memory signedTask = abi.encode(operatorAddrs, signatures, task.taskCreatedBlock);

        return signedTask;
    }

    function slashOperator(
        IHelloWorldServiceManager.Task memory task,
        uint32 referenceTaskIndex,
        address operator
    ) internal {
        IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager).slashOperator(
            task, referenceTaskIndex, operator
        );
    }
}

contract HelloWorldServiceManagerInitialization is HelloWorldTaskManagerSetup {
    function testInitialization() public view {
        ECDSAStakeRegistry stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);

        IECDSAStakeRegistryTypes.Quorum memory quorum = stakeRegistry.quorum();

        assertGt(quorum.strategies.length, 0, "No strategies in quorum");
        assertEq(
            address(quorum.strategies[0].strategy),
            address(tokenToStrategy[address(mockToken)]),
            "First strategy doesn't match mock token strategy"
        );

        assertTrue(helloWorldDeployment.stakeRegistry != address(0), "StakeRegistry not deployed");
        assertTrue(
            helloWorldDeployment.helloWorldServiceManager != address(0),
            "HelloWorldServiceManager not deployed"
        );
        assertTrue(coreDeployment.delegationManager != address(0), "DelegationManager not deployed");
        assertTrue(coreDeployment.avsDirectory != address(0), "AVSDirectory not deployed");
        assertTrue(coreDeployment.strategyManager != address(0), "StrategyManager not deployed");
        assertTrue(coreDeployment.eigenPodManager != address(0), "EigenPodManager not deployed");
        assertTrue(coreDeployment.strategyFactory != address(0), "StrategyFactory not deployed");
        assertTrue(coreDeployment.strategyBeacon != address(0), "StrategyBeacon not deployed");
    }
}

contract RegisterOperator is HelloWorldTaskManagerSetup {
    uint256 internal constant INITIAL_BALANCE = 100 ether;
    uint256 internal constant DEPOSIT_AMOUNT = 1 ether;
    uint256 internal constant OPERATOR_COUNT = 4;

    DelegationManager internal delegationManager;
    AVSDirectory internal avsDirectory;
    IHelloWorldServiceManager internal sm;
    ECDSAStakeRegistry internal stakeRegistry;

    function setUp() public virtual override {
        super.setUp();
        /// Setting to internal state for convenience
        delegationManager = DelegationManager(coreDeployment.delegationManager);
        avsDirectory = AVSDirectory(coreDeployment.avsDirectory);
        sm = IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager);
        stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);

        addStrategy(address(mockToken));

        while (operators.length < OPERATOR_COUNT) {
            createAndAddOperator();
        }

        for (uint256 i = 0; i < OPERATOR_COUNT; i++) {
            mintMockTokens(operators[i], INITIAL_BALANCE);

            depositTokenIntoStrategy(operators[i], address(mockToken), DEPOSIT_AMOUNT);

            registerAsOperator(operators[i]);
        }
    }

    function testVerifyOperatorStates() public view {
        for (uint256 i = 0; i < OPERATOR_COUNT; i++) {
            address operatorAddr = operators[i].key.addr;

            uint256 operatorShares =
                delegationManager.operatorShares(operatorAddr, tokenToStrategy[address(mockToken)]);
            assertEq(
                operatorShares, DEPOSIT_AMOUNT, "Operator shares in DelegationManager incorrect"
            );
        }
    }

    function test_RegisterOperatorToAVS() public {
        address operatorAddr = operators[0].key.addr;
        registerOperatorToAVS(operators[0]);
        assertTrue(
            avsDirectory.avsOperatorStatus(address(sm), operatorAddr)
                == IAVSDirectoryTypes.OperatorAVSRegistrationStatus.REGISTERED,
            "Operator not registered in AVSDirectory"
        );

        address signingKey = stakeRegistry.getLatestOperatorSigningKey(operatorAddr);
        assertTrue(signingKey != address(0), "Operator signing key not set in ECDSAStakeRegistry");

        uint256 operatorWeight = stakeRegistry.getLastCheckpointOperatorWeight(operatorAddr);
        assertTrue(operatorWeight > 0, "Operator weight not set in ECDSAStakeRegistry");
    }
}

contract CreateTask is HelloWorldTaskManagerSetup {
    IHelloWorldServiceManager internal sm;

    function setUp() public override {
        super.setUp();
        sm = IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager);
    }

    function testCreateTask() public {
        string memory taskName = "Test Task";

        vm.prank(generator.key.addr);
        IHelloWorldServiceManager.Task memory newTask = sm.createNewTask(taskName);

        require(
            sha256(abi.encodePacked(newTask.name)) == sha256(abi.encodePacked(taskName)),
            "Task name not set correctly"
        );
        require(
            newTask.taskCreatedBlock == uint32(block.number), "Task created block not set correctly"
        );
    }
}

contract RespondToTask is HelloWorldTaskManagerSetup {
    uint256 internal constant INITIAL_BALANCE = 100 ether;
    uint256 internal constant DEPOSIT_AMOUNT = 1 ether;
    uint256 internal constant OPERATOR_COUNT = 4;

    IDelegationManager internal delegationManager;
    AVSDirectory internal avsDirectory;
    IHelloWorldServiceManager internal sm;
    ECDSAStakeRegistry internal stakeRegistry;

    function setUp() public override {
        super.setUp();

        delegationManager = IDelegationManager(coreDeployment.delegationManager);
        avsDirectory = AVSDirectory(coreDeployment.avsDirectory);
        sm = IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager);
        stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);

        addStrategy(address(mockToken));

        while (operators.length < OPERATOR_COUNT) {
            createAndAddOperator();
        }

        for (uint256 i = 0; i < OPERATOR_COUNT; i++) {
            mintMockTokens(operators[i], INITIAL_BALANCE);

            depositTokenIntoStrategy(operators[i], address(mockToken), DEPOSIT_AMOUNT);

            registerAsOperator(operators[i]);

            registerOperatorToAVS(operators[i]);
        }
    }

    function testRespondToTask() public {
        (IHelloWorldServiceManager.Task memory newTask, uint32 taskIndex) = createTask("TestTask");

        Operator[] memory operatorsMem = getOperators(1);
        bytes memory signedResponse = makeTaskResponse(operatorsMem, newTask);

        vm.roll(block.number + 1);
        sm.respondToTask(newTask, taskIndex, signedResponse);
    }

    function testRespondToTaskWith2OperatorsAggregatedSignature() public {
        (IHelloWorldServiceManager.Task memory newTask, uint32 taskIndex) =
            createTask("TestTask2Aggregated");

        // Generate aggregated response with two operators
        Operator[] memory operatorsMem = getOperators(2);
        bytes memory signedResponse = makeTaskResponse(operatorsMem, newTask);

        vm.roll(block.number + 1);
        sm.respondToTask(newTask, taskIndex, signedResponse);
    }

    function testRespondToTaskWith3OperatorsAggregatedSignature() public {
        (IHelloWorldServiceManager.Task memory newTask, uint32 taskIndex) =
            createTask("TestTask3Aggregated");

        // Generate aggregated response with three operators
        Operator[] memory operatorsMem = getOperators(3);
        bytes memory signedResponse = makeTaskResponse(operatorsMem, newTask);

        vm.roll(block.number + 1);
        sm.respondToTask(newTask, taskIndex, signedResponse);
    }
}

contract SlashOperator is HelloWorldTaskManagerSetup {
    uint256 internal constant INITIAL_BALANCE = 100 ether;
    uint256 internal constant DEPOSIT_AMOUNT = 1 ether;
    uint256 internal constant OPERATOR_COUNT = 4;

    IDelegationManager internal delegationManager;
    AVSDirectory internal avsDirectory;
    IHelloWorldServiceManager internal sm;
    ECDSAStakeRegistry internal stakeRegistry;

    function setUp() public override {
        super.setUp();

        delegationManager = IDelegationManager(coreDeployment.delegationManager);
        avsDirectory = AVSDirectory(coreDeployment.avsDirectory);
        sm = IHelloWorldServiceManager(helloWorldDeployment.helloWorldServiceManager);
        stakeRegistry = ECDSAStakeRegistry(helloWorldDeployment.stakeRegistry);

        addStrategy(address(mockToken));

        while (operators.length < OPERATOR_COUNT) {
            createAndAddOperator();
        }

        for (uint256 i = 0; i < OPERATOR_COUNT; i++) {
            mintMockTokens(operators[i], INITIAL_BALANCE);

            depositTokenIntoStrategy(operators[i], address(mockToken), DEPOSIT_AMOUNT);

            registerAsOperator(operators[i]);

            registerOperatorToAVS(operators[i]);
        }
    }

    function testValidResponseIsNotSlashable() public {
        (IHelloWorldServiceManager.Task memory newTask, uint32 taskIndex) =
            createTask("TestValidResponseIsNotSlashable");

        Operator[] memory operatorsMem = getOperators(1);

        vm.roll(block.number + 1);
        respondToTask(operatorsMem, newTask, taskIndex);

        vm.expectRevert("Task has already been responded to");
        slashOperator(newTask, taskIndex, operatorsMem[0].key.addr);

        // TODO: check the operator's balance was not reduced
    }

    function testNoResponseIsSlashable() public {
        (IHelloWorldServiceManager.Task memory newTask, uint32 taskIndex) =
            createTask("TestNoResponseIsSlashable");

        Operator[] memory operatorsMem = getOperators(1);

        uint32 maxResponseIntervalBlocks =
            HelloWorldServiceManager(address(sm)).MAX_RESPONSE_INTERVAL_BLOCKS();
        vm.roll(block.number + maxResponseIntervalBlocks + 1);

        slashOperator(newTask, taskIndex, operatorsMem[0].key.addr);

        // TODO: check the operator's balance was reduced
    }

    function testMultipleSlashings() public {
        (IHelloWorldServiceManager.Task memory newTask, uint32 taskIndex) =
            createTask("TestMultipleSlashings");

        Operator[] memory operatorsMem = getOperators(3);

        uint32 maxResponseIntervalBlocks =
            HelloWorldServiceManager(address(sm)).MAX_RESPONSE_INTERVAL_BLOCKS();
        vm.roll(block.number + maxResponseIntervalBlocks + 1);

        slashOperator(newTask, taskIndex, operatorsMem[0].key.addr);
        slashOperator(newTask, taskIndex, operatorsMem[1].key.addr);
        slashOperator(newTask, taskIndex, operatorsMem[2].key.addr);

        // TODO: check the operator's balance was reduced
    }
}

================
File: contracts/test/SetupPaymentsLib.t.sol
================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../script/utils/SetupDistributionsLib.sol";
import "../script/utils/CoreDeploymentParsingLib.sol";
import "../script/utils/HelloWorldDeploymentLib.sol";
import "@eigenlayer/contracts/interfaces/IRewardsCoordinator.sol";
import "../src/IHelloWorldServiceManager.sol";
import "@eigenlayer/contracts/interfaces/IStrategy.sol";
import "@eigenlayer/contracts/libraries/Merkle.sol";
import "../script/DeployEigenLayerCore.s.sol";
import "../script/HelloWorldDeployer.s.sol";
import {StrategyFactory} from "@eigenlayer/contracts/strategies/StrategyFactory.sol";
import {HelloWorldTaskManagerSetup} from "test/HelloWorldServiceManager.t.sol";
import {ECDSAServiceManagerBase} from
    "@eigenlayer-middleware/src/unaudited/ECDSAServiceManagerBase.sol";
import {
    IECDSAStakeRegistryTypes,
    IStrategy
} from "@eigenlayer-middleware/src/interfaces/IECDSAStakeRegistry.sol";
import "@openzeppelin-upgrades/contracts/access/OwnableUpgradeable.sol";

contract TestConstants {
    uint256 constant NUM_PAYMENTS = 8;
    uint256 constant NUM_TOKEN_EARNINGS = 1;
    uint256 constant TOKEN_EARNINGS = 100;

    address RECIPIENT = address(1);
    address EARNER = address(2);
    uint256 INDEX_TO_PROVE = 0;
    uint256 NUM_EARNERS = 4;
}

contract SetupDistributionsLibTest is Test, TestConstants, HelloWorldTaskManagerSetup {
    using SetupDistributionsLib for *;

    Vm cheats = Vm(VM_ADDRESS);

    IRewardsCoordinator public rewardsCoordinator;
    IHelloWorldServiceManager public helloWorldServiceManager;
    IStrategy public strategy;

    address rewardsInitiator = address(1);
    address rewardsOwner = address(2);

    function setUp() public virtual override {
        proxyAdmin = UpgradeableProxyLib.deployProxyAdmin();
        coreConfigData =
            CoreDeploymentParsingLib.readDeploymentConfigValues("test/mockData/config/core/", 1337);
        coreDeployment = CoreDeployLib.deployContracts(proxyAdmin, coreConfigData);

        vm.prank(coreConfigData.strategyManager.initialOwner);
        StrategyManager(coreDeployment.strategyManager).setStrategyWhitelister(
            coreDeployment.strategyFactory
        );

        mockToken = new ERC20Mock();

        strategy = addStrategy(address(mockToken)); // Similar function to HW_SM test using strategy factory
        quorum.strategies.push(
            IECDSAStakeRegistryTypes.StrategyParams({strategy: strategy, multiplier: 10_000})
        );

        helloWorldDeployment = HelloWorldDeploymentLib.deployContracts(
            proxyAdmin, coreDeployment, quorum, rewardsInitiator, rewardsOwner
        );
        labelContracts(coreDeployment, helloWorldDeployment);

        cheats.prank(rewardsOwner);
        ECDSAServiceManagerBase(helloWorldDeployment.helloWorldServiceManager).setRewardsInitiator(
            rewardsInitiator
        );

        rewardsCoordinator = IRewardsCoordinator(coreDeployment.rewardsCoordinator);

        mockToken.mint(address(this), 100_000);
        mockToken.mint(address(rewardsCoordinator), 100_000);
        mockToken.mint(rewardsInitiator, 100_000);
    }

    function testSubmitRoot() public {
        address[] memory earners = new address[](NUM_EARNERS);
        for (uint256 i = 0; i < earners.length; i++) {
            earners[i] = address(1);
        }
        uint32 endTimestamp = rewardsCoordinator.currRewardsCalculationEndTimestamp() + 1 weeks;
        cheats.warp(endTimestamp + 1);

        bytes32[] memory tokenLeaves = SetupDistributionsLib.createTokenLeaves(
            rewardsCoordinator, NUM_TOKEN_EARNINGS, TOKEN_EARNINGS, address(strategy)
        );
        IRewardsCoordinator.EarnerTreeMerkleLeaf[] memory earnerLeaves =
            SetupDistributionsLib.createEarnerLeaves(earners, tokenLeaves);

        string memory filePath = "testSubmitRoot.json";

        cheats.startPrank(rewardsCoordinator.rewardsUpdater());
        SetupDistributionsLib.submitRoot(
            rewardsCoordinator, tokenLeaves, earnerLeaves, endTimestamp, NUM_EARNERS, 1, filePath
        );
        cheats.stopPrank();
        vm.removeFile(filePath);
    }

    function testWriteLeavesToJson() public {
        bytes32[] memory leaves = new bytes32[](2);
        leaves[0] = bytes32(uint256(1));
        leaves[1] = bytes32(uint256(2));

        bytes32[] memory tokenLeaves = new bytes32[](2);
        tokenLeaves[0] = bytes32(uint256(3));
        tokenLeaves[1] = bytes32(uint256(4));

        string memory filePath = "testWriteLeavesToJson.json";

        SetupDistributionsLib.writeLeavesToJson(leaves, tokenLeaves, filePath);

        assertTrue(vm.exists(filePath), "JSON file should be created");
        vm.removeFile(filePath);
    }

    function testParseLeavesFromJson() public {
        string memory filePath = "test_parse_payments.json";
        string memory jsonContent = '{"leaves":["0x1234"], "tokenLeaves":["0x5678"]}';
        vm.writeFile(filePath, jsonContent);

        SetupDistributionsLib.PaymentLeaves memory paymentLeaves =
            SetupDistributionsLib.parseLeavesFromJson(filePath);

        assertEq(paymentLeaves.leaves.length, 1, "Incorrect number of leaves");
        assertEq(paymentLeaves.tokenLeaves.length, 1, "Incorrect number of token leaves");

        vm.removeFile(filePath);
    }

    function testGenerateMerkleProof() public view {
        SetupDistributionsLib.PaymentLeaves memory paymentLeaves =
            SetupDistributionsLib.parseLeavesFromJson("test/mockData/scratch/payments_test.json");

        bytes32[] memory leaves = paymentLeaves.leaves;
        uint256 indexToProve = 0;

        bytes32[] memory proof = new bytes32[](2);
        proof[0] = leaves[1];
        proof[1] = keccak256(abi.encodePacked(leaves[2], leaves[3]));

        bytes memory proofBytesConstructed = abi.encodePacked(proof);
        bytes memory proofBytesCalculated =
            SetupDistributionsLib.generateMerkleProof(leaves, indexToProve);

        require(
            keccak256(proofBytesConstructed) == keccak256(proofBytesCalculated),
            "Proofs do not match"
        );

        bytes32 root = SetupDistributionsLib.merkleizeKeccak(leaves);

        require(
            Merkle.verifyInclusionKeccak(
                proofBytesCalculated, root, leaves[indexToProve], indexToProve
            )
        );
    }

    function testProcessClaim() public {
        emit log_named_address("token address", address(mockToken));
        string memory filePath = "testProcessClaim.json";

        address[] memory earners = new address[](NUM_EARNERS);
        for (uint256 i = 0; i < earners.length; i++) {
            earners[i] = address(1);
        }
        uint32 endTimestamp = rewardsCoordinator.currRewardsCalculationEndTimestamp() + 1 weeks;
        cheats.warp(endTimestamp + 1);

        bytes32[] memory tokenLeaves = SetupDistributionsLib.createTokenLeaves(
            rewardsCoordinator, NUM_TOKEN_EARNINGS, TOKEN_EARNINGS, address(strategy)
        );
        IRewardsCoordinator.EarnerTreeMerkleLeaf[] memory earnerLeaves =
            SetupDistributionsLib.createEarnerLeaves(earners, tokenLeaves);

        cheats.startPrank(rewardsCoordinator.rewardsUpdater());
        SetupDistributionsLib.submitRoot(
            rewardsCoordinator, tokenLeaves, earnerLeaves, endTimestamp, NUM_EARNERS, 1, filePath
        );
        cheats.stopPrank();

        cheats.warp(block.timestamp + 2 weeks);

        cheats.startPrank(earnerLeaves[INDEX_TO_PROVE].earner, earnerLeaves[INDEX_TO_PROVE].earner);
        SetupDistributionsLib.processClaim(
            rewardsCoordinator,
            filePath,
            INDEX_TO_PROVE,
            RECIPIENT,
            earnerLeaves[INDEX_TO_PROVE],
            NUM_TOKEN_EARNINGS,
            address(strategy),
            uint32(TOKEN_EARNINGS)
        );

        cheats.stopPrank();

        vm.removeFile(filePath);
    }

    function testCreateAVSRewardsSubmissions() public {
        uint256 numPayments = 5;
        uint256 amountPerPayment = 100;
        uint32 duration = rewardsCoordinator.MAX_REWARDS_DURATION();
        uint32 genesisTimestamp = rewardsCoordinator.GENESIS_REWARDS_TIMESTAMP();
        uint32 startTimestamp = genesisTimestamp + 10 days;
        cheats.warp(startTimestamp + 1);

        cheats.prank(rewardsInitiator);
        mockToken.increaseAllowance(
            helloWorldDeployment.helloWorldServiceManager, amountPerPayment * numPayments
        );

        cheats.startPrank(rewardsInitiator);
        SetupDistributionsLib.createAVSRewardsSubmissions(
            address(helloWorldDeployment.helloWorldServiceManager),
            address(strategy),
            numPayments,
            amountPerPayment,
            duration,
            startTimestamp
        );
    }
}

================
File: contracts/.env.example
================
PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
HOLESKY_PRIVATE_KEY=
HOLESKY_RPC_URL=
ETHERSCAN_API_KEY=

================
File: contracts/.gitignore
================
# Compiler files
cache/
out/

# Ignores development broadcast logs
broadcast/*

# Docs
docs/

# Dotenv file
.env


# DS_store files
.DS_Store
lib/.DS_Store

================
File: contracts/foundry.toml
================
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
fs_permissions = [{ access = "read-write", path = "./" }]
solc = "0.8.27"
optimizer = true
via_ir = true

remappings = [
    "@eigenlayer/=lib/eigenlayer-middleware/lib/eigenlayer-contracts/src/",
    "@eigenlayer-scripts/=lib/eigenlayer-middleware/lib/eigenlayer-contracts/script/",
    "@eigenlayer-middleware/=lib/eigenlayer-middleware/",
    "@openzeppelin/=lib/eigenlayer-middleware/lib/openzeppelin-contracts/",
    "@openzeppelin-upgrades/=lib/eigenlayer-middleware/lib/openzeppelin-contracts-upgradeable/",
    "forge-std/=lib/forge-std/src/",
]

# Ignore warnings from middleware
ignored_warnings_from = ["lib/eigenlayer-middleware"]

[rpc_endpoints]
mainnet = "${MAINNET_RPC_URL}"
holesky = "${HOLESKY_RPC_URL}"
sepolia = "${SEPOLIA_RPC_URL}"
anvil = "${ANVIL_RPC_URL}"

[etherscan]
mainnet = { key = "${ETHERSCAN_API_KEY}" }
sepolia = { key = "${ETHERSCAN_API_KEY}" }
holesky = { key = "${ETHERSCAN_API_KEY}" }

[fmt]
bracket_spacing = false
int_types = "long"
line_length = 100
multiline_func_header = "params_first"
number_underscore = "thousands"
quote_style = "double"
tab_width = 4

================
File: docs/FAQ.md
================
FAQ About The Repo

The goal is to be a list of random bespoke things that might not be immediately clear and if using an AI tool to ask questions about the repo can be a source for the AI to surface information to the user

Typescript Notes:

- We used ts-node in the repo as a dev dependency and dev commands use ts-node to run the typescript files so that there isn't an intermediate build step that the developer must call in the process to compile the typescript files to javascript and then separately use the output javascript.  This allows us to directly run the typescript files which get compiled on the fly.  We will still use tsc when creating production builds of our code but during development using ts-node has better UX and is more clear for developing

Solidity Notes:

- If you're running into low level errors with transactions being executed by ethers.js ie, code: BAD_DATA or returned with No Data related errors, then one solution to get more verbose errors is to compile and deploy your smart contracts with --revert-strings debug.  This will insert verbose revert strings to catch before a low level revert would happen in an anvil instance.



================
File: operator/e2e.test.ts
================
import { createAnvil, Anvil } from "@viem/anvil";
import { describe, beforeAll, afterAll, it, expect } from '@jest/globals';
import { exec } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import util from 'util';
import { ethers } from "ethers";
⋮----
async function loadJsonFile(filePath: string): Promise<any>
async function loadDeployments(): Promise<Record<string, any>>

================
File: operator/index.ts
================
import { ethers } from "ethers";
⋮----
// Check if the process.env object is empty
⋮----
// Setup env variables
⋮----
/// TODO: Hack
⋮----
// Load core deployment data
⋮----
const delegationManagerAddress = coreDeploymentData.addresses.delegationManager; // todo: reminder to fix the naming of this contract in the deployment file, change to delegationManager
⋮----
// Load ABIs
⋮----
// Initialize contract objects from ABIs
⋮----
const signAndRespondToTask = async (taskIndex: number, taskCreatedBlock: number, taskName: string) =>
const registerOperator = async () =>
⋮----
// Registers as an Operator in EigenLayer.
⋮----
"0x0000000000000000000000000000000000000000", // initDelegationApprover
0, // allocationDelay
"", // metadataURI
⋮----
const expiry = Math.floor(Date.now() / 1000) + 3600; // Example expiry, 1 hour from now
// Define the output structure
⋮----
// Calculate the digest hash, which is a unique value representing the operator, avs, unique value (salt) and expiration date.
⋮----
// Sign the digest hash with the operator's private key
⋮----
// Encode the signature in the required format
⋮----
// Register Operator to AVS
// Per release here: https://github.com/Layr-Labs/eigenlayer-middleware/blob/v0.2.1-mainnet-rewards/src/unaudited/ECDSAStakeRegistry.sol#L49
⋮----
const monitorNewTasks = async () =>
⋮----
//console.log(`Creating new task "EigenWorld"`);
//await helloWorldServiceManager.createNewTask("EigenWorld");
⋮----
const main = async () =>

================
File: scripts/rewards-script-check.sh
================
#!/bin/bash
# This flags makes the script exit if any command has a non-zero exit status, or 
# if tries to use a non defined variable
set -e -o nounset
# Execute anvil in background
anvil -q &
# Deploy contracts
make deploy-eigenlayer-contracts
make deploy-helloworld-contracts
# Check that at first, claimer balance in token is zero
initialBalance=$(make claimer-account-token-balance | tail -n1 | tr -d '[:space:]')
echo "Initial balance: '$initialBalance'"
if [ "$initialBalance" -ne 0 ]; then
    echo "claimer balance in token should be zero"
    exit 2
fi
# Create and claim normal distribution root
echo "Creating distribution root:"
make create-avs-distributions-root
echo "Claiming distribution root:"
make claim-distributions
# Check that after claim, claimer balance in token is 100
balanceAfterClaim=$(make claimer-account-token-balance | tail -n1 | tr -d '[:space:]')
echo "Balance after first claim: '$balanceAfterClaim'"
if [ "$balanceAfterClaim" -ne 100 ]; then
    echo "After first claim, claimer balance in token should be 100"
    exit 3
fi
# Create and claim operator directed distribution root
echo "Creating operator directed distribution root:"
make create-operator-directed-distributions-root
echo "Claiming distribution root:"
make claim-distributions
# Check that after another claim, claimer balance in token is 200
balanceAfterClaim=$(make claimer-account-token-balance | tail -n1 | tr -d '[:space:]')
echo "Balance after second claim: '$balanceAfterClaim'"
if [ "$balanceAfterClaim" -ne 200 ]; then
    echo "After second claim, claimer balance in token should be 200"
    exit 3
fi
# Kill anvil executing in background
kill $(pgrep anvil)

================
File: utils/abis.js
================
const artifactsDir = path.join(contractsDir, 'out');
⋮----
if (!fs.existsSync(abiDir)) {
fs.mkdirSync(abiDir);
⋮----
function checkArtifactsDirectory() {
if (!fs.existsSync(artifactsDir)) {
console.error(`The artifacts directory '${artifactsDir}' does not exist.`);
console.log('Please compile your contracts first using "forge build"');
process.exit(1);
⋮----
const files = fs.readdirSync(artifactsDir);
⋮----
console.error(`The artifacts directory '${artifactsDir}' is empty.`);
console.log('Please compile your contracts first using "forge build" or confirm the path is correct.');
⋮----
function extractAbi(contractName) {
const outputPath = path.join(artifactsDir, `${contractName}.sol`, `${contractName}.json`);
const abiOutputPath = path.join(abiDir, `${contractName}.json`);
⋮----
const contractData = JSON.parse(fs.readFileSync(outputPath, 'utf8'));
const abi = JSON.stringify(contractData.abi, null, 2);
fs.writeFileSync(abiOutputPath, abi);
console.log(`Extracted ABI for ${contractName}`);
⋮----
console.error(`Error extracting ABI for ${contractName}:`, error.message);
⋮----
checkArtifactsDirectory();
⋮----
extractAbi(contractName);
⋮----
console.log('ABI extraction complete. Check the "abis" directory for the output.');

================
File: .dockerignore
================
node_modules/
target/

================
File: .env.example
================
PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
OPERATOR_RESPONSE_PERCENTAGE=80
RPC_URL=http://localhost:8545
WS_URL=ws://localhost:8545

================
File: .gitignore
================
# Ignore node_modules directory
node_modules/

# Ignore built output
dist/

# Ignore environment-specific files
.env

# Ignore nixos related environment-specific files
.envrc
.cargo/
.direnv/

# Ignore editor-specific files
.vscode/
.idea/

# Ignore TypeScript build artifacts
dist/**/*.js
dist/*.js.map
dist/*.d.ts

# Ignore local anvil state
# utils/anvil/*.json
contracts/anvil/state.json

oldUtils

target/
debug/

yarn.lock
contracts/deployments/

**/.DS_Store

================
File: .gitmodules
================
[submodule "contracts/lib/forge-std"]
	path = contracts/lib/forge-std
	url = https://github.com/foundry-rs/forge-std
[submodule "contracts/lib/eigenlayer-middleware"]
	path = contracts/lib/eigenlayer-middleware
	url = https://github.com/Layr-Labs/eigenlayer-middleware


================
File: Dockerfile
================
FROM node:22

WORKDIR /app

COPY package.json ./
COPY tsconfig.json ./
RUN npm install

COPY . .

CMD ["npm", "start"]

================
File: jest.config.ts
================
import type { Config } from '@jest/types';
⋮----
testTimeout: 60000, // 60 seconds
maxWorkers: 1, // Run tests sequentially

================
File: LICENSE
================
Copyright 2024 Eigen Labs, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

================
File: Makefile
================
############################# HELP MESSAGE #############################
# Make sure the help command stays first, so that it's printed by default when `make` is called without arguments
.PHONY: help tests
help:
	@grep -E '^[a-zA-Z0-9_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'


RUST_BINDINGS_PATH:=operator/rust/crates/utils/src/bindings

-----------------------------: ##

___ANVIL_STATE___: ##
build-anvil-state-with-deployed-contracts: ## builds anvil state with deployed contracts and generates a state
	@chmod +x ./contracts/anvil/build-state.sh
	./contracts/anvil/build-state.sh

___CONTRACTS___: ##

build-contracts: ## builds all contracts
	cd contracts && forge build

deploy-eigenlayer-contracts:
	@chmod +x ./contracts/anvil/deploy-el.sh
	./contracts/anvil/deploy-el.sh

deploy-helloworld-contracts:
	@chmod +x ./contracts/anvil/deploy-helloworld.sh
	./contracts/anvil/deploy-helloworld.sh

generate-bindings:
	cd contracts && forge build --force --skip test --skip script
	rm -rf ${RUST_BINDINGS_PATH}
	forge bind --alloy --skip-build --overwrite --module \
		--root contracts/  \
		--bindings-path ${RUST_BINDINGS_PATH} \
		--select '^ECDSAStakeRegistry$$' --select '^HelloWorldServiceManager$$'

__CLI__: ##

send-fund: ## sends fund to the operator saved in tests/keys/test.ecdsa.key.json
	cast send 0x860B6912C2d0337ef05bbC89b0C2CB6CbAEAB4A5 --value 10ether \
		--private-key 

-----------------------------: ##
# We pipe all zapper logs through https://github.com/maoueh/zap-pretty so make sure to install it
# TODO: piping to zap-pretty only works when zapper environment is set to production, unsure why
____OFFCHAIN_SOFTWARE___:
start-operator: ## start operator (part of quickstart)
	tsc && node dist/index.js

spam-tasks: ## start tasks spamming (part of quickstart)
	tsc && node dist/createNewTasks.js

-----------------------------: ##
_____HELPER_____: ##
tests-contract: ## runs all forge tests
	cd contracts && forge test

___RUST_OFFCHAIN_SOFTWARE___:
start-rust-operator: ## start operator (part of quickstart) 
	cargo run --bin start_operator

spam-rust-tasks:  ## start tasks spamming (part of quickstart)
	cargo run --bin spam_tasks

start-rust-challenger: ## start challenger (part of quickstart)
	cargo run --bin challenger

__REWARDS__: ##

TOKEN_ADDRESS=$(shell jq -r '.addresses.token' contracts/deployments/hello-world/31337.json)

create-avs-distributions-root:
	npm run create-distributions-root

claim-distributions:
	npm run claim-distributions

create-operator-directed-distributions-root:
	npm run create-operator-directed-distributions-root

get-deployed-token-address:
	@echo "Deployed token Address: $(TOKEN_ADDRESS)"

claimer-account-token-balance:
	cast balance --erc20 $(TOKEN_ADDRESS) 0x0000000000000000000000000000000000000001

================
File: package.json
================
{
  "name": "hello-world-avs",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start:operator": "ts-node operator/index.ts",
    "start:traffic": "ts-node operator/createNewTasks.ts",
    "start:anvil": "anvil",
    "deploy:core": "cd contracts && forge script script/DeployEigenLayerCore.s.sol --rpc-url http://localhost:8545 --broadcast --optimize --optimizer-runs 200 --via-ir",
    "deploy:hello-world": "cd contracts && forge script script/HelloWorldDeployer.s.sol --rpc-url http://localhost:8545 --broadcast --optimize --optimizer-runs 200 --via-ir",
    "deploy:core-debug": "cd contracts && forge script script/DeployEigenLayerCore.s.sol --rpc-url http://localhost:8545 --broadcast --revert-strings debug --optimize --optimizer-runs 200 --via-ir",
    "deploy:hello-world-debug": "cd contracts && forge script script/HelloWorldDeployer.s.sol --rpc-url http://localhost:8545 --broadcast --revert-strings debug",
    "create-distributions-root": "cd contracts && forge script script/SetupDistributions.s.sol --rpc-url http://localhost:8545 --broadcast -v --sender 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
    "claim-distributions": "cd contracts && forge script script/SetupDistributions.s.sol --rpc-url http://localhost:8545 --broadcast --sig \"executeProcessClaim()\" -v --sender 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
    "create-operator-directed-distributions-root": "cd contracts && forge script script/SetupDistributions.s.sol --rpc-url http://localhost:8545 --broadcast --sig \"runOperatorDirected()\" -v --sender 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
    "build": "tsc",
    "build:forge": "cd contracts && forge build",
    "extract:abis": "node utils/abis.js",
    "test": "NODE_OPTIONS=\"$NODE_OPTIONS --experimental-vm-modules\" npx jest"
  },
  "dependencies": {
    "dotenv": "^10.0.0",
    "ethers": "^6.13.2"
  },
  "devDependencies": {
    "@types/jest": "^29.5.13",
    "@types/node": "^20.12.12",
    "@viem/anvil": "^0.0.10",
    "jest": "^29.7.0",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.5"
  }
}

================
File: README.md
================
# Hello World AVS

Welcome to the Hello World AVS. This project shows you the simplest functionality you can expect from an AVS. It will give you a concrete understanding of the basic components. For new users, please find [this video walkthrough](https://drive.google.com/file/d/1P6uA6kYWCbpeorTjADuoTlQ-q8uqwPZf/view?usp=sharing) of the hello world AVS repository.

## Architecture

![hello-world-png](./assets/hello-world-diagramv2.png)

### AVS User Flow

1) AVS consumer requests a "Hello World" message to be generated and signed.
2) HelloWorld contract receives the request and emits a NewTaskCreated event for the request.
3) All Operators who are registered to the AVS and has staked, delegated assets takes this request. Operator generates the requested message, hashes it, and signs the hash with their private key.
4) Each Operator submits their signed hash back to the HelloWorld AVS contract.
5) If the Operator is registered to the AVS and has the minimum needed stake, the submission is accepted.

That's it. This simple flow highlights some of the core mechanics of how AVSs work.


## Local Devnet Deployment

The following instructions explain how to manually deploy the AVS from scratch including EigenLayer and AVS specific contracts using Foundry (forge) to a local anvil chain, and start Typescript Operator application and tasks.

## Development Environment

This section describes the tooling required for local development.

Install dependencies:

- [Node](https://nodejs.org/en/download/)
- [Typescript](https://www.typescriptlang.org/download)
- [ts-node](https://www.npmjs.com/package/ts-node)
- [tcs](https://www.npmjs.com/package/tcs#installation)
- [npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)
- [Foundry](https://getfoundry.sh/)
- [ethers](https://www.npmjs.com/package/ethers)



## Quick start (TypeScript)

### Start Anvil Chain

In terminal window #1, execute the following commands:

```sh

# Install npm packages
npm install

# Start local anvil chain
npm run start:anvil
```

### Deploy Contracts and Start Operator

Open a separate terminal window #2, execute the following commands

```sh
# Setup .env file
cp .env.example .env
cp contracts/.env.example contracts/.env

# Updates dependencies if necessary and builds the contracts 
npm run build:forge

# Deploy the EigenLayer contracts
npm run deploy:core

# Deploy the Hello World AVS contracts
npm run deploy:hello-world

# (Optional) Update ABIs
npm run extract:abis

# Start the Operator application
npm run start:operator
```

### Create Hello-World-AVS Tasks

Open a separate terminal window #3, execute the following commands

```sh
# Start the createNewTasks application 
npm run start:traffic
```

### Create and Claim Distribution

In a terminal, start a new instance of anvil and deploy the core and avs contracts

```sh
# Start anvil
npm run start:anvil
# Deploy the EigenLayer contracts
npm run deploy:core

# Deploy the Hello World AVS contracts
npm run deploy:hello-world

```

In another terminal, run:

```sh
# Create distribution roots
npm run create-distributions-root

# Claim created distribution
npm run claim-distributions
```

To run operator directed rewards distribution, run:

```sh
#Create distribution roots
npm run create-operator-directed-distributions-root

# Claim created rewards distribution
npm run claim-distributions
```



## Help and Support

For help and support deploying and modifying this repo for your AVS, please:

1. Open a ticket via the intercom link at [support.eigenlayer.xyz](https://support.eigenlayer.xyz).
2. Include the necessary troubleshooting information for your environment:
  * Local anvil testing:
    * Redeploy your local test using `--revert-strings debug` flag via the following commands and retest: `npm run deploy:core-debug && npm run deploy:hello-world-debug`
    * Include the full stacktrace from your error as a .txt file attachment.
    * Create a minimal repo that demonstrates the behavior (fork or otherwise)
    * Steps require to reproduce issue (compile and cause the error)
  * Holesky testing:
    * Ensure contracts are verified on Holesky. Eg `forge verify-contract --chain-id 17000 --num-of-optimizations 200 src/YourContract.sol:YourContract YOUR_CONTRACT_ADDRESS`
    * Send us your transaction hash where your contract is failing. We will use Tenderly to debug (adjust gas limit) and/or cast to re-run the transaction (eg `cast call --trace "trace_replayTransaction(0xTransactionHash)"`).

## Contact Us

If you're planning to build an AVS and would like to speak with a member of the EigenLayer DevRel team to discuss your ideas or architecture, please fill out this form and we'll be in touch shortly: [EigenLayer AVS Intro Call](https://share.hsforms.com/1BksFoaPjSk2l3pQ5J4EVCAein6l)

## Disclaimers

- This repo is meant currently intended for _local anvil development testing_. Holesky deployment support will be added shortly.
- Users who wish to build an AVS for Production purposes will want to migrate from the `ECDSAServiceManagerBase` implementation in `HelloWorldServiceManager.sol` to a BLS style architecture using [RegistryCoordinator](https://github.com/Layr-Labs/eigenlayer-middleware/blob/dev/docs/RegistryCoordinator.md).

## Appendix (Future Capabilities In Progress)

### Adding a New Strategy

### Potential Enhancements to the AVS (for learning purposes)

The architecture can be further enhanced via:

- the nature of the request is more sophisticated than generating a constant string
- the operators might need to coordinate with each other
- the type of signature is different based on the constraints of the service
- the type and amount of security used to secure the AVS


================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES6",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "exclude": [
    "node_modules",
    "contracts"
  ]
}



================================================================
End of Codebase
================================================================
